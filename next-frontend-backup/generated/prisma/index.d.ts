
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model FinancialAuditLog
 * 
 */
export type FinancialAuditLog = $Result.DefaultSelection<Prisma.$FinancialAuditLogPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model TaxReturn
 * 
 */
export type TaxReturn = $Result.DefaultSelection<Prisma.$TaxReturnPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceLineItem
 * 
 */
export type InvoiceLineItem = $Result.DefaultSelection<Prisma.$InvoiceLineItemPayload>
/**
 * Model AIConversation
 * 
 */
export type AIConversation = $Result.DefaultSelection<Prisma.$AIConversationPayload>
/**
 * Model AIInsight
 * 
 */
export type AIInsight = $Result.DefaultSelection<Prisma.$AIInsightPayload>
/**
 * Model AIUsageTracking
 * 
 */
export type AIUsageTracking = $Result.DefaultSelection<Prisma.$AIUsageTrackingPayload>
/**
 * Model AICache
 * 
 */
export type AICache = $Result.DefaultSelection<Prisma.$AICachePayload>
/**
 * Model AIProviderHealth
 * 
 */
export type AIProviderHealth = $Result.DefaultSelection<Prisma.$AIProviderHealthPayload>
/**
 * Model basiq_users
 * 
 */
export type basiq_users = $Result.DefaultSelection<Prisma.$basiq_usersPayload>
/**
 * Model bank_connections
 * 
 */
export type bank_connections = $Result.DefaultSelection<Prisma.$bank_connectionsPayload>
/**
 * Model bank_accounts
 * 
 */
export type bank_accounts = $Result.DefaultSelection<Prisma.$bank_accountsPayload>
/**
 * Model bank_transactions
 * 
 */
export type bank_transactions = $Result.DefaultSelection<Prisma.$bank_transactionsPayload>
/**
 * Model basiq_webhooks
 * 
 */
export type basiq_webhooks = $Result.DefaultSelection<Prisma.$basiq_webhooksPayload>
/**
 * Model basiq_api_logs
 * 
 */
export type basiq_api_logs = $Result.DefaultSelection<Prisma.$basiq_api_logsPayload>
/**
 * Model Receipt
 * 
 */
export type Receipt = $Result.DefaultSelection<Prisma.$ReceiptPayload>
/**
 * Model Budget
 * 
 */
export type Budget = $Result.DefaultSelection<Prisma.$BudgetPayload>
/**
 * Model BudgetTracking
 * 
 */
export type BudgetTracking = $Result.DefaultSelection<Prisma.$BudgetTrackingPayload>
/**
 * Model FinancialInsight
 * 
 */
export type FinancialInsight = $Result.DefaultSelection<Prisma.$FinancialInsightPayload>
/**
 * Model Goal
 * 
 */
export type Goal = $Result.DefaultSelection<Prisma.$GoalPayload>
/**
 * Model AMLTransactionMonitoring
 * 
 */
export type AMLTransactionMonitoring = $Result.DefaultSelection<Prisma.$AMLTransactionMonitoringPayload>
/**
 * Model PrivacyConsent
 * 
 */
export type PrivacyConsent = $Result.DefaultSelection<Prisma.$PrivacyConsentPayload>
/**
 * Model DataAccessRequest
 * 
 */
export type DataAccessRequest = $Result.DefaultSelection<Prisma.$DataAccessRequestPayload>
/**
 * Model APRAIncidentReport
 * 
 */
export type APRAIncidentReport = $Result.DefaultSelection<Prisma.$APRAIncidentReportPayload>
/**
 * Model GSTTransactionDetail
 * 
 */
export type GSTTransactionDetail = $Result.DefaultSelection<Prisma.$GSTTransactionDetailPayload>
/**
 * Model ComplianceConfiguration
 * 
 */
export type ComplianceConfiguration = $Result.DefaultSelection<Prisma.$ComplianceConfigurationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  ACCOUNTANT: 'ACCOUNTANT',
  SUPPORT: 'SUPPORT'
};

export type Role = (typeof Role)[keyof typeof Role]


export const TaxResidency: {
  RESIDENT: 'RESIDENT',
  NON_RESIDENT: 'NON_RESIDENT',
  TEMPORARY_RESIDENT: 'TEMPORARY_RESIDENT'
};

export type TaxResidency = (typeof TaxResidency)[keyof typeof TaxResidency]


export const AuthEvent: {
  LOGIN: 'LOGIN',
  LOGIN_SUCCESS: 'LOGIN_SUCCESS',
  LOGIN_FAILED: 'LOGIN_FAILED',
  LOGOUT: 'LOGOUT',
  REGISTER: 'REGISTER',
  PASSWORD_RESET: 'PASSWORD_RESET',
  PASSWORD_RESET_REQUEST: 'PASSWORD_RESET_REQUEST',
  PASSWORD_RESET_SUCCESS: 'PASSWORD_RESET_SUCCESS',
  PASSWORD_CHANGE: 'PASSWORD_CHANGE',
  EMAIL_VERIFICATION: 'EMAIL_VERIFICATION',
  ACCOUNT_LOCKED: 'ACCOUNT_LOCKED',
  ACCOUNT_UNLOCKED: 'ACCOUNT_UNLOCKED',
  TWO_FACTOR_ENABLED: 'TWO_FACTOR_ENABLED',
  TWO_FACTOR_DISABLED: 'TWO_FACTOR_DISABLED',
  TWO_FACTOR_SUCCESS: 'TWO_FACTOR_SUCCESS',
  TWO_FACTOR_FAILED: 'TWO_FACTOR_FAILED',
  SESSION_EXPIRED: 'SESSION_EXPIRED',
  SUSPICIOUS_ACTIVITY: 'SUSPICIOUS_ACTIVITY'
};

export type AuthEvent = (typeof AuthEvent)[keyof typeof AuthEvent]


export const Plan: {
  SMART: 'SMART',
  PRO: 'PRO'
};

export type Plan = (typeof Plan)[keyof typeof Plan]


export const TaxReturnStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  REJECTED: 'REJECTED'
};

export type TaxReturnStatus = (typeof TaxReturnStatus)[keyof typeof TaxReturnStatus]


export const ReceiptStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  PROCESSED: 'PROCESSED',
  MANUAL_REVIEW: 'MANUAL_REVIEW',
  FAILED: 'FAILED',
  MATCHED: 'MATCHED'
};

export type ReceiptStatus = (typeof ReceiptStatus)[keyof typeof ReceiptStatus]


export const BudgetStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  DRAFT: 'DRAFT'
};

export type BudgetStatus = (typeof BudgetStatus)[keyof typeof BudgetStatus]


export const InsightPriority: {
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW'
};

export type InsightPriority = (typeof InsightPriority)[keyof typeof InsightPriority]


export const GoalStatus: {
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  PAUSED: 'PAUSED',
  CANCELLED: 'CANCELLED'
};

export type GoalStatus = (typeof GoalStatus)[keyof typeof GoalStatus]


export const FinancialOperation: {
  GOAL_CREATE: 'GOAL_CREATE',
  GOAL_UPDATE: 'GOAL_UPDATE',
  GOAL_DELETE: 'GOAL_DELETE',
  GOAL_COMPLETE: 'GOAL_COMPLETE',
  TRANSACTION_CREATE: 'TRANSACTION_CREATE',
  TRANSACTION_UPDATE: 'TRANSACTION_UPDATE',
  TRANSACTION_DELETE: 'TRANSACTION_DELETE',
  TRANSACTION_CATEGORIZE: 'TRANSACTION_CATEGORIZE',
  RECEIPT_UPLOAD: 'RECEIPT_UPLOAD',
  RECEIPT_PROCESS: 'RECEIPT_PROCESS',
  RECEIPT_UPDATE: 'RECEIPT_UPDATE',
  RECEIPT_DELETE: 'RECEIPT_DELETE',
  RECEIPT_MATCH: 'RECEIPT_MATCH',
  BANK_CONNECT: 'BANK_CONNECT',
  BANK_DISCONNECT: 'BANK_DISCONNECT',
  BANK_SYNC: 'BANK_SYNC',
  BANK_ACCOUNT_ADD: 'BANK_ACCOUNT_ADD',
  BANK_ACCOUNT_REMOVE: 'BANK_ACCOUNT_REMOVE',
  BUDGET_CREATE: 'BUDGET_CREATE',
  BUDGET_UPDATE: 'BUDGET_UPDATE',
  BUDGET_DELETE: 'BUDGET_DELETE',
  SUBSCRIPTION_CREATE: 'SUBSCRIPTION_CREATE',
  SUBSCRIPTION_UPDATE: 'SUBSCRIPTION_UPDATE',
  SUBSCRIPTION_CANCEL: 'SUBSCRIPTION_CANCEL',
  REPORT_GENERATE: 'REPORT_GENERATE',
  REPORT_EXPORT: 'REPORT_EXPORT',
  TAX_RETURN_CREATE: 'TAX_RETURN_CREATE',
  TAX_RETURN_UPDATE: 'TAX_RETURN_UPDATE',
  TAX_RETURN_SUBMIT: 'TAX_RETURN_SUBMIT',
  DATA_EXPORT: 'DATA_EXPORT',
  DATA_IMPORT: 'DATA_IMPORT',
  COMPLIANCE_CONSENT_GRANTED: 'COMPLIANCE_CONSENT_GRANTED',
  COMPLIANCE_CONSENT_REVOKED: 'COMPLIANCE_CONSENT_REVOKED',
  COMPLIANCE_DATA_ACCESS: 'COMPLIANCE_DATA_ACCESS',
  COMPLIANCE_DATA_DELETION: 'COMPLIANCE_DATA_DELETION',
  COMPLIANCE_REPORT_GENERATED: 'COMPLIANCE_REPORT_GENERATED',
  AML_TRANSACTION_FLAGGED: 'AML_TRANSACTION_FLAGGED',
  AML_REPORT_SUBMITTED: 'AML_REPORT_SUBMITTED'
};

export type FinancialOperation = (typeof FinancialOperation)[keyof typeof FinancialOperation]


export const AMLMonitoringType: {
  THRESHOLD_EXCEEDED: 'THRESHOLD_EXCEEDED',
  VELOCITY_CHECK: 'VELOCITY_CHECK',
  PATTERN_DETECTION: 'PATTERN_DETECTION',
  SUSPICIOUS_ACTIVITY: 'SUSPICIOUS_ACTIVITY',
  CUSTOMER_RISK_PROFILE: 'CUSTOMER_RISK_PROFILE',
  SANCTIONS_SCREENING: 'SANCTIONS_SCREENING'
};

export type AMLMonitoringType = (typeof AMLMonitoringType)[keyof typeof AMLMonitoringType]


export const ConsentType: {
  PRIVACY_POLICY: 'PRIVACY_POLICY',
  TERMS_OF_SERVICE: 'TERMS_OF_SERVICE',
  MARKETING_COMMUNICATIONS: 'MARKETING_COMMUNICATIONS',
  DATA_SHARING: 'DATA_SHARING',
  THIRD_PARTY_INTEGRATION: 'THIRD_PARTY_INTEGRATION',
  BIOMETRIC_DATA: 'BIOMETRIC_DATA'
};

export type ConsentType = (typeof ConsentType)[keyof typeof ConsentType]


export const ConsentStatus: {
  PENDING: 'PENDING',
  GRANTED: 'GRANTED',
  DENIED: 'DENIED',
  WITHDRAWN: 'WITHDRAWN',
  EXPIRED: 'EXPIRED'
};

export type ConsentStatus = (typeof ConsentStatus)[keyof typeof ConsentStatus]


export const DataRequestType: {
  ACCESS_REQUEST: 'ACCESS_REQUEST',
  PORTABILITY_REQUEST: 'PORTABILITY_REQUEST',
  DELETION_REQUEST: 'DELETION_REQUEST',
  CORRECTION_REQUEST: 'CORRECTION_REQUEST',
  RESTRICTION_REQUEST: 'RESTRICTION_REQUEST'
};

export type DataRequestType = (typeof DataRequestType)[keyof typeof DataRequestType]


export const DataRequestStatus: {
  PENDING: 'PENDING',
  VERIFIED: 'VERIFIED',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED'
};

export type DataRequestStatus = (typeof DataRequestStatus)[keyof typeof DataRequestStatus]


export const IncidentType: {
  DATA_BREACH: 'DATA_BREACH',
  SYSTEM_OUTAGE: 'SYSTEM_OUTAGE',
  SECURITY_INCIDENT: 'SECURITY_INCIDENT',
  COMPLIANCE_BREACH: 'COMPLIANCE_BREACH',
  OPERATIONAL_FAILURE: 'OPERATIONAL_FAILURE',
  THIRD_PARTY_FAILURE: 'THIRD_PARTY_FAILURE'
};

export type IncidentType = (typeof IncidentType)[keyof typeof IncidentType]


export const IncidentSeverity: {
  CRITICAL: 'CRITICAL',
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW'
};

export type IncidentSeverity = (typeof IncidentSeverity)[keyof typeof IncidentSeverity]


export const IncidentStatus: {
  OPEN: 'OPEN',
  INVESTIGATING: 'INVESTIGATING',
  CONTAINED: 'CONTAINED',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type IncidentStatus = (typeof IncidentStatus)[keyof typeof IncidentStatus]


export const GSTTreatment: {
  TAXABLE_SUPPLY: 'TAXABLE_SUPPLY',
  GST_FREE: 'GST_FREE',
  INPUT_TAXED: 'INPUT_TAXED',
  OUT_OF_SCOPE: 'OUT_OF_SCOPE'
};

export type GSTTreatment = (typeof GSTTreatment)[keyof typeof GSTTreatment]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type TaxResidency = $Enums.TaxResidency

export const TaxResidency: typeof $Enums.TaxResidency

export type AuthEvent = $Enums.AuthEvent

export const AuthEvent: typeof $Enums.AuthEvent

export type Plan = $Enums.Plan

export const Plan: typeof $Enums.Plan

export type TaxReturnStatus = $Enums.TaxReturnStatus

export const TaxReturnStatus: typeof $Enums.TaxReturnStatus

export type ReceiptStatus = $Enums.ReceiptStatus

export const ReceiptStatus: typeof $Enums.ReceiptStatus

export type BudgetStatus = $Enums.BudgetStatus

export const BudgetStatus: typeof $Enums.BudgetStatus

export type InsightPriority = $Enums.InsightPriority

export const InsightPriority: typeof $Enums.InsightPriority

export type GoalStatus = $Enums.GoalStatus

export const GoalStatus: typeof $Enums.GoalStatus

export type FinancialOperation = $Enums.FinancialOperation

export const FinancialOperation: typeof $Enums.FinancialOperation

export type AMLMonitoringType = $Enums.AMLMonitoringType

export const AMLMonitoringType: typeof $Enums.AMLMonitoringType

export type ConsentType = $Enums.ConsentType

export const ConsentType: typeof $Enums.ConsentType

export type ConsentStatus = $Enums.ConsentStatus

export const ConsentStatus: typeof $Enums.ConsentStatus

export type DataRequestType = $Enums.DataRequestType

export const DataRequestType: typeof $Enums.DataRequestType

export type DataRequestStatus = $Enums.DataRequestStatus

export const DataRequestStatus: typeof $Enums.DataRequestStatus

export type IncidentType = $Enums.IncidentType

export const IncidentType: typeof $Enums.IncidentType

export type IncidentSeverity = $Enums.IncidentSeverity

export const IncidentSeverity: typeof $Enums.IncidentSeverity

export type IncidentStatus = $Enums.IncidentStatus

export const IncidentStatus: typeof $Enums.IncidentStatus

export type GSTTreatment = $Enums.GSTTreatment

export const GSTTreatment: typeof $Enums.GSTTreatment

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.financialAuditLog`: Exposes CRUD operations for the **FinancialAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialAuditLogs
    * const financialAuditLogs = await prisma.financialAuditLog.findMany()
    * ```
    */
  get financialAuditLog(): Prisma.FinancialAuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taxReturn`: Exposes CRUD operations for the **TaxReturn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxReturns
    * const taxReturns = await prisma.taxReturn.findMany()
    * ```
    */
  get taxReturn(): Prisma.TaxReturnDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceLineItem`: Exposes CRUD operations for the **InvoiceLineItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceLineItems
    * const invoiceLineItems = await prisma.invoiceLineItem.findMany()
    * ```
    */
  get invoiceLineItem(): Prisma.InvoiceLineItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIConversation`: Exposes CRUD operations for the **AIConversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIConversations
    * const aIConversations = await prisma.aIConversation.findMany()
    * ```
    */
  get aIConversation(): Prisma.AIConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIInsight`: Exposes CRUD operations for the **AIInsight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIInsights
    * const aIInsights = await prisma.aIInsight.findMany()
    * ```
    */
  get aIInsight(): Prisma.AIInsightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIUsageTracking`: Exposes CRUD operations for the **AIUsageTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIUsageTrackings
    * const aIUsageTrackings = await prisma.aIUsageTracking.findMany()
    * ```
    */
  get aIUsageTracking(): Prisma.AIUsageTrackingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aICache`: Exposes CRUD operations for the **AICache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AICaches
    * const aICaches = await prisma.aICache.findMany()
    * ```
    */
  get aICache(): Prisma.AICacheDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIProviderHealth`: Exposes CRUD operations for the **AIProviderHealth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIProviderHealths
    * const aIProviderHealths = await prisma.aIProviderHealth.findMany()
    * ```
    */
  get aIProviderHealth(): Prisma.AIProviderHealthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.basiq_users`: Exposes CRUD operations for the **basiq_users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Basiq_users
    * const basiq_users = await prisma.basiq_users.findMany()
    * ```
    */
  get basiq_users(): Prisma.basiq_usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bank_connections`: Exposes CRUD operations for the **bank_connections** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bank_connections
    * const bank_connections = await prisma.bank_connections.findMany()
    * ```
    */
  get bank_connections(): Prisma.bank_connectionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bank_accounts`: Exposes CRUD operations for the **bank_accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bank_accounts
    * const bank_accounts = await prisma.bank_accounts.findMany()
    * ```
    */
  get bank_accounts(): Prisma.bank_accountsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bank_transactions`: Exposes CRUD operations for the **bank_transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bank_transactions
    * const bank_transactions = await prisma.bank_transactions.findMany()
    * ```
    */
  get bank_transactions(): Prisma.bank_transactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.basiq_webhooks`: Exposes CRUD operations for the **basiq_webhooks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Basiq_webhooks
    * const basiq_webhooks = await prisma.basiq_webhooks.findMany()
    * ```
    */
  get basiq_webhooks(): Prisma.basiq_webhooksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.basiq_api_logs`: Exposes CRUD operations for the **basiq_api_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Basiq_api_logs
    * const basiq_api_logs = await prisma.basiq_api_logs.findMany()
    * ```
    */
  get basiq_api_logs(): Prisma.basiq_api_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.receipt`: Exposes CRUD operations for the **Receipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Receipts
    * const receipts = await prisma.receipt.findMany()
    * ```
    */
  get receipt(): Prisma.ReceiptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budget`: Exposes CRUD operations for the **Budget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budgets
    * const budgets = await prisma.budget.findMany()
    * ```
    */
  get budget(): Prisma.BudgetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budgetTracking`: Exposes CRUD operations for the **BudgetTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BudgetTrackings
    * const budgetTrackings = await prisma.budgetTracking.findMany()
    * ```
    */
  get budgetTracking(): Prisma.BudgetTrackingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.financialInsight`: Exposes CRUD operations for the **FinancialInsight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialInsights
    * const financialInsights = await prisma.financialInsight.findMany()
    * ```
    */
  get financialInsight(): Prisma.FinancialInsightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.goal`: Exposes CRUD operations for the **Goal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Goals
    * const goals = await prisma.goal.findMany()
    * ```
    */
  get goal(): Prisma.GoalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aMLTransactionMonitoring`: Exposes CRUD operations for the **AMLTransactionMonitoring** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AMLTransactionMonitorings
    * const aMLTransactionMonitorings = await prisma.aMLTransactionMonitoring.findMany()
    * ```
    */
  get aMLTransactionMonitoring(): Prisma.AMLTransactionMonitoringDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.privacyConsent`: Exposes CRUD operations for the **PrivacyConsent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrivacyConsents
    * const privacyConsents = await prisma.privacyConsent.findMany()
    * ```
    */
  get privacyConsent(): Prisma.PrivacyConsentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataAccessRequest`: Exposes CRUD operations for the **DataAccessRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataAccessRequests
    * const dataAccessRequests = await prisma.dataAccessRequest.findMany()
    * ```
    */
  get dataAccessRequest(): Prisma.DataAccessRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aPRAIncidentReport`: Exposes CRUD operations for the **APRAIncidentReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more APRAIncidentReports
    * const aPRAIncidentReports = await prisma.aPRAIncidentReport.findMany()
    * ```
    */
  get aPRAIncidentReport(): Prisma.APRAIncidentReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gSTTransactionDetail`: Exposes CRUD operations for the **GSTTransactionDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GSTTransactionDetails
    * const gSTTransactionDetails = await prisma.gSTTransactionDetail.findMany()
    * ```
    */
  get gSTTransactionDetail(): Prisma.GSTTransactionDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complianceConfiguration`: Exposes CRUD operations for the **ComplianceConfiguration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplianceConfigurations
    * const complianceConfigurations = await prisma.complianceConfiguration.findMany()
    * ```
    */
  get complianceConfiguration(): Prisma.ComplianceConfigurationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    AuditLog: 'AuditLog',
    FinancialAuditLog: 'FinancialAuditLog',
    Subscription: 'Subscription',
    TaxReturn: 'TaxReturn',
    Payment: 'Payment',
    Invoice: 'Invoice',
    InvoiceLineItem: 'InvoiceLineItem',
    AIConversation: 'AIConversation',
    AIInsight: 'AIInsight',
    AIUsageTracking: 'AIUsageTracking',
    AICache: 'AICache',
    AIProviderHealth: 'AIProviderHealth',
    basiq_users: 'basiq_users',
    bank_connections: 'bank_connections',
    bank_accounts: 'bank_accounts',
    bank_transactions: 'bank_transactions',
    basiq_webhooks: 'basiq_webhooks',
    basiq_api_logs: 'basiq_api_logs',
    Receipt: 'Receipt',
    Budget: 'Budget',
    BudgetTracking: 'BudgetTracking',
    FinancialInsight: 'FinancialInsight',
    Goal: 'Goal',
    AMLTransactionMonitoring: 'AMLTransactionMonitoring',
    PrivacyConsent: 'PrivacyConsent',
    DataAccessRequest: 'DataAccessRequest',
    APRAIncidentReport: 'APRAIncidentReport',
    GSTTransactionDetail: 'GSTTransactionDetail',
    ComplianceConfiguration: 'ComplianceConfiguration'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "verificationToken" | "auditLog" | "financialAuditLog" | "subscription" | "taxReturn" | "payment" | "invoice" | "invoiceLineItem" | "aIConversation" | "aIInsight" | "aIUsageTracking" | "aICache" | "aIProviderHealth" | "basiq_users" | "bank_connections" | "bank_accounts" | "bank_transactions" | "basiq_webhooks" | "basiq_api_logs" | "receipt" | "budget" | "budgetTracking" | "financialInsight" | "goal" | "aMLTransactionMonitoring" | "privacyConsent" | "dataAccessRequest" | "aPRAIncidentReport" | "gSTTransactionDetail" | "complianceConfiguration"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      FinancialAuditLog: {
        payload: Prisma.$FinancialAuditLogPayload<ExtArgs>
        fields: Prisma.FinancialAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAuditLogPayload>
          }
          findFirst: {
            args: Prisma.FinancialAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAuditLogPayload>
          }
          findMany: {
            args: Prisma.FinancialAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAuditLogPayload>[]
          }
          create: {
            args: Prisma.FinancialAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAuditLogPayload>
          }
          createMany: {
            args: Prisma.FinancialAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinancialAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAuditLogPayload>[]
          }
          delete: {
            args: Prisma.FinancialAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAuditLogPayload>
          }
          update: {
            args: Prisma.FinancialAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.FinancialAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinancialAuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAuditLogPayload>[]
          }
          upsert: {
            args: Prisma.FinancialAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAuditLogPayload>
          }
          aggregate: {
            args: Prisma.FinancialAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancialAuditLog>
          }
          groupBy: {
            args: Prisma.FinancialAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancialAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancialAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<FinancialAuditLogCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      TaxReturn: {
        payload: Prisma.$TaxReturnPayload<ExtArgs>
        fields: Prisma.TaxReturnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxReturnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxReturnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxReturnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxReturnPayload>
          }
          findFirst: {
            args: Prisma.TaxReturnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxReturnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxReturnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxReturnPayload>
          }
          findMany: {
            args: Prisma.TaxReturnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxReturnPayload>[]
          }
          create: {
            args: Prisma.TaxReturnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxReturnPayload>
          }
          createMany: {
            args: Prisma.TaxReturnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxReturnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxReturnPayload>[]
          }
          delete: {
            args: Prisma.TaxReturnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxReturnPayload>
          }
          update: {
            args: Prisma.TaxReturnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxReturnPayload>
          }
          deleteMany: {
            args: Prisma.TaxReturnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxReturnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaxReturnUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxReturnPayload>[]
          }
          upsert: {
            args: Prisma.TaxReturnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxReturnPayload>
          }
          aggregate: {
            args: Prisma.TaxReturnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxReturn>
          }
          groupBy: {
            args: Prisma.TaxReturnGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxReturnGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxReturnCountArgs<ExtArgs>
            result: $Utils.Optional<TaxReturnCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceLineItem: {
        payload: Prisma.$InvoiceLineItemPayload<ExtArgs>
        fields: Prisma.InvoiceLineItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceLineItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceLineItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceLineItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceLineItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceLineItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceLineItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceLineItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceLineItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceLineItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload>
          }
          update: {
            args: Prisma.InvoiceLineItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceLineItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceLineItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceLineItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload>[]
          }
          upsert: {
            args: Prisma.InvoiceLineItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceLineItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceLineItem>
          }
          groupBy: {
            args: Prisma.InvoiceLineItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLineItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceLineItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLineItemCountAggregateOutputType> | number
          }
        }
      }
      AIConversation: {
        payload: Prisma.$AIConversationPayload<ExtArgs>
        fields: Prisma.AIConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          findFirst: {
            args: Prisma.AIConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          findMany: {
            args: Prisma.AIConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>[]
          }
          create: {
            args: Prisma.AIConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          createMany: {
            args: Prisma.AIConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>[]
          }
          delete: {
            args: Prisma.AIConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          update: {
            args: Prisma.AIConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          deleteMany: {
            args: Prisma.AIConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>[]
          }
          upsert: {
            args: Prisma.AIConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          aggregate: {
            args: Prisma.AIConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIConversation>
          }
          groupBy: {
            args: Prisma.AIConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIConversationCountArgs<ExtArgs>
            result: $Utils.Optional<AIConversationCountAggregateOutputType> | number
          }
        }
      }
      AIInsight: {
        payload: Prisma.$AIInsightPayload<ExtArgs>
        fields: Prisma.AIInsightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIInsightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIInsightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>
          }
          findFirst: {
            args: Prisma.AIInsightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIInsightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>
          }
          findMany: {
            args: Prisma.AIInsightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>[]
          }
          create: {
            args: Prisma.AIInsightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>
          }
          createMany: {
            args: Prisma.AIInsightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIInsightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>[]
          }
          delete: {
            args: Prisma.AIInsightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>
          }
          update: {
            args: Prisma.AIInsightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>
          }
          deleteMany: {
            args: Prisma.AIInsightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIInsightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIInsightUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>[]
          }
          upsert: {
            args: Prisma.AIInsightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>
          }
          aggregate: {
            args: Prisma.AIInsightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIInsight>
          }
          groupBy: {
            args: Prisma.AIInsightGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIInsightGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIInsightCountArgs<ExtArgs>
            result: $Utils.Optional<AIInsightCountAggregateOutputType> | number
          }
        }
      }
      AIUsageTracking: {
        payload: Prisma.$AIUsageTrackingPayload<ExtArgs>
        fields: Prisma.AIUsageTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIUsageTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIUsageTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageTrackingPayload>
          }
          findFirst: {
            args: Prisma.AIUsageTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIUsageTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageTrackingPayload>
          }
          findMany: {
            args: Prisma.AIUsageTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageTrackingPayload>[]
          }
          create: {
            args: Prisma.AIUsageTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageTrackingPayload>
          }
          createMany: {
            args: Prisma.AIUsageTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIUsageTrackingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageTrackingPayload>[]
          }
          delete: {
            args: Prisma.AIUsageTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageTrackingPayload>
          }
          update: {
            args: Prisma.AIUsageTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageTrackingPayload>
          }
          deleteMany: {
            args: Prisma.AIUsageTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIUsageTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIUsageTrackingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageTrackingPayload>[]
          }
          upsert: {
            args: Prisma.AIUsageTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageTrackingPayload>
          }
          aggregate: {
            args: Prisma.AIUsageTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIUsageTracking>
          }
          groupBy: {
            args: Prisma.AIUsageTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIUsageTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIUsageTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<AIUsageTrackingCountAggregateOutputType> | number
          }
        }
      }
      AICache: {
        payload: Prisma.$AICachePayload<ExtArgs>
        fields: Prisma.AICacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AICacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AICacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICachePayload>
          }
          findFirst: {
            args: Prisma.AICacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AICacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICachePayload>
          }
          findMany: {
            args: Prisma.AICacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICachePayload>[]
          }
          create: {
            args: Prisma.AICacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICachePayload>
          }
          createMany: {
            args: Prisma.AICacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AICacheCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICachePayload>[]
          }
          delete: {
            args: Prisma.AICacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICachePayload>
          }
          update: {
            args: Prisma.AICacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICachePayload>
          }
          deleteMany: {
            args: Prisma.AICacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AICacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AICacheUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICachePayload>[]
          }
          upsert: {
            args: Prisma.AICacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICachePayload>
          }
          aggregate: {
            args: Prisma.AICacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAICache>
          }
          groupBy: {
            args: Prisma.AICacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<AICacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.AICacheCountArgs<ExtArgs>
            result: $Utils.Optional<AICacheCountAggregateOutputType> | number
          }
        }
      }
      AIProviderHealth: {
        payload: Prisma.$AIProviderHealthPayload<ExtArgs>
        fields: Prisma.AIProviderHealthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIProviderHealthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderHealthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIProviderHealthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderHealthPayload>
          }
          findFirst: {
            args: Prisma.AIProviderHealthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderHealthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIProviderHealthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderHealthPayload>
          }
          findMany: {
            args: Prisma.AIProviderHealthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderHealthPayload>[]
          }
          create: {
            args: Prisma.AIProviderHealthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderHealthPayload>
          }
          createMany: {
            args: Prisma.AIProviderHealthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIProviderHealthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderHealthPayload>[]
          }
          delete: {
            args: Prisma.AIProviderHealthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderHealthPayload>
          }
          update: {
            args: Prisma.AIProviderHealthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderHealthPayload>
          }
          deleteMany: {
            args: Prisma.AIProviderHealthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIProviderHealthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIProviderHealthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderHealthPayload>[]
          }
          upsert: {
            args: Prisma.AIProviderHealthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderHealthPayload>
          }
          aggregate: {
            args: Prisma.AIProviderHealthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIProviderHealth>
          }
          groupBy: {
            args: Prisma.AIProviderHealthGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIProviderHealthGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIProviderHealthCountArgs<ExtArgs>
            result: $Utils.Optional<AIProviderHealthCountAggregateOutputType> | number
          }
        }
      }
      basiq_users: {
        payload: Prisma.$basiq_usersPayload<ExtArgs>
        fields: Prisma.basiq_usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.basiq_usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.basiq_usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_usersPayload>
          }
          findFirst: {
            args: Prisma.basiq_usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.basiq_usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_usersPayload>
          }
          findMany: {
            args: Prisma.basiq_usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_usersPayload>[]
          }
          create: {
            args: Prisma.basiq_usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_usersPayload>
          }
          createMany: {
            args: Prisma.basiq_usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.basiq_usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_usersPayload>[]
          }
          delete: {
            args: Prisma.basiq_usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_usersPayload>
          }
          update: {
            args: Prisma.basiq_usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_usersPayload>
          }
          deleteMany: {
            args: Prisma.basiq_usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.basiq_usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.basiq_usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_usersPayload>[]
          }
          upsert: {
            args: Prisma.basiq_usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_usersPayload>
          }
          aggregate: {
            args: Prisma.Basiq_usersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBasiq_users>
          }
          groupBy: {
            args: Prisma.basiq_usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Basiq_usersGroupByOutputType>[]
          }
          count: {
            args: Prisma.basiq_usersCountArgs<ExtArgs>
            result: $Utils.Optional<Basiq_usersCountAggregateOutputType> | number
          }
        }
      }
      bank_connections: {
        payload: Prisma.$bank_connectionsPayload<ExtArgs>
        fields: Prisma.bank_connectionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bank_connectionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_connectionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bank_connectionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_connectionsPayload>
          }
          findFirst: {
            args: Prisma.bank_connectionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_connectionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bank_connectionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_connectionsPayload>
          }
          findMany: {
            args: Prisma.bank_connectionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_connectionsPayload>[]
          }
          create: {
            args: Prisma.bank_connectionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_connectionsPayload>
          }
          createMany: {
            args: Prisma.bank_connectionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.bank_connectionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_connectionsPayload>[]
          }
          delete: {
            args: Prisma.bank_connectionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_connectionsPayload>
          }
          update: {
            args: Prisma.bank_connectionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_connectionsPayload>
          }
          deleteMany: {
            args: Prisma.bank_connectionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bank_connectionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.bank_connectionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_connectionsPayload>[]
          }
          upsert: {
            args: Prisma.bank_connectionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_connectionsPayload>
          }
          aggregate: {
            args: Prisma.Bank_connectionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBank_connections>
          }
          groupBy: {
            args: Prisma.bank_connectionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Bank_connectionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bank_connectionsCountArgs<ExtArgs>
            result: $Utils.Optional<Bank_connectionsCountAggregateOutputType> | number
          }
        }
      }
      bank_accounts: {
        payload: Prisma.$bank_accountsPayload<ExtArgs>
        fields: Prisma.bank_accountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bank_accountsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bank_accountsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload>
          }
          findFirst: {
            args: Prisma.bank_accountsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bank_accountsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload>
          }
          findMany: {
            args: Prisma.bank_accountsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload>[]
          }
          create: {
            args: Prisma.bank_accountsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload>
          }
          createMany: {
            args: Prisma.bank_accountsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.bank_accountsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload>[]
          }
          delete: {
            args: Prisma.bank_accountsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload>
          }
          update: {
            args: Prisma.bank_accountsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload>
          }
          deleteMany: {
            args: Prisma.bank_accountsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bank_accountsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.bank_accountsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload>[]
          }
          upsert: {
            args: Prisma.bank_accountsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload>
          }
          aggregate: {
            args: Prisma.Bank_accountsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBank_accounts>
          }
          groupBy: {
            args: Prisma.bank_accountsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Bank_accountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bank_accountsCountArgs<ExtArgs>
            result: $Utils.Optional<Bank_accountsCountAggregateOutputType> | number
          }
        }
      }
      bank_transactions: {
        payload: Prisma.$bank_transactionsPayload<ExtArgs>
        fields: Prisma.bank_transactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bank_transactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_transactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bank_transactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_transactionsPayload>
          }
          findFirst: {
            args: Prisma.bank_transactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_transactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bank_transactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_transactionsPayload>
          }
          findMany: {
            args: Prisma.bank_transactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_transactionsPayload>[]
          }
          create: {
            args: Prisma.bank_transactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_transactionsPayload>
          }
          createMany: {
            args: Prisma.bank_transactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.bank_transactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_transactionsPayload>[]
          }
          delete: {
            args: Prisma.bank_transactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_transactionsPayload>
          }
          update: {
            args: Prisma.bank_transactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_transactionsPayload>
          }
          deleteMany: {
            args: Prisma.bank_transactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bank_transactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.bank_transactionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_transactionsPayload>[]
          }
          upsert: {
            args: Prisma.bank_transactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_transactionsPayload>
          }
          aggregate: {
            args: Prisma.Bank_transactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBank_transactions>
          }
          groupBy: {
            args: Prisma.bank_transactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Bank_transactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bank_transactionsCountArgs<ExtArgs>
            result: $Utils.Optional<Bank_transactionsCountAggregateOutputType> | number
          }
        }
      }
      basiq_webhooks: {
        payload: Prisma.$basiq_webhooksPayload<ExtArgs>
        fields: Prisma.basiq_webhooksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.basiq_webhooksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_webhooksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.basiq_webhooksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_webhooksPayload>
          }
          findFirst: {
            args: Prisma.basiq_webhooksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_webhooksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.basiq_webhooksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_webhooksPayload>
          }
          findMany: {
            args: Prisma.basiq_webhooksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_webhooksPayload>[]
          }
          create: {
            args: Prisma.basiq_webhooksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_webhooksPayload>
          }
          createMany: {
            args: Prisma.basiq_webhooksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.basiq_webhooksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_webhooksPayload>[]
          }
          delete: {
            args: Prisma.basiq_webhooksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_webhooksPayload>
          }
          update: {
            args: Prisma.basiq_webhooksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_webhooksPayload>
          }
          deleteMany: {
            args: Prisma.basiq_webhooksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.basiq_webhooksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.basiq_webhooksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_webhooksPayload>[]
          }
          upsert: {
            args: Prisma.basiq_webhooksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_webhooksPayload>
          }
          aggregate: {
            args: Prisma.Basiq_webhooksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBasiq_webhooks>
          }
          groupBy: {
            args: Prisma.basiq_webhooksGroupByArgs<ExtArgs>
            result: $Utils.Optional<Basiq_webhooksGroupByOutputType>[]
          }
          count: {
            args: Prisma.basiq_webhooksCountArgs<ExtArgs>
            result: $Utils.Optional<Basiq_webhooksCountAggregateOutputType> | number
          }
        }
      }
      basiq_api_logs: {
        payload: Prisma.$basiq_api_logsPayload<ExtArgs>
        fields: Prisma.basiq_api_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.basiq_api_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_api_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.basiq_api_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_api_logsPayload>
          }
          findFirst: {
            args: Prisma.basiq_api_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_api_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.basiq_api_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_api_logsPayload>
          }
          findMany: {
            args: Prisma.basiq_api_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_api_logsPayload>[]
          }
          create: {
            args: Prisma.basiq_api_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_api_logsPayload>
          }
          createMany: {
            args: Prisma.basiq_api_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.basiq_api_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_api_logsPayload>[]
          }
          delete: {
            args: Prisma.basiq_api_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_api_logsPayload>
          }
          update: {
            args: Prisma.basiq_api_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_api_logsPayload>
          }
          deleteMany: {
            args: Prisma.basiq_api_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.basiq_api_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.basiq_api_logsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_api_logsPayload>[]
          }
          upsert: {
            args: Prisma.basiq_api_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basiq_api_logsPayload>
          }
          aggregate: {
            args: Prisma.Basiq_api_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBasiq_api_logs>
          }
          groupBy: {
            args: Prisma.basiq_api_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Basiq_api_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.basiq_api_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Basiq_api_logsCountAggregateOutputType> | number
          }
        }
      }
      Receipt: {
        payload: Prisma.$ReceiptPayload<ExtArgs>
        fields: Prisma.ReceiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceiptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceiptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          findFirst: {
            args: Prisma.ReceiptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceiptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          findMany: {
            args: Prisma.ReceiptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
          }
          create: {
            args: Prisma.ReceiptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          createMany: {
            args: Prisma.ReceiptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReceiptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
          }
          delete: {
            args: Prisma.ReceiptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          update: {
            args: Prisma.ReceiptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          deleteMany: {
            args: Prisma.ReceiptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceiptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReceiptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
          }
          upsert: {
            args: Prisma.ReceiptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          aggregate: {
            args: Prisma.ReceiptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceipt>
          }
          groupBy: {
            args: Prisma.ReceiptGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceiptCountArgs<ExtArgs>
            result: $Utils.Optional<ReceiptCountAggregateOutputType> | number
          }
        }
      }
      Budget: {
        payload: Prisma.$BudgetPayload<ExtArgs>
        fields: Prisma.BudgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findFirst: {
            args: Prisma.BudgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findMany: {
            args: Prisma.BudgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          create: {
            args: Prisma.BudgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          createMany: {
            args: Prisma.BudgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          delete: {
            args: Prisma.BudgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          update: {
            args: Prisma.BudgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          deleteMany: {
            args: Prisma.BudgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BudgetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          upsert: {
            args: Prisma.BudgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          aggregate: {
            args: Prisma.BudgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget>
          }
          groupBy: {
            args: Prisma.BudgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetCountAggregateOutputType> | number
          }
        }
      }
      BudgetTracking: {
        payload: Prisma.$BudgetTrackingPayload<ExtArgs>
        fields: Prisma.BudgetTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetTrackingPayload>
          }
          findFirst: {
            args: Prisma.BudgetTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetTrackingPayload>
          }
          findMany: {
            args: Prisma.BudgetTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetTrackingPayload>[]
          }
          create: {
            args: Prisma.BudgetTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetTrackingPayload>
          }
          createMany: {
            args: Prisma.BudgetTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetTrackingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetTrackingPayload>[]
          }
          delete: {
            args: Prisma.BudgetTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetTrackingPayload>
          }
          update: {
            args: Prisma.BudgetTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetTrackingPayload>
          }
          deleteMany: {
            args: Prisma.BudgetTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BudgetTrackingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetTrackingPayload>[]
          }
          upsert: {
            args: Prisma.BudgetTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetTrackingPayload>
          }
          aggregate: {
            args: Prisma.BudgetTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudgetTracking>
          }
          groupBy: {
            args: Prisma.BudgetTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetTrackingCountAggregateOutputType> | number
          }
        }
      }
      FinancialInsight: {
        payload: Prisma.$FinancialInsightPayload<ExtArgs>
        fields: Prisma.FinancialInsightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialInsightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialInsightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload>
          }
          findFirst: {
            args: Prisma.FinancialInsightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialInsightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload>
          }
          findMany: {
            args: Prisma.FinancialInsightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload>[]
          }
          create: {
            args: Prisma.FinancialInsightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload>
          }
          createMany: {
            args: Prisma.FinancialInsightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinancialInsightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload>[]
          }
          delete: {
            args: Prisma.FinancialInsightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload>
          }
          update: {
            args: Prisma.FinancialInsightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload>
          }
          deleteMany: {
            args: Prisma.FinancialInsightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialInsightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinancialInsightUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload>[]
          }
          upsert: {
            args: Prisma.FinancialInsightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload>
          }
          aggregate: {
            args: Prisma.FinancialInsightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancialInsight>
          }
          groupBy: {
            args: Prisma.FinancialInsightGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancialInsightGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancialInsightCountArgs<ExtArgs>
            result: $Utils.Optional<FinancialInsightCountAggregateOutputType> | number
          }
        }
      }
      Goal: {
        payload: Prisma.$GoalPayload<ExtArgs>
        fields: Prisma.GoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          findFirst: {
            args: Prisma.GoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          findMany: {
            args: Prisma.GoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          create: {
            args: Prisma.GoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          createMany: {
            args: Prisma.GoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          delete: {
            args: Prisma.GoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          update: {
            args: Prisma.GoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          deleteMany: {
            args: Prisma.GoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GoalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          upsert: {
            args: Prisma.GoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          aggregate: {
            args: Prisma.GoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoal>
          }
          groupBy: {
            args: Prisma.GoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoalGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoalCountArgs<ExtArgs>
            result: $Utils.Optional<GoalCountAggregateOutputType> | number
          }
        }
      }
      AMLTransactionMonitoring: {
        payload: Prisma.$AMLTransactionMonitoringPayload<ExtArgs>
        fields: Prisma.AMLTransactionMonitoringFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AMLTransactionMonitoringFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AMLTransactionMonitoringPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AMLTransactionMonitoringFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AMLTransactionMonitoringPayload>
          }
          findFirst: {
            args: Prisma.AMLTransactionMonitoringFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AMLTransactionMonitoringPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AMLTransactionMonitoringFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AMLTransactionMonitoringPayload>
          }
          findMany: {
            args: Prisma.AMLTransactionMonitoringFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AMLTransactionMonitoringPayload>[]
          }
          create: {
            args: Prisma.AMLTransactionMonitoringCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AMLTransactionMonitoringPayload>
          }
          createMany: {
            args: Prisma.AMLTransactionMonitoringCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AMLTransactionMonitoringCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AMLTransactionMonitoringPayload>[]
          }
          delete: {
            args: Prisma.AMLTransactionMonitoringDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AMLTransactionMonitoringPayload>
          }
          update: {
            args: Prisma.AMLTransactionMonitoringUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AMLTransactionMonitoringPayload>
          }
          deleteMany: {
            args: Prisma.AMLTransactionMonitoringDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AMLTransactionMonitoringUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AMLTransactionMonitoringUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AMLTransactionMonitoringPayload>[]
          }
          upsert: {
            args: Prisma.AMLTransactionMonitoringUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AMLTransactionMonitoringPayload>
          }
          aggregate: {
            args: Prisma.AMLTransactionMonitoringAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAMLTransactionMonitoring>
          }
          groupBy: {
            args: Prisma.AMLTransactionMonitoringGroupByArgs<ExtArgs>
            result: $Utils.Optional<AMLTransactionMonitoringGroupByOutputType>[]
          }
          count: {
            args: Prisma.AMLTransactionMonitoringCountArgs<ExtArgs>
            result: $Utils.Optional<AMLTransactionMonitoringCountAggregateOutputType> | number
          }
        }
      }
      PrivacyConsent: {
        payload: Prisma.$PrivacyConsentPayload<ExtArgs>
        fields: Prisma.PrivacyConsentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrivacyConsentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyConsentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrivacyConsentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyConsentPayload>
          }
          findFirst: {
            args: Prisma.PrivacyConsentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyConsentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrivacyConsentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyConsentPayload>
          }
          findMany: {
            args: Prisma.PrivacyConsentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyConsentPayload>[]
          }
          create: {
            args: Prisma.PrivacyConsentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyConsentPayload>
          }
          createMany: {
            args: Prisma.PrivacyConsentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrivacyConsentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyConsentPayload>[]
          }
          delete: {
            args: Prisma.PrivacyConsentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyConsentPayload>
          }
          update: {
            args: Prisma.PrivacyConsentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyConsentPayload>
          }
          deleteMany: {
            args: Prisma.PrivacyConsentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrivacyConsentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrivacyConsentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyConsentPayload>[]
          }
          upsert: {
            args: Prisma.PrivacyConsentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyConsentPayload>
          }
          aggregate: {
            args: Prisma.PrivacyConsentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivacyConsent>
          }
          groupBy: {
            args: Prisma.PrivacyConsentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrivacyConsentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrivacyConsentCountArgs<ExtArgs>
            result: $Utils.Optional<PrivacyConsentCountAggregateOutputType> | number
          }
        }
      }
      DataAccessRequest: {
        payload: Prisma.$DataAccessRequestPayload<ExtArgs>
        fields: Prisma.DataAccessRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataAccessRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataAccessRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataAccessRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataAccessRequestPayload>
          }
          findFirst: {
            args: Prisma.DataAccessRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataAccessRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataAccessRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataAccessRequestPayload>
          }
          findMany: {
            args: Prisma.DataAccessRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataAccessRequestPayload>[]
          }
          create: {
            args: Prisma.DataAccessRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataAccessRequestPayload>
          }
          createMany: {
            args: Prisma.DataAccessRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataAccessRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataAccessRequestPayload>[]
          }
          delete: {
            args: Prisma.DataAccessRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataAccessRequestPayload>
          }
          update: {
            args: Prisma.DataAccessRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataAccessRequestPayload>
          }
          deleteMany: {
            args: Prisma.DataAccessRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataAccessRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DataAccessRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataAccessRequestPayload>[]
          }
          upsert: {
            args: Prisma.DataAccessRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataAccessRequestPayload>
          }
          aggregate: {
            args: Prisma.DataAccessRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataAccessRequest>
          }
          groupBy: {
            args: Prisma.DataAccessRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataAccessRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataAccessRequestCountArgs<ExtArgs>
            result: $Utils.Optional<DataAccessRequestCountAggregateOutputType> | number
          }
        }
      }
      APRAIncidentReport: {
        payload: Prisma.$APRAIncidentReportPayload<ExtArgs>
        fields: Prisma.APRAIncidentReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.APRAIncidentReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APRAIncidentReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.APRAIncidentReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APRAIncidentReportPayload>
          }
          findFirst: {
            args: Prisma.APRAIncidentReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APRAIncidentReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.APRAIncidentReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APRAIncidentReportPayload>
          }
          findMany: {
            args: Prisma.APRAIncidentReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APRAIncidentReportPayload>[]
          }
          create: {
            args: Prisma.APRAIncidentReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APRAIncidentReportPayload>
          }
          createMany: {
            args: Prisma.APRAIncidentReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.APRAIncidentReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APRAIncidentReportPayload>[]
          }
          delete: {
            args: Prisma.APRAIncidentReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APRAIncidentReportPayload>
          }
          update: {
            args: Prisma.APRAIncidentReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APRAIncidentReportPayload>
          }
          deleteMany: {
            args: Prisma.APRAIncidentReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.APRAIncidentReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.APRAIncidentReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APRAIncidentReportPayload>[]
          }
          upsert: {
            args: Prisma.APRAIncidentReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APRAIncidentReportPayload>
          }
          aggregate: {
            args: Prisma.APRAIncidentReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAPRAIncidentReport>
          }
          groupBy: {
            args: Prisma.APRAIncidentReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<APRAIncidentReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.APRAIncidentReportCountArgs<ExtArgs>
            result: $Utils.Optional<APRAIncidentReportCountAggregateOutputType> | number
          }
        }
      }
      GSTTransactionDetail: {
        payload: Prisma.$GSTTransactionDetailPayload<ExtArgs>
        fields: Prisma.GSTTransactionDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GSTTransactionDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GSTTransactionDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GSTTransactionDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GSTTransactionDetailPayload>
          }
          findFirst: {
            args: Prisma.GSTTransactionDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GSTTransactionDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GSTTransactionDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GSTTransactionDetailPayload>
          }
          findMany: {
            args: Prisma.GSTTransactionDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GSTTransactionDetailPayload>[]
          }
          create: {
            args: Prisma.GSTTransactionDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GSTTransactionDetailPayload>
          }
          createMany: {
            args: Prisma.GSTTransactionDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GSTTransactionDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GSTTransactionDetailPayload>[]
          }
          delete: {
            args: Prisma.GSTTransactionDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GSTTransactionDetailPayload>
          }
          update: {
            args: Prisma.GSTTransactionDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GSTTransactionDetailPayload>
          }
          deleteMany: {
            args: Prisma.GSTTransactionDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GSTTransactionDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GSTTransactionDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GSTTransactionDetailPayload>[]
          }
          upsert: {
            args: Prisma.GSTTransactionDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GSTTransactionDetailPayload>
          }
          aggregate: {
            args: Prisma.GSTTransactionDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGSTTransactionDetail>
          }
          groupBy: {
            args: Prisma.GSTTransactionDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<GSTTransactionDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.GSTTransactionDetailCountArgs<ExtArgs>
            result: $Utils.Optional<GSTTransactionDetailCountAggregateOutputType> | number
          }
        }
      }
      ComplianceConfiguration: {
        payload: Prisma.$ComplianceConfigurationPayload<ExtArgs>
        fields: Prisma.ComplianceConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplianceConfigurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplianceConfigurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceConfigurationPayload>
          }
          findFirst: {
            args: Prisma.ComplianceConfigurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplianceConfigurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceConfigurationPayload>
          }
          findMany: {
            args: Prisma.ComplianceConfigurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceConfigurationPayload>[]
          }
          create: {
            args: Prisma.ComplianceConfigurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceConfigurationPayload>
          }
          createMany: {
            args: Prisma.ComplianceConfigurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplianceConfigurationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceConfigurationPayload>[]
          }
          delete: {
            args: Prisma.ComplianceConfigurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceConfigurationPayload>
          }
          update: {
            args: Prisma.ComplianceConfigurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.ComplianceConfigurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplianceConfigurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComplianceConfigurationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceConfigurationPayload>[]
          }
          upsert: {
            args: Prisma.ComplianceConfigurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceConfigurationPayload>
          }
          aggregate: {
            args: Prisma.ComplianceConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplianceConfiguration>
          }
          groupBy: {
            args: Prisma.ComplianceConfigurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplianceConfigurationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplianceConfigurationCountArgs<ExtArgs>
            result: $Utils.Optional<ComplianceConfigurationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    auditLog?: AuditLogOmit
    financialAuditLog?: FinancialAuditLogOmit
    subscription?: SubscriptionOmit
    taxReturn?: TaxReturnOmit
    payment?: PaymentOmit
    invoice?: InvoiceOmit
    invoiceLineItem?: InvoiceLineItemOmit
    aIConversation?: AIConversationOmit
    aIInsight?: AIInsightOmit
    aIUsageTracking?: AIUsageTrackingOmit
    aICache?: AICacheOmit
    aIProviderHealth?: AIProviderHealthOmit
    basiq_users?: basiq_usersOmit
    bank_connections?: bank_connectionsOmit
    bank_accounts?: bank_accountsOmit
    bank_transactions?: bank_transactionsOmit
    basiq_webhooks?: basiq_webhooksOmit
    basiq_api_logs?: basiq_api_logsOmit
    receipt?: ReceiptOmit
    budget?: BudgetOmit
    budgetTracking?: BudgetTrackingOmit
    financialInsight?: FinancialInsightOmit
    goal?: GoalOmit
    aMLTransactionMonitoring?: AMLTransactionMonitoringOmit
    privacyConsent?: PrivacyConsentOmit
    dataAccessRequest?: DataAccessRequestOmit
    aPRAIncidentReport?: APRAIncidentReportOmit
    gSTTransactionDetail?: GSTTransactionDetailOmit
    complianceConfiguration?: ComplianceConfigurationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    auditLogs: number
    subscriptions: number
    taxReturns: number
    payments: number
    aiConversations: number
    aiInsights: number
    aiUsageTracking: number
    basiq_api_logs: number
    receipts: number
    budgets: number
    budgetTracking: number
    financialInsights: number
    goals: number
    financialAuditLogs: number
    amlMonitoring: number
    privacyConsents: number
    dataAccessRequests: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    subscriptions?: boolean | UserCountOutputTypeCountSubscriptionsArgs
    taxReturns?: boolean | UserCountOutputTypeCountTaxReturnsArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    aiConversations?: boolean | UserCountOutputTypeCountAiConversationsArgs
    aiInsights?: boolean | UserCountOutputTypeCountAiInsightsArgs
    aiUsageTracking?: boolean | UserCountOutputTypeCountAiUsageTrackingArgs
    basiq_api_logs?: boolean | UserCountOutputTypeCountBasiq_api_logsArgs
    receipts?: boolean | UserCountOutputTypeCountReceiptsArgs
    budgets?: boolean | UserCountOutputTypeCountBudgetsArgs
    budgetTracking?: boolean | UserCountOutputTypeCountBudgetTrackingArgs
    financialInsights?: boolean | UserCountOutputTypeCountFinancialInsightsArgs
    goals?: boolean | UserCountOutputTypeCountGoalsArgs
    financialAuditLogs?: boolean | UserCountOutputTypeCountFinancialAuditLogsArgs
    amlMonitoring?: boolean | UserCountOutputTypeCountAmlMonitoringArgs
    privacyConsents?: boolean | UserCountOutputTypeCountPrivacyConsentsArgs
    dataAccessRequests?: boolean | UserCountOutputTypeCountDataAccessRequestsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaxReturnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxReturnWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIInsightWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiUsageTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIUsageTrackingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBasiq_api_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: basiq_api_logsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBudgetTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetTrackingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFinancialInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialInsightWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFinancialAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialAuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAmlMonitoringArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AMLTransactionMonitoringWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPrivacyConsentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivacyConsentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDataAccessRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataAccessRequestWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    lineItems: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItems?: boolean | InvoiceCountOutputTypeCountLineItemsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountLineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineItemWhereInput
  }


  /**
   * Count Type Basiq_usersCountOutputType
   */

  export type Basiq_usersCountOutputType = {
    bank_connections: number
    bank_accounts: number
  }

  export type Basiq_usersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bank_connections?: boolean | Basiq_usersCountOutputTypeCountBank_connectionsArgs
    bank_accounts?: boolean | Basiq_usersCountOutputTypeCountBank_accountsArgs
  }

  // Custom InputTypes
  /**
   * Basiq_usersCountOutputType without action
   */
  export type Basiq_usersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Basiq_usersCountOutputType
     */
    select?: Basiq_usersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Basiq_usersCountOutputType without action
   */
  export type Basiq_usersCountOutputTypeCountBank_connectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bank_connectionsWhereInput
  }

  /**
   * Basiq_usersCountOutputType without action
   */
  export type Basiq_usersCountOutputTypeCountBank_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bank_accountsWhereInput
  }


  /**
   * Count Type Bank_connectionsCountOutputType
   */

  export type Bank_connectionsCountOutputType = {
    bank_accounts: number
  }

  export type Bank_connectionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bank_accounts?: boolean | Bank_connectionsCountOutputTypeCountBank_accountsArgs
  }

  // Custom InputTypes
  /**
   * Bank_connectionsCountOutputType without action
   */
  export type Bank_connectionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank_connectionsCountOutputType
     */
    select?: Bank_connectionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Bank_connectionsCountOutputType without action
   */
  export type Bank_connectionsCountOutputTypeCountBank_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bank_accountsWhereInput
  }


  /**
   * Count Type Bank_accountsCountOutputType
   */

  export type Bank_accountsCountOutputType = {
    bank_transactions: number
  }

  export type Bank_accountsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bank_transactions?: boolean | Bank_accountsCountOutputTypeCountBank_transactionsArgs
  }

  // Custom InputTypes
  /**
   * Bank_accountsCountOutputType without action
   */
  export type Bank_accountsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank_accountsCountOutputType
     */
    select?: Bank_accountsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Bank_accountsCountOutputType without action
   */
  export type Bank_accountsCountOutputTypeCountBank_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bank_transactionsWhereInput
  }


  /**
   * Count Type BudgetCountOutputType
   */

  export type BudgetCountOutputType = {
    budgetTracking: number
  }

  export type BudgetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budgetTracking?: boolean | BudgetCountOutputTypeCountBudgetTrackingArgs
  }

  // Custom InputTypes
  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCountOutputType
     */
    select?: BudgetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeCountBudgetTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetTrackingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    failedLoginAttempts: number | null
  }

  export type UserSumAggregateOutputType = {
    failedLoginAttempts: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: Date | null
    name: string | null
    phone: string | null
    password: string | null
    image: string | null
    role: $Enums.Role | null
    abn: string | null
    tfn: string | null
    taxResidency: $Enums.TaxResidency | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    emailVerificationToken: string | null
    emailVerificationExpires: Date | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: Date | null
    name: string | null
    phone: string | null
    password: string | null
    image: string | null
    role: $Enums.Role | null
    abn: string | null
    tfn: string | null
    taxResidency: $Enums.TaxResidency | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    emailVerificationToken: string | null
    emailVerificationExpires: Date | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    emailVerified: number
    name: number
    phone: number
    password: number
    image: number
    role: number
    abn: number
    tfn: number
    taxResidency: number
    failedLoginAttempts: number
    lockedUntil: number
    lastLoginAt: number
    lastLoginIp: number
    twoFactorEnabled: number
    twoFactorSecret: number
    emailVerificationToken: number
    emailVerificationExpires: number
    passwordResetToken: number
    passwordResetExpires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    failedLoginAttempts?: true
  }

  export type UserSumAggregateInputType = {
    failedLoginAttempts?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    name?: true
    phone?: true
    password?: true
    image?: true
    role?: true
    abn?: true
    tfn?: true
    taxResidency?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    lastLoginAt?: true
    lastLoginIp?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    emailVerificationToken?: true
    emailVerificationExpires?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    name?: true
    phone?: true
    password?: true
    image?: true
    role?: true
    abn?: true
    tfn?: true
    taxResidency?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    lastLoginAt?: true
    lastLoginIp?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    emailVerificationToken?: true
    emailVerificationExpires?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    name?: true
    phone?: true
    password?: true
    image?: true
    role?: true
    abn?: true
    tfn?: true
    taxResidency?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    lastLoginAt?: true
    lastLoginIp?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    emailVerificationToken?: true
    emailVerificationExpires?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    emailVerified: Date | null
    name: string
    phone: string | null
    password: string | null
    image: string | null
    role: $Enums.Role
    abn: string | null
    tfn: string | null
    taxResidency: $Enums.TaxResidency
    failedLoginAttempts: number
    lockedUntil: Date | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    twoFactorEnabled: boolean
    twoFactorSecret: string | null
    emailVerificationToken: string | null
    emailVerificationExpires: Date | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    phone?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    abn?: boolean
    tfn?: boolean
    taxResidency?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    emailVerificationToken?: boolean
    emailVerificationExpires?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    taxReturns?: boolean | User$taxReturnsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    aiConversations?: boolean | User$aiConversationsArgs<ExtArgs>
    aiInsights?: boolean | User$aiInsightsArgs<ExtArgs>
    aiUsageTracking?: boolean | User$aiUsageTrackingArgs<ExtArgs>
    basiq_users?: boolean | User$basiq_usersArgs<ExtArgs>
    basiq_api_logs?: boolean | User$basiq_api_logsArgs<ExtArgs>
    receipts?: boolean | User$receiptsArgs<ExtArgs>
    budgets?: boolean | User$budgetsArgs<ExtArgs>
    budgetTracking?: boolean | User$budgetTrackingArgs<ExtArgs>
    financialInsights?: boolean | User$financialInsightsArgs<ExtArgs>
    goals?: boolean | User$goalsArgs<ExtArgs>
    financialAuditLogs?: boolean | User$financialAuditLogsArgs<ExtArgs>
    amlMonitoring?: boolean | User$amlMonitoringArgs<ExtArgs>
    privacyConsents?: boolean | User$privacyConsentsArgs<ExtArgs>
    dataAccessRequests?: boolean | User$dataAccessRequestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    phone?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    abn?: boolean
    tfn?: boolean
    taxResidency?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    emailVerificationToken?: boolean
    emailVerificationExpires?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    phone?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    abn?: boolean
    tfn?: boolean
    taxResidency?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    emailVerificationToken?: boolean
    emailVerificationExpires?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    phone?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    abn?: boolean
    tfn?: boolean
    taxResidency?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    emailVerificationToken?: boolean
    emailVerificationExpires?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "emailVerified" | "name" | "phone" | "password" | "image" | "role" | "abn" | "tfn" | "taxResidency" | "failedLoginAttempts" | "lockedUntil" | "lastLoginAt" | "lastLoginIp" | "twoFactorEnabled" | "twoFactorSecret" | "emailVerificationToken" | "emailVerificationExpires" | "passwordResetToken" | "passwordResetExpires" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    taxReturns?: boolean | User$taxReturnsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    aiConversations?: boolean | User$aiConversationsArgs<ExtArgs>
    aiInsights?: boolean | User$aiInsightsArgs<ExtArgs>
    aiUsageTracking?: boolean | User$aiUsageTrackingArgs<ExtArgs>
    basiq_users?: boolean | User$basiq_usersArgs<ExtArgs>
    basiq_api_logs?: boolean | User$basiq_api_logsArgs<ExtArgs>
    receipts?: boolean | User$receiptsArgs<ExtArgs>
    budgets?: boolean | User$budgetsArgs<ExtArgs>
    budgetTracking?: boolean | User$budgetTrackingArgs<ExtArgs>
    financialInsights?: boolean | User$financialInsightsArgs<ExtArgs>
    goals?: boolean | User$goalsArgs<ExtArgs>
    financialAuditLogs?: boolean | User$financialAuditLogsArgs<ExtArgs>
    amlMonitoring?: boolean | User$amlMonitoringArgs<ExtArgs>
    privacyConsents?: boolean | User$privacyConsentsArgs<ExtArgs>
    dataAccessRequests?: boolean | User$dataAccessRequestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      taxReturns: Prisma.$TaxReturnPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      aiConversations: Prisma.$AIConversationPayload<ExtArgs>[]
      aiInsights: Prisma.$AIInsightPayload<ExtArgs>[]
      aiUsageTracking: Prisma.$AIUsageTrackingPayload<ExtArgs>[]
      basiq_users: Prisma.$basiq_usersPayload<ExtArgs> | null
      basiq_api_logs: Prisma.$basiq_api_logsPayload<ExtArgs>[]
      receipts: Prisma.$ReceiptPayload<ExtArgs>[]
      budgets: Prisma.$BudgetPayload<ExtArgs>[]
      budgetTracking: Prisma.$BudgetTrackingPayload<ExtArgs>[]
      financialInsights: Prisma.$FinancialInsightPayload<ExtArgs>[]
      goals: Prisma.$GoalPayload<ExtArgs>[]
      financialAuditLogs: Prisma.$FinancialAuditLogPayload<ExtArgs>[]
      amlMonitoring: Prisma.$AMLTransactionMonitoringPayload<ExtArgs>[]
      privacyConsents: Prisma.$PrivacyConsentPayload<ExtArgs>[]
      dataAccessRequests: Prisma.$DataAccessRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      emailVerified: Date | null
      name: string
      phone: string | null
      password: string | null
      image: string | null
      role: $Enums.Role
      abn: string | null
      tfn: string | null
      taxResidency: $Enums.TaxResidency
      failedLoginAttempts: number
      lockedUntil: Date | null
      lastLoginAt: Date | null
      lastLoginIp: string | null
      twoFactorEnabled: boolean
      /**
       * @encrypted
       */
      twoFactorSecret: string | null
      emailVerificationToken: string | null
      emailVerificationExpires: Date | null
      passwordResetToken: string | null
      passwordResetExpires: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends User$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taxReturns<T extends User$taxReturnsArgs<ExtArgs> = {}>(args?: Subset<T, User$taxReturnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiConversations<T extends User$aiConversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$aiConversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiInsights<T extends User$aiInsightsArgs<ExtArgs> = {}>(args?: Subset<T, User$aiInsightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiUsageTracking<T extends User$aiUsageTrackingArgs<ExtArgs> = {}>(args?: Subset<T, User$aiUsageTrackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    basiq_users<T extends User$basiq_usersArgs<ExtArgs> = {}>(args?: Subset<T, User$basiq_usersArgs<ExtArgs>>): Prisma__basiq_usersClient<$Result.GetResult<Prisma.$basiq_usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    basiq_api_logs<T extends User$basiq_api_logsArgs<ExtArgs> = {}>(args?: Subset<T, User$basiq_api_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$basiq_api_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receipts<T extends User$receiptsArgs<ExtArgs> = {}>(args?: Subset<T, User$receiptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    budgets<T extends User$budgetsArgs<ExtArgs> = {}>(args?: Subset<T, User$budgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    budgetTracking<T extends User$budgetTrackingArgs<ExtArgs> = {}>(args?: Subset<T, User$budgetTrackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialInsights<T extends User$financialInsightsArgs<ExtArgs> = {}>(args?: Subset<T, User$financialInsightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    goals<T extends User$goalsArgs<ExtArgs> = {}>(args?: Subset<T, User$goalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialAuditLogs<T extends User$financialAuditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$financialAuditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    amlMonitoring<T extends User$amlMonitoringArgs<ExtArgs> = {}>(args?: Subset<T, User$amlMonitoringArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AMLTransactionMonitoringPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    privacyConsents<T extends User$privacyConsentsArgs<ExtArgs> = {}>(args?: Subset<T, User$privacyConsentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivacyConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dataAccessRequests<T extends User$dataAccessRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$dataAccessRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataAccessRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly abn: FieldRef<"User", 'String'>
    readonly tfn: FieldRef<"User", 'String'>
    readonly taxResidency: FieldRef<"User", 'TaxResidency'>
    readonly failedLoginAttempts: FieldRef<"User", 'Int'>
    readonly lockedUntil: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginIp: FieldRef<"User", 'String'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly emailVerificationToken: FieldRef<"User", 'String'>
    readonly emailVerificationExpires: FieldRef<"User", 'DateTime'>
    readonly passwordResetToken: FieldRef<"User", 'String'>
    readonly passwordResetExpires: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.subscriptions
   */
  export type User$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * User.taxReturns
   */
  export type User$taxReturnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxReturn
     */
    select?: TaxReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxReturn
     */
    omit?: TaxReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxReturnInclude<ExtArgs> | null
    where?: TaxReturnWhereInput
    orderBy?: TaxReturnOrderByWithRelationInput | TaxReturnOrderByWithRelationInput[]
    cursor?: TaxReturnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaxReturnScalarFieldEnum | TaxReturnScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.aiConversations
   */
  export type User$aiConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    where?: AIConversationWhereInput
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    cursor?: AIConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIConversationScalarFieldEnum | AIConversationScalarFieldEnum[]
  }

  /**
   * User.aiInsights
   */
  export type User$aiInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    where?: AIInsightWhereInput
    orderBy?: AIInsightOrderByWithRelationInput | AIInsightOrderByWithRelationInput[]
    cursor?: AIInsightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIInsightScalarFieldEnum | AIInsightScalarFieldEnum[]
  }

  /**
   * User.aiUsageTracking
   */
  export type User$aiUsageTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageTracking
     */
    select?: AIUsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageTracking
     */
    omit?: AIUsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageTrackingInclude<ExtArgs> | null
    where?: AIUsageTrackingWhereInput
    orderBy?: AIUsageTrackingOrderByWithRelationInput | AIUsageTrackingOrderByWithRelationInput[]
    cursor?: AIUsageTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIUsageTrackingScalarFieldEnum | AIUsageTrackingScalarFieldEnum[]
  }

  /**
   * User.basiq_users
   */
  export type User$basiq_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_users
     */
    select?: basiq_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_users
     */
    omit?: basiq_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_usersInclude<ExtArgs> | null
    where?: basiq_usersWhereInput
  }

  /**
   * User.basiq_api_logs
   */
  export type User$basiq_api_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_api_logs
     */
    select?: basiq_api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_api_logs
     */
    omit?: basiq_api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_api_logsInclude<ExtArgs> | null
    where?: basiq_api_logsWhereInput
    orderBy?: basiq_api_logsOrderByWithRelationInput | basiq_api_logsOrderByWithRelationInput[]
    cursor?: basiq_api_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Basiq_api_logsScalarFieldEnum | Basiq_api_logsScalarFieldEnum[]
  }

  /**
   * User.receipts
   */
  export type User$receiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    where?: ReceiptWhereInput
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    cursor?: ReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * User.budgets
   */
  export type User$budgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    cursor?: BudgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * User.budgetTracking
   */
  export type User$budgetTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetTracking
     */
    select?: BudgetTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetTracking
     */
    omit?: BudgetTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetTrackingInclude<ExtArgs> | null
    where?: BudgetTrackingWhereInput
    orderBy?: BudgetTrackingOrderByWithRelationInput | BudgetTrackingOrderByWithRelationInput[]
    cursor?: BudgetTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetTrackingScalarFieldEnum | BudgetTrackingScalarFieldEnum[]
  }

  /**
   * User.financialInsights
   */
  export type User$financialInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    where?: FinancialInsightWhereInput
    orderBy?: FinancialInsightOrderByWithRelationInput | FinancialInsightOrderByWithRelationInput[]
    cursor?: FinancialInsightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialInsightScalarFieldEnum | FinancialInsightScalarFieldEnum[]
  }

  /**
   * User.goals
   */
  export type User$goalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    where?: GoalWhereInput
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    cursor?: GoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * User.financialAuditLogs
   */
  export type User$financialAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAuditLog
     */
    select?: FinancialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAuditLog
     */
    omit?: FinancialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAuditLogInclude<ExtArgs> | null
    where?: FinancialAuditLogWhereInput
    orderBy?: FinancialAuditLogOrderByWithRelationInput | FinancialAuditLogOrderByWithRelationInput[]
    cursor?: FinancialAuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialAuditLogScalarFieldEnum | FinancialAuditLogScalarFieldEnum[]
  }

  /**
   * User.amlMonitoring
   */
  export type User$amlMonitoringArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AMLTransactionMonitoring
     */
    select?: AMLTransactionMonitoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AMLTransactionMonitoring
     */
    omit?: AMLTransactionMonitoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AMLTransactionMonitoringInclude<ExtArgs> | null
    where?: AMLTransactionMonitoringWhereInput
    orderBy?: AMLTransactionMonitoringOrderByWithRelationInput | AMLTransactionMonitoringOrderByWithRelationInput[]
    cursor?: AMLTransactionMonitoringWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AMLTransactionMonitoringScalarFieldEnum | AMLTransactionMonitoringScalarFieldEnum[]
  }

  /**
   * User.privacyConsents
   */
  export type User$privacyConsentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyConsent
     */
    select?: PrivacyConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyConsent
     */
    omit?: PrivacyConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivacyConsentInclude<ExtArgs> | null
    where?: PrivacyConsentWhereInput
    orderBy?: PrivacyConsentOrderByWithRelationInput | PrivacyConsentOrderByWithRelationInput[]
    cursor?: PrivacyConsentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrivacyConsentScalarFieldEnum | PrivacyConsentScalarFieldEnum[]
  }

  /**
   * User.dataAccessRequests
   */
  export type User$dataAccessRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataAccessRequest
     */
    select?: DataAccessRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataAccessRequest
     */
    omit?: DataAccessRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataAccessRequestInclude<ExtArgs> | null
    where?: DataAccessRequestWhereInput
    orderBy?: DataAccessRequestOrderByWithRelationInput | DataAccessRequestOrderByWithRelationInput[]
    cursor?: DataAccessRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataAccessRequestScalarFieldEnum | DataAccessRequestScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires" | "createdAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    event: $Enums.AuthEvent | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    event: $Enums.AuthEvent | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    event: number
    ipAddress: number
    userAgent: number
    metadata: number
    success: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    event?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    event?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    event?: true
    ipAddress?: true
    userAgent?: true
    metadata?: true
    success?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    event: $Enums.AuthEvent
    ipAddress: string
    userAgent: string | null
    metadata: JsonValue | null
    success: boolean
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    event?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    success?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    event?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    success?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    event?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    success?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    event?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    success?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "event" | "ipAddress" | "userAgent" | "metadata" | "success" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      event: $Enums.AuthEvent
      ipAddress: string
      userAgent: string | null
      metadata: Prisma.JsonValue | null
      success: boolean
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly event: FieldRef<"AuditLog", 'AuthEvent'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly success: FieldRef<"AuditLog", 'Boolean'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model FinancialAuditLog
   */

  export type AggregateFinancialAuditLog = {
    _count: FinancialAuditLogCountAggregateOutputType | null
    _avg: FinancialAuditLogAvgAggregateOutputType | null
    _sum: FinancialAuditLogSumAggregateOutputType | null
    _min: FinancialAuditLogMinAggregateOutputType | null
    _max: FinancialAuditLogMaxAggregateOutputType | null
  }

  export type FinancialAuditLogAvgAggregateOutputType = {
    amount: Decimal | null
    gstAmount: Decimal | null
  }

  export type FinancialAuditLogSumAggregateOutputType = {
    amount: Decimal | null
    gstAmount: Decimal | null
  }

  export type FinancialAuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    operationType: $Enums.FinancialOperation | null
    resourceType: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    httpMethod: string | null
    endpoint: string | null
    amount: Decimal | null
    gstAmount: Decimal | null
    currency: string | null
    taxYear: string | null
    success: boolean | null
    errorMessage: string | null
    hashChain: string | null
    previousHash: string | null
    createdAt: Date | null
    timezone: string | null
  }

  export type FinancialAuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    operationType: $Enums.FinancialOperation | null
    resourceType: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    httpMethod: string | null
    endpoint: string | null
    amount: Decimal | null
    gstAmount: Decimal | null
    currency: string | null
    taxYear: string | null
    success: boolean | null
    errorMessage: string | null
    hashChain: string | null
    previousHash: string | null
    createdAt: Date | null
    timezone: string | null
  }

  export type FinancialAuditLogCountAggregateOutputType = {
    id: number
    userId: number
    sessionId: number
    operationType: number
    resourceType: number
    resourceId: number
    ipAddress: number
    userAgent: number
    httpMethod: number
    endpoint: number
    previousData: number
    currentData: number
    changedFields: number
    amount: number
    gstAmount: number
    currency: number
    taxYear: number
    success: number
    errorMessage: number
    hashChain: number
    previousHash: number
    createdAt: number
    timezone: number
    _all: number
  }


  export type FinancialAuditLogAvgAggregateInputType = {
    amount?: true
    gstAmount?: true
  }

  export type FinancialAuditLogSumAggregateInputType = {
    amount?: true
    gstAmount?: true
  }

  export type FinancialAuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    operationType?: true
    resourceType?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    httpMethod?: true
    endpoint?: true
    amount?: true
    gstAmount?: true
    currency?: true
    taxYear?: true
    success?: true
    errorMessage?: true
    hashChain?: true
    previousHash?: true
    createdAt?: true
    timezone?: true
  }

  export type FinancialAuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    operationType?: true
    resourceType?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    httpMethod?: true
    endpoint?: true
    amount?: true
    gstAmount?: true
    currency?: true
    taxYear?: true
    success?: true
    errorMessage?: true
    hashChain?: true
    previousHash?: true
    createdAt?: true
    timezone?: true
  }

  export type FinancialAuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    operationType?: true
    resourceType?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    httpMethod?: true
    endpoint?: true
    previousData?: true
    currentData?: true
    changedFields?: true
    amount?: true
    gstAmount?: true
    currency?: true
    taxYear?: true
    success?: true
    errorMessage?: true
    hashChain?: true
    previousHash?: true
    createdAt?: true
    timezone?: true
    _all?: true
  }

  export type FinancialAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialAuditLog to aggregate.
     */
    where?: FinancialAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialAuditLogs to fetch.
     */
    orderBy?: FinancialAuditLogOrderByWithRelationInput | FinancialAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialAuditLogs
    **/
    _count?: true | FinancialAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancialAuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancialAuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialAuditLogMaxAggregateInputType
  }

  export type GetFinancialAuditLogAggregateType<T extends FinancialAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialAuditLog[P]>
      : GetScalarType<T[P], AggregateFinancialAuditLog[P]>
  }




  export type FinancialAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialAuditLogWhereInput
    orderBy?: FinancialAuditLogOrderByWithAggregationInput | FinancialAuditLogOrderByWithAggregationInput[]
    by: FinancialAuditLogScalarFieldEnum[] | FinancialAuditLogScalarFieldEnum
    having?: FinancialAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialAuditLogCountAggregateInputType | true
    _avg?: FinancialAuditLogAvgAggregateInputType
    _sum?: FinancialAuditLogSumAggregateInputType
    _min?: FinancialAuditLogMinAggregateInputType
    _max?: FinancialAuditLogMaxAggregateInputType
  }

  export type FinancialAuditLogGroupByOutputType = {
    id: string
    userId: string
    sessionId: string | null
    operationType: $Enums.FinancialOperation
    resourceType: string
    resourceId: string | null
    ipAddress: string
    userAgent: string | null
    httpMethod: string | null
    endpoint: string | null
    previousData: JsonValue | null
    currentData: JsonValue | null
    changedFields: string[]
    amount: Decimal | null
    gstAmount: Decimal | null
    currency: string | null
    taxYear: string | null
    success: boolean
    errorMessage: string | null
    hashChain: string | null
    previousHash: string | null
    createdAt: Date
    timezone: string
    _count: FinancialAuditLogCountAggregateOutputType | null
    _avg: FinancialAuditLogAvgAggregateOutputType | null
    _sum: FinancialAuditLogSumAggregateOutputType | null
    _min: FinancialAuditLogMinAggregateOutputType | null
    _max: FinancialAuditLogMaxAggregateOutputType | null
  }

  type GetFinancialAuditLogGroupByPayload<T extends FinancialAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type FinancialAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    operationType?: boolean
    resourceType?: boolean
    resourceId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    httpMethod?: boolean
    endpoint?: boolean
    previousData?: boolean
    currentData?: boolean
    changedFields?: boolean
    amount?: boolean
    gstAmount?: boolean
    currency?: boolean
    taxYear?: boolean
    success?: boolean
    errorMessage?: boolean
    hashChain?: boolean
    previousHash?: boolean
    createdAt?: boolean
    timezone?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialAuditLog"]>

  export type FinancialAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    operationType?: boolean
    resourceType?: boolean
    resourceId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    httpMethod?: boolean
    endpoint?: boolean
    previousData?: boolean
    currentData?: boolean
    changedFields?: boolean
    amount?: boolean
    gstAmount?: boolean
    currency?: boolean
    taxYear?: boolean
    success?: boolean
    errorMessage?: boolean
    hashChain?: boolean
    previousHash?: boolean
    createdAt?: boolean
    timezone?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialAuditLog"]>

  export type FinancialAuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    operationType?: boolean
    resourceType?: boolean
    resourceId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    httpMethod?: boolean
    endpoint?: boolean
    previousData?: boolean
    currentData?: boolean
    changedFields?: boolean
    amount?: boolean
    gstAmount?: boolean
    currency?: boolean
    taxYear?: boolean
    success?: boolean
    errorMessage?: boolean
    hashChain?: boolean
    previousHash?: boolean
    createdAt?: boolean
    timezone?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialAuditLog"]>

  export type FinancialAuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    operationType?: boolean
    resourceType?: boolean
    resourceId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    httpMethod?: boolean
    endpoint?: boolean
    previousData?: boolean
    currentData?: boolean
    changedFields?: boolean
    amount?: boolean
    gstAmount?: boolean
    currency?: boolean
    taxYear?: boolean
    success?: boolean
    errorMessage?: boolean
    hashChain?: boolean
    previousHash?: boolean
    createdAt?: boolean
    timezone?: boolean
  }

  export type FinancialAuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "sessionId" | "operationType" | "resourceType" | "resourceId" | "ipAddress" | "userAgent" | "httpMethod" | "endpoint" | "previousData" | "currentData" | "changedFields" | "amount" | "gstAmount" | "currency" | "taxYear" | "success" | "errorMessage" | "hashChain" | "previousHash" | "createdAt" | "timezone", ExtArgs["result"]["financialAuditLog"]>
  export type FinancialAuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FinancialAuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FinancialAuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FinancialAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialAuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      sessionId: string | null
      operationType: $Enums.FinancialOperation
      resourceType: string
      resourceId: string | null
      ipAddress: string
      userAgent: string | null
      httpMethod: string | null
      endpoint: string | null
      previousData: Prisma.JsonValue | null
      currentData: Prisma.JsonValue | null
      changedFields: string[]
      amount: Prisma.Decimal | null
      gstAmount: Prisma.Decimal | null
      currency: string | null
      taxYear: string | null
      success: boolean
      errorMessage: string | null
      hashChain: string | null
      previousHash: string | null
      createdAt: Date
      timezone: string
    }, ExtArgs["result"]["financialAuditLog"]>
    composites: {}
  }

  type FinancialAuditLogGetPayload<S extends boolean | null | undefined | FinancialAuditLogDefaultArgs> = $Result.GetResult<Prisma.$FinancialAuditLogPayload, S>

  type FinancialAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinancialAuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinancialAuditLogCountAggregateInputType | true
    }

  export interface FinancialAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialAuditLog'], meta: { name: 'FinancialAuditLog' } }
    /**
     * Find zero or one FinancialAuditLog that matches the filter.
     * @param {FinancialAuditLogFindUniqueArgs} args - Arguments to find a FinancialAuditLog
     * @example
     * // Get one FinancialAuditLog
     * const financialAuditLog = await prisma.financialAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancialAuditLogFindUniqueArgs>(args: SelectSubset<T, FinancialAuditLogFindUniqueArgs<ExtArgs>>): Prisma__FinancialAuditLogClient<$Result.GetResult<Prisma.$FinancialAuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FinancialAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinancialAuditLogFindUniqueOrThrowArgs} args - Arguments to find a FinancialAuditLog
     * @example
     * // Get one FinancialAuditLog
     * const financialAuditLog = await prisma.financialAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancialAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancialAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancialAuditLogClient<$Result.GetResult<Prisma.$FinancialAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialAuditLogFindFirstArgs} args - Arguments to find a FinancialAuditLog
     * @example
     * // Get one FinancialAuditLog
     * const financialAuditLog = await prisma.financialAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancialAuditLogFindFirstArgs>(args?: SelectSubset<T, FinancialAuditLogFindFirstArgs<ExtArgs>>): Prisma__FinancialAuditLogClient<$Result.GetResult<Prisma.$FinancialAuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialAuditLogFindFirstOrThrowArgs} args - Arguments to find a FinancialAuditLog
     * @example
     * // Get one FinancialAuditLog
     * const financialAuditLog = await prisma.financialAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancialAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancialAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancialAuditLogClient<$Result.GetResult<Prisma.$FinancialAuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinancialAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialAuditLogs
     * const financialAuditLogs = await prisma.financialAuditLog.findMany()
     * 
     * // Get first 10 FinancialAuditLogs
     * const financialAuditLogs = await prisma.financialAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financialAuditLogWithIdOnly = await prisma.financialAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancialAuditLogFindManyArgs>(args?: SelectSubset<T, FinancialAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FinancialAuditLog.
     * @param {FinancialAuditLogCreateArgs} args - Arguments to create a FinancialAuditLog.
     * @example
     * // Create one FinancialAuditLog
     * const FinancialAuditLog = await prisma.financialAuditLog.create({
     *   data: {
     *     // ... data to create a FinancialAuditLog
     *   }
     * })
     * 
     */
    create<T extends FinancialAuditLogCreateArgs>(args: SelectSubset<T, FinancialAuditLogCreateArgs<ExtArgs>>): Prisma__FinancialAuditLogClient<$Result.GetResult<Prisma.$FinancialAuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FinancialAuditLogs.
     * @param {FinancialAuditLogCreateManyArgs} args - Arguments to create many FinancialAuditLogs.
     * @example
     * // Create many FinancialAuditLogs
     * const financialAuditLog = await prisma.financialAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancialAuditLogCreateManyArgs>(args?: SelectSubset<T, FinancialAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinancialAuditLogs and returns the data saved in the database.
     * @param {FinancialAuditLogCreateManyAndReturnArgs} args - Arguments to create many FinancialAuditLogs.
     * @example
     * // Create many FinancialAuditLogs
     * const financialAuditLog = await prisma.financialAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinancialAuditLogs and only return the `id`
     * const financialAuditLogWithIdOnly = await prisma.financialAuditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinancialAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, FinancialAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialAuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FinancialAuditLog.
     * @param {FinancialAuditLogDeleteArgs} args - Arguments to delete one FinancialAuditLog.
     * @example
     * // Delete one FinancialAuditLog
     * const FinancialAuditLog = await prisma.financialAuditLog.delete({
     *   where: {
     *     // ... filter to delete one FinancialAuditLog
     *   }
     * })
     * 
     */
    delete<T extends FinancialAuditLogDeleteArgs>(args: SelectSubset<T, FinancialAuditLogDeleteArgs<ExtArgs>>): Prisma__FinancialAuditLogClient<$Result.GetResult<Prisma.$FinancialAuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FinancialAuditLog.
     * @param {FinancialAuditLogUpdateArgs} args - Arguments to update one FinancialAuditLog.
     * @example
     * // Update one FinancialAuditLog
     * const financialAuditLog = await prisma.financialAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancialAuditLogUpdateArgs>(args: SelectSubset<T, FinancialAuditLogUpdateArgs<ExtArgs>>): Prisma__FinancialAuditLogClient<$Result.GetResult<Prisma.$FinancialAuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FinancialAuditLogs.
     * @param {FinancialAuditLogDeleteManyArgs} args - Arguments to filter FinancialAuditLogs to delete.
     * @example
     * // Delete a few FinancialAuditLogs
     * const { count } = await prisma.financialAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancialAuditLogDeleteManyArgs>(args?: SelectSubset<T, FinancialAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialAuditLogs
     * const financialAuditLog = await prisma.financialAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancialAuditLogUpdateManyArgs>(args: SelectSubset<T, FinancialAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialAuditLogs and returns the data updated in the database.
     * @param {FinancialAuditLogUpdateManyAndReturnArgs} args - Arguments to update many FinancialAuditLogs.
     * @example
     * // Update many FinancialAuditLogs
     * const financialAuditLog = await prisma.financialAuditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FinancialAuditLogs and only return the `id`
     * const financialAuditLogWithIdOnly = await prisma.financialAuditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinancialAuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, FinancialAuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialAuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FinancialAuditLog.
     * @param {FinancialAuditLogUpsertArgs} args - Arguments to update or create a FinancialAuditLog.
     * @example
     * // Update or create a FinancialAuditLog
     * const financialAuditLog = await prisma.financialAuditLog.upsert({
     *   create: {
     *     // ... data to create a FinancialAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends FinancialAuditLogUpsertArgs>(args: SelectSubset<T, FinancialAuditLogUpsertArgs<ExtArgs>>): Prisma__FinancialAuditLogClient<$Result.GetResult<Prisma.$FinancialAuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FinancialAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialAuditLogCountArgs} args - Arguments to filter FinancialAuditLogs to count.
     * @example
     * // Count the number of FinancialAuditLogs
     * const count = await prisma.financialAuditLog.count({
     *   where: {
     *     // ... the filter for the FinancialAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends FinancialAuditLogCountArgs>(
      args?: Subset<T, FinancialAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialAuditLogAggregateArgs>(args: Subset<T, FinancialAuditLogAggregateArgs>): Prisma.PrismaPromise<GetFinancialAuditLogAggregateType<T>>

    /**
     * Group by FinancialAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: FinancialAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialAuditLog model
   */
  readonly fields: FinancialAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancialAuditLog model
   */
  interface FinancialAuditLogFieldRefs {
    readonly id: FieldRef<"FinancialAuditLog", 'String'>
    readonly userId: FieldRef<"FinancialAuditLog", 'String'>
    readonly sessionId: FieldRef<"FinancialAuditLog", 'String'>
    readonly operationType: FieldRef<"FinancialAuditLog", 'FinancialOperation'>
    readonly resourceType: FieldRef<"FinancialAuditLog", 'String'>
    readonly resourceId: FieldRef<"FinancialAuditLog", 'String'>
    readonly ipAddress: FieldRef<"FinancialAuditLog", 'String'>
    readonly userAgent: FieldRef<"FinancialAuditLog", 'String'>
    readonly httpMethod: FieldRef<"FinancialAuditLog", 'String'>
    readonly endpoint: FieldRef<"FinancialAuditLog", 'String'>
    readonly previousData: FieldRef<"FinancialAuditLog", 'Json'>
    readonly currentData: FieldRef<"FinancialAuditLog", 'Json'>
    readonly changedFields: FieldRef<"FinancialAuditLog", 'String[]'>
    readonly amount: FieldRef<"FinancialAuditLog", 'Decimal'>
    readonly gstAmount: FieldRef<"FinancialAuditLog", 'Decimal'>
    readonly currency: FieldRef<"FinancialAuditLog", 'String'>
    readonly taxYear: FieldRef<"FinancialAuditLog", 'String'>
    readonly success: FieldRef<"FinancialAuditLog", 'Boolean'>
    readonly errorMessage: FieldRef<"FinancialAuditLog", 'String'>
    readonly hashChain: FieldRef<"FinancialAuditLog", 'String'>
    readonly previousHash: FieldRef<"FinancialAuditLog", 'String'>
    readonly createdAt: FieldRef<"FinancialAuditLog", 'DateTime'>
    readonly timezone: FieldRef<"FinancialAuditLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FinancialAuditLog findUnique
   */
  export type FinancialAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAuditLog
     */
    select?: FinancialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAuditLog
     */
    omit?: FinancialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which FinancialAuditLog to fetch.
     */
    where: FinancialAuditLogWhereUniqueInput
  }

  /**
   * FinancialAuditLog findUniqueOrThrow
   */
  export type FinancialAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAuditLog
     */
    select?: FinancialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAuditLog
     */
    omit?: FinancialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which FinancialAuditLog to fetch.
     */
    where: FinancialAuditLogWhereUniqueInput
  }

  /**
   * FinancialAuditLog findFirst
   */
  export type FinancialAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAuditLog
     */
    select?: FinancialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAuditLog
     */
    omit?: FinancialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which FinancialAuditLog to fetch.
     */
    where?: FinancialAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialAuditLogs to fetch.
     */
    orderBy?: FinancialAuditLogOrderByWithRelationInput | FinancialAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialAuditLogs.
     */
    cursor?: FinancialAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialAuditLogs.
     */
    distinct?: FinancialAuditLogScalarFieldEnum | FinancialAuditLogScalarFieldEnum[]
  }

  /**
   * FinancialAuditLog findFirstOrThrow
   */
  export type FinancialAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAuditLog
     */
    select?: FinancialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAuditLog
     */
    omit?: FinancialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which FinancialAuditLog to fetch.
     */
    where?: FinancialAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialAuditLogs to fetch.
     */
    orderBy?: FinancialAuditLogOrderByWithRelationInput | FinancialAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialAuditLogs.
     */
    cursor?: FinancialAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialAuditLogs.
     */
    distinct?: FinancialAuditLogScalarFieldEnum | FinancialAuditLogScalarFieldEnum[]
  }

  /**
   * FinancialAuditLog findMany
   */
  export type FinancialAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAuditLog
     */
    select?: FinancialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAuditLog
     */
    omit?: FinancialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which FinancialAuditLogs to fetch.
     */
    where?: FinancialAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialAuditLogs to fetch.
     */
    orderBy?: FinancialAuditLogOrderByWithRelationInput | FinancialAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialAuditLogs.
     */
    cursor?: FinancialAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialAuditLogs.
     */
    skip?: number
    distinct?: FinancialAuditLogScalarFieldEnum | FinancialAuditLogScalarFieldEnum[]
  }

  /**
   * FinancialAuditLog create
   */
  export type FinancialAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAuditLog
     */
    select?: FinancialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAuditLog
     */
    omit?: FinancialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a FinancialAuditLog.
     */
    data: XOR<FinancialAuditLogCreateInput, FinancialAuditLogUncheckedCreateInput>
  }

  /**
   * FinancialAuditLog createMany
   */
  export type FinancialAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialAuditLogs.
     */
    data: FinancialAuditLogCreateManyInput | FinancialAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancialAuditLog createManyAndReturn
   */
  export type FinancialAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAuditLog
     */
    select?: FinancialAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAuditLog
     */
    omit?: FinancialAuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many FinancialAuditLogs.
     */
    data: FinancialAuditLogCreateManyInput | FinancialAuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialAuditLog update
   */
  export type FinancialAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAuditLog
     */
    select?: FinancialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAuditLog
     */
    omit?: FinancialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a FinancialAuditLog.
     */
    data: XOR<FinancialAuditLogUpdateInput, FinancialAuditLogUncheckedUpdateInput>
    /**
     * Choose, which FinancialAuditLog to update.
     */
    where: FinancialAuditLogWhereUniqueInput
  }

  /**
   * FinancialAuditLog updateMany
   */
  export type FinancialAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialAuditLogs.
     */
    data: XOR<FinancialAuditLogUpdateManyMutationInput, FinancialAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which FinancialAuditLogs to update
     */
    where?: FinancialAuditLogWhereInput
    /**
     * Limit how many FinancialAuditLogs to update.
     */
    limit?: number
  }

  /**
   * FinancialAuditLog updateManyAndReturn
   */
  export type FinancialAuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAuditLog
     */
    select?: FinancialAuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAuditLog
     */
    omit?: FinancialAuditLogOmit<ExtArgs> | null
    /**
     * The data used to update FinancialAuditLogs.
     */
    data: XOR<FinancialAuditLogUpdateManyMutationInput, FinancialAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which FinancialAuditLogs to update
     */
    where?: FinancialAuditLogWhereInput
    /**
     * Limit how many FinancialAuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialAuditLog upsert
   */
  export type FinancialAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAuditLog
     */
    select?: FinancialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAuditLog
     */
    omit?: FinancialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the FinancialAuditLog to update in case it exists.
     */
    where: FinancialAuditLogWhereUniqueInput
    /**
     * In case the FinancialAuditLog found by the `where` argument doesn't exist, create a new FinancialAuditLog with this data.
     */
    create: XOR<FinancialAuditLogCreateInput, FinancialAuditLogUncheckedCreateInput>
    /**
     * In case the FinancialAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialAuditLogUpdateInput, FinancialAuditLogUncheckedUpdateInput>
  }

  /**
   * FinancialAuditLog delete
   */
  export type FinancialAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAuditLog
     */
    select?: FinancialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAuditLog
     */
    omit?: FinancialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAuditLogInclude<ExtArgs> | null
    /**
     * Filter which FinancialAuditLog to delete.
     */
    where: FinancialAuditLogWhereUniqueInput
  }

  /**
   * FinancialAuditLog deleteMany
   */
  export type FinancialAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialAuditLogs to delete
     */
    where?: FinancialAuditLogWhereInput
    /**
     * Limit how many FinancialAuditLogs to delete.
     */
    limit?: number
  }

  /**
   * FinancialAuditLog without action
   */
  export type FinancialAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAuditLog
     */
    select?: FinancialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAuditLog
     */
    omit?: FinancialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    amount: number | null
    failedPaymentCount: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    amount: number | null
    failedPaymentCount: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    stripePriceId: string | null
    status: string | null
    plan: $Enums.Plan | null
    interval: string | null
    amount: number | null
    currency: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    cancelledAt: Date | null
    trialEnd: Date | null
    defaultPaymentMethodId: string | null
    lastPaymentAttempt: Date | null
    failedPaymentCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    stripePriceId: string | null
    status: string | null
    plan: $Enums.Plan | null
    interval: string | null
    amount: number | null
    currency: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    cancelledAt: Date | null
    trialEnd: Date | null
    defaultPaymentMethodId: string | null
    lastPaymentAttempt: Date | null
    failedPaymentCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    stripePriceId: number
    status: number
    plan: number
    interval: number
    amount: number
    currency: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelAtPeriodEnd: number
    cancelledAt: number
    trialEnd: number
    defaultPaymentMethodId: number
    lastPaymentAttempt: number
    failedPaymentCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    amount?: true
    failedPaymentCount?: true
  }

  export type SubscriptionSumAggregateInputType = {
    amount?: true
    failedPaymentCount?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripePriceId?: true
    status?: true
    plan?: true
    interval?: true
    amount?: true
    currency?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    cancelledAt?: true
    trialEnd?: true
    defaultPaymentMethodId?: true
    lastPaymentAttempt?: true
    failedPaymentCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripePriceId?: true
    status?: true
    plan?: true
    interval?: true
    amount?: true
    currency?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    cancelledAt?: true
    trialEnd?: true
    defaultPaymentMethodId?: true
    lastPaymentAttempt?: true
    failedPaymentCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripePriceId?: true
    status?: true
    plan?: true
    interval?: true
    amount?: true
    currency?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    cancelledAt?: true
    trialEnd?: true
    defaultPaymentMethodId?: true
    lastPaymentAttempt?: true
    failedPaymentCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    stripePriceId: string
    status: string
    plan: $Enums.Plan
    interval: string
    amount: number
    currency: string
    currentPeriodStart: Date
    currentPeriodEnd: Date
    cancelAtPeriodEnd: boolean
    cancelledAt: Date | null
    trialEnd: Date | null
    defaultPaymentMethodId: string | null
    lastPaymentAttempt: Date | null
    failedPaymentCount: number
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    status?: boolean
    plan?: boolean
    interval?: boolean
    amount?: boolean
    currency?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    cancelledAt?: boolean
    trialEnd?: boolean
    defaultPaymentMethodId?: boolean
    lastPaymentAttempt?: boolean
    failedPaymentCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    status?: boolean
    plan?: boolean
    interval?: boolean
    amount?: boolean
    currency?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    cancelledAt?: boolean
    trialEnd?: boolean
    defaultPaymentMethodId?: boolean
    lastPaymentAttempt?: boolean
    failedPaymentCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    status?: boolean
    plan?: boolean
    interval?: boolean
    amount?: boolean
    currency?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    cancelledAt?: boolean
    trialEnd?: boolean
    defaultPaymentMethodId?: boolean
    lastPaymentAttempt?: boolean
    failedPaymentCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    status?: boolean
    plan?: boolean
    interval?: boolean
    amount?: boolean
    currency?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    cancelledAt?: boolean
    trialEnd?: boolean
    defaultPaymentMethodId?: boolean
    lastPaymentAttempt?: boolean
    failedPaymentCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "stripeCustomerId" | "stripeSubscriptionId" | "stripePriceId" | "status" | "plan" | "interval" | "amount" | "currency" | "currentPeriodStart" | "currentPeriodEnd" | "cancelAtPeriodEnd" | "cancelledAt" | "trialEnd" | "defaultPaymentMethodId" | "lastPaymentAttempt" | "failedPaymentCount" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      stripeCustomerId: string
      stripeSubscriptionId: string
      stripePriceId: string
      status: string
      plan: $Enums.Plan
      interval: string
      amount: number
      currency: string
      currentPeriodStart: Date
      currentPeriodEnd: Date
      cancelAtPeriodEnd: boolean
      cancelledAt: Date | null
      trialEnd: Date | null
      defaultPaymentMethodId: string | null
      lastPaymentAttempt: Date | null
      failedPaymentCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'String'>
    readonly stripeCustomerId: FieldRef<"Subscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly stripePriceId: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly plan: FieldRef<"Subscription", 'Plan'>
    readonly interval: FieldRef<"Subscription", 'String'>
    readonly amount: FieldRef<"Subscription", 'Int'>
    readonly currency: FieldRef<"Subscription", 'String'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"Subscription", 'Boolean'>
    readonly cancelledAt: FieldRef<"Subscription", 'DateTime'>
    readonly trialEnd: FieldRef<"Subscription", 'DateTime'>
    readonly defaultPaymentMethodId: FieldRef<"Subscription", 'String'>
    readonly lastPaymentAttempt: FieldRef<"Subscription", 'DateTime'>
    readonly failedPaymentCount: FieldRef<"Subscription", 'Int'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model TaxReturn
   */

  export type AggregateTaxReturn = {
    _count: TaxReturnCountAggregateOutputType | null
    _min: TaxReturnMinAggregateOutputType | null
    _max: TaxReturnMaxAggregateOutputType | null
  }

  export type TaxReturnMinAggregateOutputType = {
    id: string | null
    userId: string | null
    year: string | null
    status: $Enums.TaxReturnStatus | null
    submittedAt: Date | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxReturnMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    year: string | null
    status: $Enums.TaxReturnStatus | null
    submittedAt: Date | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxReturnCountAggregateOutputType = {
    id: number
    userId: number
    year: number
    data: number
    status: number
    submittedAt: number
    processedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaxReturnMinAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    status?: true
    submittedAt?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxReturnMaxAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    status?: true
    submittedAt?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxReturnCountAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    data?: true
    status?: true
    submittedAt?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaxReturnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxReturn to aggregate.
     */
    where?: TaxReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxReturns to fetch.
     */
    orderBy?: TaxReturnOrderByWithRelationInput | TaxReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxReturns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxReturns
    **/
    _count?: true | TaxReturnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxReturnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxReturnMaxAggregateInputType
  }

  export type GetTaxReturnAggregateType<T extends TaxReturnAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxReturn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxReturn[P]>
      : GetScalarType<T[P], AggregateTaxReturn[P]>
  }




  export type TaxReturnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxReturnWhereInput
    orderBy?: TaxReturnOrderByWithAggregationInput | TaxReturnOrderByWithAggregationInput[]
    by: TaxReturnScalarFieldEnum[] | TaxReturnScalarFieldEnum
    having?: TaxReturnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxReturnCountAggregateInputType | true
    _min?: TaxReturnMinAggregateInputType
    _max?: TaxReturnMaxAggregateInputType
  }

  export type TaxReturnGroupByOutputType = {
    id: string
    userId: string
    year: string
    data: JsonValue
    status: $Enums.TaxReturnStatus
    submittedAt: Date | null
    processedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TaxReturnCountAggregateOutputType | null
    _min: TaxReturnMinAggregateOutputType | null
    _max: TaxReturnMaxAggregateOutputType | null
  }

  type GetTaxReturnGroupByPayload<T extends TaxReturnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxReturnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxReturnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxReturnGroupByOutputType[P]>
            : GetScalarType<T[P], TaxReturnGroupByOutputType[P]>
        }
      >
    >


  export type TaxReturnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    data?: boolean
    status?: boolean
    submittedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxReturn"]>

  export type TaxReturnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    data?: boolean
    status?: boolean
    submittedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxReturn"]>

  export type TaxReturnSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    data?: boolean
    status?: boolean
    submittedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxReturn"]>

  export type TaxReturnSelectScalar = {
    id?: boolean
    userId?: boolean
    year?: boolean
    data?: boolean
    status?: boolean
    submittedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaxReturnOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "year" | "data" | "status" | "submittedAt" | "processedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["taxReturn"]>
  export type TaxReturnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaxReturnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaxReturnIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaxReturnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxReturn"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      year: string
      data: Prisma.JsonValue
      status: $Enums.TaxReturnStatus
      submittedAt: Date | null
      processedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taxReturn"]>
    composites: {}
  }

  type TaxReturnGetPayload<S extends boolean | null | undefined | TaxReturnDefaultArgs> = $Result.GetResult<Prisma.$TaxReturnPayload, S>

  type TaxReturnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaxReturnFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxReturnCountAggregateInputType | true
    }

  export interface TaxReturnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxReturn'], meta: { name: 'TaxReturn' } }
    /**
     * Find zero or one TaxReturn that matches the filter.
     * @param {TaxReturnFindUniqueArgs} args - Arguments to find a TaxReturn
     * @example
     * // Get one TaxReturn
     * const taxReturn = await prisma.taxReturn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxReturnFindUniqueArgs>(args: SelectSubset<T, TaxReturnFindUniqueArgs<ExtArgs>>): Prisma__TaxReturnClient<$Result.GetResult<Prisma.$TaxReturnPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaxReturn that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaxReturnFindUniqueOrThrowArgs} args - Arguments to find a TaxReturn
     * @example
     * // Get one TaxReturn
     * const taxReturn = await prisma.taxReturn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxReturnFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxReturnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxReturnClient<$Result.GetResult<Prisma.$TaxReturnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxReturn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxReturnFindFirstArgs} args - Arguments to find a TaxReturn
     * @example
     * // Get one TaxReturn
     * const taxReturn = await prisma.taxReturn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxReturnFindFirstArgs>(args?: SelectSubset<T, TaxReturnFindFirstArgs<ExtArgs>>): Prisma__TaxReturnClient<$Result.GetResult<Prisma.$TaxReturnPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxReturn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxReturnFindFirstOrThrowArgs} args - Arguments to find a TaxReturn
     * @example
     * // Get one TaxReturn
     * const taxReturn = await prisma.taxReturn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxReturnFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxReturnFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxReturnClient<$Result.GetResult<Prisma.$TaxReturnPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaxReturns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxReturnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxReturns
     * const taxReturns = await prisma.taxReturn.findMany()
     * 
     * // Get first 10 TaxReturns
     * const taxReturns = await prisma.taxReturn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxReturnWithIdOnly = await prisma.taxReturn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxReturnFindManyArgs>(args?: SelectSubset<T, TaxReturnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaxReturn.
     * @param {TaxReturnCreateArgs} args - Arguments to create a TaxReturn.
     * @example
     * // Create one TaxReturn
     * const TaxReturn = await prisma.taxReturn.create({
     *   data: {
     *     // ... data to create a TaxReturn
     *   }
     * })
     * 
     */
    create<T extends TaxReturnCreateArgs>(args: SelectSubset<T, TaxReturnCreateArgs<ExtArgs>>): Prisma__TaxReturnClient<$Result.GetResult<Prisma.$TaxReturnPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaxReturns.
     * @param {TaxReturnCreateManyArgs} args - Arguments to create many TaxReturns.
     * @example
     * // Create many TaxReturns
     * const taxReturn = await prisma.taxReturn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxReturnCreateManyArgs>(args?: SelectSubset<T, TaxReturnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxReturns and returns the data saved in the database.
     * @param {TaxReturnCreateManyAndReturnArgs} args - Arguments to create many TaxReturns.
     * @example
     * // Create many TaxReturns
     * const taxReturn = await prisma.taxReturn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxReturns and only return the `id`
     * const taxReturnWithIdOnly = await prisma.taxReturn.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxReturnCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxReturnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxReturnPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaxReturn.
     * @param {TaxReturnDeleteArgs} args - Arguments to delete one TaxReturn.
     * @example
     * // Delete one TaxReturn
     * const TaxReturn = await prisma.taxReturn.delete({
     *   where: {
     *     // ... filter to delete one TaxReturn
     *   }
     * })
     * 
     */
    delete<T extends TaxReturnDeleteArgs>(args: SelectSubset<T, TaxReturnDeleteArgs<ExtArgs>>): Prisma__TaxReturnClient<$Result.GetResult<Prisma.$TaxReturnPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaxReturn.
     * @param {TaxReturnUpdateArgs} args - Arguments to update one TaxReturn.
     * @example
     * // Update one TaxReturn
     * const taxReturn = await prisma.taxReturn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxReturnUpdateArgs>(args: SelectSubset<T, TaxReturnUpdateArgs<ExtArgs>>): Prisma__TaxReturnClient<$Result.GetResult<Prisma.$TaxReturnPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaxReturns.
     * @param {TaxReturnDeleteManyArgs} args - Arguments to filter TaxReturns to delete.
     * @example
     * // Delete a few TaxReturns
     * const { count } = await prisma.taxReturn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxReturnDeleteManyArgs>(args?: SelectSubset<T, TaxReturnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxReturns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxReturnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxReturns
     * const taxReturn = await prisma.taxReturn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxReturnUpdateManyArgs>(args: SelectSubset<T, TaxReturnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxReturns and returns the data updated in the database.
     * @param {TaxReturnUpdateManyAndReturnArgs} args - Arguments to update many TaxReturns.
     * @example
     * // Update many TaxReturns
     * const taxReturn = await prisma.taxReturn.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaxReturns and only return the `id`
     * const taxReturnWithIdOnly = await prisma.taxReturn.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaxReturnUpdateManyAndReturnArgs>(args: SelectSubset<T, TaxReturnUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxReturnPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaxReturn.
     * @param {TaxReturnUpsertArgs} args - Arguments to update or create a TaxReturn.
     * @example
     * // Update or create a TaxReturn
     * const taxReturn = await prisma.taxReturn.upsert({
     *   create: {
     *     // ... data to create a TaxReturn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxReturn we want to update
     *   }
     * })
     */
    upsert<T extends TaxReturnUpsertArgs>(args: SelectSubset<T, TaxReturnUpsertArgs<ExtArgs>>): Prisma__TaxReturnClient<$Result.GetResult<Prisma.$TaxReturnPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaxReturns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxReturnCountArgs} args - Arguments to filter TaxReturns to count.
     * @example
     * // Count the number of TaxReturns
     * const count = await prisma.taxReturn.count({
     *   where: {
     *     // ... the filter for the TaxReturns we want to count
     *   }
     * })
    **/
    count<T extends TaxReturnCountArgs>(
      args?: Subset<T, TaxReturnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxReturnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxReturn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxReturnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxReturnAggregateArgs>(args: Subset<T, TaxReturnAggregateArgs>): Prisma.PrismaPromise<GetTaxReturnAggregateType<T>>

    /**
     * Group by TaxReturn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxReturnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxReturnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxReturnGroupByArgs['orderBy'] }
        : { orderBy?: TaxReturnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxReturnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxReturnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxReturn model
   */
  readonly fields: TaxReturnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxReturn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxReturnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxReturn model
   */
  interface TaxReturnFieldRefs {
    readonly id: FieldRef<"TaxReturn", 'String'>
    readonly userId: FieldRef<"TaxReturn", 'String'>
    readonly year: FieldRef<"TaxReturn", 'String'>
    readonly data: FieldRef<"TaxReturn", 'Json'>
    readonly status: FieldRef<"TaxReturn", 'TaxReturnStatus'>
    readonly submittedAt: FieldRef<"TaxReturn", 'DateTime'>
    readonly processedAt: FieldRef<"TaxReturn", 'DateTime'>
    readonly createdAt: FieldRef<"TaxReturn", 'DateTime'>
    readonly updatedAt: FieldRef<"TaxReturn", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaxReturn findUnique
   */
  export type TaxReturnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxReturn
     */
    select?: TaxReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxReturn
     */
    omit?: TaxReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxReturnInclude<ExtArgs> | null
    /**
     * Filter, which TaxReturn to fetch.
     */
    where: TaxReturnWhereUniqueInput
  }

  /**
   * TaxReturn findUniqueOrThrow
   */
  export type TaxReturnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxReturn
     */
    select?: TaxReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxReturn
     */
    omit?: TaxReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxReturnInclude<ExtArgs> | null
    /**
     * Filter, which TaxReturn to fetch.
     */
    where: TaxReturnWhereUniqueInput
  }

  /**
   * TaxReturn findFirst
   */
  export type TaxReturnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxReturn
     */
    select?: TaxReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxReturn
     */
    omit?: TaxReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxReturnInclude<ExtArgs> | null
    /**
     * Filter, which TaxReturn to fetch.
     */
    where?: TaxReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxReturns to fetch.
     */
    orderBy?: TaxReturnOrderByWithRelationInput | TaxReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxReturns.
     */
    cursor?: TaxReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxReturns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxReturns.
     */
    distinct?: TaxReturnScalarFieldEnum | TaxReturnScalarFieldEnum[]
  }

  /**
   * TaxReturn findFirstOrThrow
   */
  export type TaxReturnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxReturn
     */
    select?: TaxReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxReturn
     */
    omit?: TaxReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxReturnInclude<ExtArgs> | null
    /**
     * Filter, which TaxReturn to fetch.
     */
    where?: TaxReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxReturns to fetch.
     */
    orderBy?: TaxReturnOrderByWithRelationInput | TaxReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxReturns.
     */
    cursor?: TaxReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxReturns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxReturns.
     */
    distinct?: TaxReturnScalarFieldEnum | TaxReturnScalarFieldEnum[]
  }

  /**
   * TaxReturn findMany
   */
  export type TaxReturnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxReturn
     */
    select?: TaxReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxReturn
     */
    omit?: TaxReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxReturnInclude<ExtArgs> | null
    /**
     * Filter, which TaxReturns to fetch.
     */
    where?: TaxReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxReturns to fetch.
     */
    orderBy?: TaxReturnOrderByWithRelationInput | TaxReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxReturns.
     */
    cursor?: TaxReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxReturns.
     */
    skip?: number
    distinct?: TaxReturnScalarFieldEnum | TaxReturnScalarFieldEnum[]
  }

  /**
   * TaxReturn create
   */
  export type TaxReturnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxReturn
     */
    select?: TaxReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxReturn
     */
    omit?: TaxReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxReturnInclude<ExtArgs> | null
    /**
     * The data needed to create a TaxReturn.
     */
    data: XOR<TaxReturnCreateInput, TaxReturnUncheckedCreateInput>
  }

  /**
   * TaxReturn createMany
   */
  export type TaxReturnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxReturns.
     */
    data: TaxReturnCreateManyInput | TaxReturnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxReturn createManyAndReturn
   */
  export type TaxReturnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxReturn
     */
    select?: TaxReturnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxReturn
     */
    omit?: TaxReturnOmit<ExtArgs> | null
    /**
     * The data used to create many TaxReturns.
     */
    data: TaxReturnCreateManyInput | TaxReturnCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxReturnIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxReturn update
   */
  export type TaxReturnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxReturn
     */
    select?: TaxReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxReturn
     */
    omit?: TaxReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxReturnInclude<ExtArgs> | null
    /**
     * The data needed to update a TaxReturn.
     */
    data: XOR<TaxReturnUpdateInput, TaxReturnUncheckedUpdateInput>
    /**
     * Choose, which TaxReturn to update.
     */
    where: TaxReturnWhereUniqueInput
  }

  /**
   * TaxReturn updateMany
   */
  export type TaxReturnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxReturns.
     */
    data: XOR<TaxReturnUpdateManyMutationInput, TaxReturnUncheckedUpdateManyInput>
    /**
     * Filter which TaxReturns to update
     */
    where?: TaxReturnWhereInput
    /**
     * Limit how many TaxReturns to update.
     */
    limit?: number
  }

  /**
   * TaxReturn updateManyAndReturn
   */
  export type TaxReturnUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxReturn
     */
    select?: TaxReturnSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxReturn
     */
    omit?: TaxReturnOmit<ExtArgs> | null
    /**
     * The data used to update TaxReturns.
     */
    data: XOR<TaxReturnUpdateManyMutationInput, TaxReturnUncheckedUpdateManyInput>
    /**
     * Filter which TaxReturns to update
     */
    where?: TaxReturnWhereInput
    /**
     * Limit how many TaxReturns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxReturnIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxReturn upsert
   */
  export type TaxReturnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxReturn
     */
    select?: TaxReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxReturn
     */
    omit?: TaxReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxReturnInclude<ExtArgs> | null
    /**
     * The filter to search for the TaxReturn to update in case it exists.
     */
    where: TaxReturnWhereUniqueInput
    /**
     * In case the TaxReturn found by the `where` argument doesn't exist, create a new TaxReturn with this data.
     */
    create: XOR<TaxReturnCreateInput, TaxReturnUncheckedCreateInput>
    /**
     * In case the TaxReturn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxReturnUpdateInput, TaxReturnUncheckedUpdateInput>
  }

  /**
   * TaxReturn delete
   */
  export type TaxReturnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxReturn
     */
    select?: TaxReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxReturn
     */
    omit?: TaxReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxReturnInclude<ExtArgs> | null
    /**
     * Filter which TaxReturn to delete.
     */
    where: TaxReturnWhereUniqueInput
  }

  /**
   * TaxReturn deleteMany
   */
  export type TaxReturnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxReturns to delete
     */
    where?: TaxReturnWhereInput
    /**
     * Limit how many TaxReturns to delete.
     */
    limit?: number
  }

  /**
   * TaxReturn without action
   */
  export type TaxReturnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxReturn
     */
    select?: TaxReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxReturn
     */
    omit?: TaxReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxReturnInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    stripePaymentIntentId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    stripePaymentIntentId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    userId: number
    stripePaymentIntentId: number
    amount: number
    currency: number
    status: number
    description: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    userId?: true
    stripePaymentIntentId?: true
    amount?: true
    currency?: true
    status?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    userId?: true
    stripePaymentIntentId?: true
    amount?: true
    currency?: true
    status?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    userId?: true
    stripePaymentIntentId?: true
    amount?: true
    currency?: true
    status?: true
    description?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    userId: string
    stripePaymentIntentId: string
    amount: number
    currency: string
    status: string
    description: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripePaymentIntentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripePaymentIntentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripePaymentIntentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    userId?: boolean
    stripePaymentIntentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "stripePaymentIntentId" | "amount" | "currency" | "status" | "description" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      stripePaymentIntentId: string
      amount: number
      currency: string
      status: string
      description: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly stripePaymentIntentId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Int'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly description: FieldRef<"Payment", 'String'>
    readonly metadata: FieldRef<"Payment", 'Json'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: number | null
    gstAmount: number | null
    total: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: number | null
    gstAmount: number | null
    total: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    stripeInvoiceId: string | null
    customerName: string | null
    customerEmail: string | null
    customerABN: string | null
    subtotal: number | null
    gstAmount: number | null
    total: number | null
    status: string | null
    invoiceDate: Date | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    stripeInvoiceId: string | null
    customerName: string | null
    customerEmail: string | null
    customerABN: string | null
    subtotal: number | null
    gstAmount: number | null
    total: number | null
    status: string | null
    invoiceDate: Date | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    stripeInvoiceId: number
    customerName: number
    customerEmail: number
    customerABN: number
    subtotal: number
    gstAmount: number
    total: number
    status: number
    invoiceDate: number
    paidAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    gstAmount?: true
    total?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    gstAmount?: true
    total?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    stripeInvoiceId?: true
    customerName?: true
    customerEmail?: true
    customerABN?: true
    subtotal?: true
    gstAmount?: true
    total?: true
    status?: true
    invoiceDate?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    stripeInvoiceId?: true
    customerName?: true
    customerEmail?: true
    customerABN?: true
    subtotal?: true
    gstAmount?: true
    total?: true
    status?: true
    invoiceDate?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    stripeInvoiceId?: true
    customerName?: true
    customerEmail?: true
    customerABN?: true
    subtotal?: true
    gstAmount?: true
    total?: true
    status?: true
    invoiceDate?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    invoiceNumber: string
    stripeInvoiceId: string
    customerName: string
    customerEmail: string
    customerABN: string | null
    subtotal: number
    gstAmount: number
    total: number
    status: string
    invoiceDate: Date
    paidAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    stripeInvoiceId?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerABN?: boolean
    subtotal?: boolean
    gstAmount?: boolean
    total?: boolean
    status?: boolean
    invoiceDate?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lineItems?: boolean | Invoice$lineItemsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    stripeInvoiceId?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerABN?: boolean
    subtotal?: boolean
    gstAmount?: boolean
    total?: boolean
    status?: boolean
    invoiceDate?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    stripeInvoiceId?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerABN?: boolean
    subtotal?: boolean
    gstAmount?: boolean
    total?: boolean
    status?: boolean
    invoiceDate?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    stripeInvoiceId?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerABN?: boolean
    subtotal?: boolean
    gstAmount?: boolean
    total?: boolean
    status?: boolean
    invoiceDate?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNumber" | "stripeInvoiceId" | "customerName" | "customerEmail" | "customerABN" | "subtotal" | "gstAmount" | "total" | "status" | "invoiceDate" | "paidAt" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItems?: boolean | Invoice$lineItemsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      lineItems: Prisma.$InvoiceLineItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNumber: string
      stripeInvoiceId: string
      customerName: string
      customerEmail: string
      customerABN: string | null
      subtotal: number
      gstAmount: number
      total: number
      status: string
      invoiceDate: Date
      paidAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lineItems<T extends Invoice$lineItemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$lineItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly stripeInvoiceId: FieldRef<"Invoice", 'String'>
    readonly customerName: FieldRef<"Invoice", 'String'>
    readonly customerEmail: FieldRef<"Invoice", 'String'>
    readonly customerABN: FieldRef<"Invoice", 'String'>
    readonly subtotal: FieldRef<"Invoice", 'Int'>
    readonly gstAmount: FieldRef<"Invoice", 'Int'>
    readonly total: FieldRef<"Invoice", 'Int'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly invoiceDate: FieldRef<"Invoice", 'DateTime'>
    readonly paidAt: FieldRef<"Invoice", 'DateTime'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.lineItems
   */
  export type Invoice$lineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    where?: InvoiceLineItemWhereInput
    orderBy?: InvoiceLineItemOrderByWithRelationInput | InvoiceLineItemOrderByWithRelationInput[]
    cursor?: InvoiceLineItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceLineItemScalarFieldEnum | InvoiceLineItemScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceLineItem
   */

  export type AggregateInvoiceLineItem = {
    _count: InvoiceLineItemCountAggregateOutputType | null
    _avg: InvoiceLineItemAvgAggregateOutputType | null
    _sum: InvoiceLineItemSumAggregateOutputType | null
    _min: InvoiceLineItemMinAggregateOutputType | null
    _max: InvoiceLineItemMaxAggregateOutputType | null
  }

  export type InvoiceLineItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type InvoiceLineItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type InvoiceLineItemMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceLineItemMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceLineItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    description: number
    quantity: number
    unitPrice: number
    totalPrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceLineItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type InvoiceLineItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type InvoiceLineItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceLineItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceLineItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceLineItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLineItem to aggregate.
     */
    where?: InvoiceLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLineItems to fetch.
     */
    orderBy?: InvoiceLineItemOrderByWithRelationInput | InvoiceLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceLineItems
    **/
    _count?: true | InvoiceLineItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceLineItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceLineItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceLineItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceLineItemMaxAggregateInputType
  }

  export type GetInvoiceLineItemAggregateType<T extends InvoiceLineItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceLineItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceLineItem[P]>
      : GetScalarType<T[P], AggregateInvoiceLineItem[P]>
  }




  export type InvoiceLineItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineItemWhereInput
    orderBy?: InvoiceLineItemOrderByWithAggregationInput | InvoiceLineItemOrderByWithAggregationInput[]
    by: InvoiceLineItemScalarFieldEnum[] | InvoiceLineItemScalarFieldEnum
    having?: InvoiceLineItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceLineItemCountAggregateInputType | true
    _avg?: InvoiceLineItemAvgAggregateInputType
    _sum?: InvoiceLineItemSumAggregateInputType
    _min?: InvoiceLineItemMinAggregateInputType
    _max?: InvoiceLineItemMaxAggregateInputType
  }

  export type InvoiceLineItemGroupByOutputType = {
    id: string
    invoiceId: string
    description: string
    quantity: number
    unitPrice: number
    totalPrice: number
    createdAt: Date
    updatedAt: Date
    _count: InvoiceLineItemCountAggregateOutputType | null
    _avg: InvoiceLineItemAvgAggregateOutputType | null
    _sum: InvoiceLineItemSumAggregateOutputType | null
    _min: InvoiceLineItemMinAggregateOutputType | null
    _max: InvoiceLineItemMaxAggregateOutputType | null
  }

  type GetInvoiceLineItemGroupByPayload<T extends InvoiceLineItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceLineItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceLineItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceLineItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceLineItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceLineItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLineItem"]>

  export type InvoiceLineItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLineItem"]>

  export type InvoiceLineItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLineItem"]>

  export type InvoiceLineItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceLineItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "description" | "quantity" | "unitPrice" | "totalPrice" | "createdAt" | "updatedAt", ExtArgs["result"]["invoiceLineItem"]>
  export type InvoiceLineItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceLineItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceLineItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceLineItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceLineItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      description: string
      quantity: number
      unitPrice: number
      totalPrice: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoiceLineItem"]>
    composites: {}
  }

  type InvoiceLineItemGetPayload<S extends boolean | null | undefined | InvoiceLineItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceLineItemPayload, S>

  type InvoiceLineItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceLineItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceLineItemCountAggregateInputType | true
    }

  export interface InvoiceLineItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceLineItem'], meta: { name: 'InvoiceLineItem' } }
    /**
     * Find zero or one InvoiceLineItem that matches the filter.
     * @param {InvoiceLineItemFindUniqueArgs} args - Arguments to find a InvoiceLineItem
     * @example
     * // Get one InvoiceLineItem
     * const invoiceLineItem = await prisma.invoiceLineItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceLineItemFindUniqueArgs>(args: SelectSubset<T, InvoiceLineItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceLineItemClient<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceLineItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceLineItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceLineItem
     * @example
     * // Get one InvoiceLineItem
     * const invoiceLineItem = await prisma.invoiceLineItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceLineItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceLineItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceLineItemClient<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceLineItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemFindFirstArgs} args - Arguments to find a InvoiceLineItem
     * @example
     * // Get one InvoiceLineItem
     * const invoiceLineItem = await prisma.invoiceLineItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceLineItemFindFirstArgs>(args?: SelectSubset<T, InvoiceLineItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceLineItemClient<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceLineItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceLineItem
     * @example
     * // Get one InvoiceLineItem
     * const invoiceLineItem = await prisma.invoiceLineItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceLineItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceLineItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceLineItemClient<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceLineItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceLineItems
     * const invoiceLineItems = await prisma.invoiceLineItem.findMany()
     * 
     * // Get first 10 InvoiceLineItems
     * const invoiceLineItems = await prisma.invoiceLineItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceLineItemWithIdOnly = await prisma.invoiceLineItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceLineItemFindManyArgs>(args?: SelectSubset<T, InvoiceLineItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceLineItem.
     * @param {InvoiceLineItemCreateArgs} args - Arguments to create a InvoiceLineItem.
     * @example
     * // Create one InvoiceLineItem
     * const InvoiceLineItem = await prisma.invoiceLineItem.create({
     *   data: {
     *     // ... data to create a InvoiceLineItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceLineItemCreateArgs>(args: SelectSubset<T, InvoiceLineItemCreateArgs<ExtArgs>>): Prisma__InvoiceLineItemClient<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceLineItems.
     * @param {InvoiceLineItemCreateManyArgs} args - Arguments to create many InvoiceLineItems.
     * @example
     * // Create many InvoiceLineItems
     * const invoiceLineItem = await prisma.invoiceLineItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceLineItemCreateManyArgs>(args?: SelectSubset<T, InvoiceLineItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceLineItems and returns the data saved in the database.
     * @param {InvoiceLineItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceLineItems.
     * @example
     * // Create many InvoiceLineItems
     * const invoiceLineItem = await prisma.invoiceLineItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceLineItems and only return the `id`
     * const invoiceLineItemWithIdOnly = await prisma.invoiceLineItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceLineItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceLineItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceLineItem.
     * @param {InvoiceLineItemDeleteArgs} args - Arguments to delete one InvoiceLineItem.
     * @example
     * // Delete one InvoiceLineItem
     * const InvoiceLineItem = await prisma.invoiceLineItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceLineItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceLineItemDeleteArgs>(args: SelectSubset<T, InvoiceLineItemDeleteArgs<ExtArgs>>): Prisma__InvoiceLineItemClient<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceLineItem.
     * @param {InvoiceLineItemUpdateArgs} args - Arguments to update one InvoiceLineItem.
     * @example
     * // Update one InvoiceLineItem
     * const invoiceLineItem = await prisma.invoiceLineItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceLineItemUpdateArgs>(args: SelectSubset<T, InvoiceLineItemUpdateArgs<ExtArgs>>): Prisma__InvoiceLineItemClient<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceLineItems.
     * @param {InvoiceLineItemDeleteManyArgs} args - Arguments to filter InvoiceLineItems to delete.
     * @example
     * // Delete a few InvoiceLineItems
     * const { count } = await prisma.invoiceLineItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceLineItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceLineItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceLineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceLineItems
     * const invoiceLineItem = await prisma.invoiceLineItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceLineItemUpdateManyArgs>(args: SelectSubset<T, InvoiceLineItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceLineItems and returns the data updated in the database.
     * @param {InvoiceLineItemUpdateManyAndReturnArgs} args - Arguments to update many InvoiceLineItems.
     * @example
     * // Update many InvoiceLineItems
     * const invoiceLineItem = await prisma.invoiceLineItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceLineItems and only return the `id`
     * const invoiceLineItemWithIdOnly = await prisma.invoiceLineItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceLineItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceLineItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceLineItem.
     * @param {InvoiceLineItemUpsertArgs} args - Arguments to update or create a InvoiceLineItem.
     * @example
     * // Update or create a InvoiceLineItem
     * const invoiceLineItem = await prisma.invoiceLineItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceLineItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceLineItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceLineItemUpsertArgs>(args: SelectSubset<T, InvoiceLineItemUpsertArgs<ExtArgs>>): Prisma__InvoiceLineItemClient<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceLineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemCountArgs} args - Arguments to filter InvoiceLineItems to count.
     * @example
     * // Count the number of InvoiceLineItems
     * const count = await prisma.invoiceLineItem.count({
     *   where: {
     *     // ... the filter for the InvoiceLineItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceLineItemCountArgs>(
      args?: Subset<T, InvoiceLineItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceLineItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceLineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceLineItemAggregateArgs>(args: Subset<T, InvoiceLineItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceLineItemAggregateType<T>>

    /**
     * Group by InvoiceLineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceLineItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceLineItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceLineItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceLineItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceLineItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceLineItem model
   */
  readonly fields: InvoiceLineItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceLineItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceLineItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceLineItem model
   */
  interface InvoiceLineItemFieldRefs {
    readonly id: FieldRef<"InvoiceLineItem", 'String'>
    readonly invoiceId: FieldRef<"InvoiceLineItem", 'String'>
    readonly description: FieldRef<"InvoiceLineItem", 'String'>
    readonly quantity: FieldRef<"InvoiceLineItem", 'Int'>
    readonly unitPrice: FieldRef<"InvoiceLineItem", 'Int'>
    readonly totalPrice: FieldRef<"InvoiceLineItem", 'Int'>
    readonly createdAt: FieldRef<"InvoiceLineItem", 'DateTime'>
    readonly updatedAt: FieldRef<"InvoiceLineItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceLineItem findUnique
   */
  export type InvoiceLineItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLineItem to fetch.
     */
    where: InvoiceLineItemWhereUniqueInput
  }

  /**
   * InvoiceLineItem findUniqueOrThrow
   */
  export type InvoiceLineItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLineItem to fetch.
     */
    where: InvoiceLineItemWhereUniqueInput
  }

  /**
   * InvoiceLineItem findFirst
   */
  export type InvoiceLineItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLineItem to fetch.
     */
    where?: InvoiceLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLineItems to fetch.
     */
    orderBy?: InvoiceLineItemOrderByWithRelationInput | InvoiceLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLineItems.
     */
    cursor?: InvoiceLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLineItems.
     */
    distinct?: InvoiceLineItemScalarFieldEnum | InvoiceLineItemScalarFieldEnum[]
  }

  /**
   * InvoiceLineItem findFirstOrThrow
   */
  export type InvoiceLineItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLineItem to fetch.
     */
    where?: InvoiceLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLineItems to fetch.
     */
    orderBy?: InvoiceLineItemOrderByWithRelationInput | InvoiceLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLineItems.
     */
    cursor?: InvoiceLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLineItems.
     */
    distinct?: InvoiceLineItemScalarFieldEnum | InvoiceLineItemScalarFieldEnum[]
  }

  /**
   * InvoiceLineItem findMany
   */
  export type InvoiceLineItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLineItems to fetch.
     */
    where?: InvoiceLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLineItems to fetch.
     */
    orderBy?: InvoiceLineItemOrderByWithRelationInput | InvoiceLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceLineItems.
     */
    cursor?: InvoiceLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLineItems.
     */
    skip?: number
    distinct?: InvoiceLineItemScalarFieldEnum | InvoiceLineItemScalarFieldEnum[]
  }

  /**
   * InvoiceLineItem create
   */
  export type InvoiceLineItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceLineItem.
     */
    data: XOR<InvoiceLineItemCreateInput, InvoiceLineItemUncheckedCreateInput>
  }

  /**
   * InvoiceLineItem createMany
   */
  export type InvoiceLineItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceLineItems.
     */
    data: InvoiceLineItemCreateManyInput | InvoiceLineItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceLineItem createManyAndReturn
   */
  export type InvoiceLineItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceLineItems.
     */
    data: InvoiceLineItemCreateManyInput | InvoiceLineItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceLineItem update
   */
  export type InvoiceLineItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceLineItem.
     */
    data: XOR<InvoiceLineItemUpdateInput, InvoiceLineItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceLineItem to update.
     */
    where: InvoiceLineItemWhereUniqueInput
  }

  /**
   * InvoiceLineItem updateMany
   */
  export type InvoiceLineItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceLineItems.
     */
    data: XOR<InvoiceLineItemUpdateManyMutationInput, InvoiceLineItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceLineItems to update
     */
    where?: InvoiceLineItemWhereInput
    /**
     * Limit how many InvoiceLineItems to update.
     */
    limit?: number
  }

  /**
   * InvoiceLineItem updateManyAndReturn
   */
  export type InvoiceLineItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceLineItems.
     */
    data: XOR<InvoiceLineItemUpdateManyMutationInput, InvoiceLineItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceLineItems to update
     */
    where?: InvoiceLineItemWhereInput
    /**
     * Limit how many InvoiceLineItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceLineItem upsert
   */
  export type InvoiceLineItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceLineItem to update in case it exists.
     */
    where: InvoiceLineItemWhereUniqueInput
    /**
     * In case the InvoiceLineItem found by the `where` argument doesn't exist, create a new InvoiceLineItem with this data.
     */
    create: XOR<InvoiceLineItemCreateInput, InvoiceLineItemUncheckedCreateInput>
    /**
     * In case the InvoiceLineItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceLineItemUpdateInput, InvoiceLineItemUncheckedUpdateInput>
  }

  /**
   * InvoiceLineItem delete
   */
  export type InvoiceLineItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceLineItem to delete.
     */
    where: InvoiceLineItemWhereUniqueInput
  }

  /**
   * InvoiceLineItem deleteMany
   */
  export type InvoiceLineItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLineItems to delete
     */
    where?: InvoiceLineItemWhereInput
    /**
     * Limit how many InvoiceLineItems to delete.
     */
    limit?: number
  }

  /**
   * InvoiceLineItem without action
   */
  export type InvoiceLineItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
  }


  /**
   * Model AIConversation
   */

  export type AggregateAIConversation = {
    _count: AIConversationCountAggregateOutputType | null
    _avg: AIConversationAvgAggregateOutputType | null
    _sum: AIConversationSumAggregateOutputType | null
    _min: AIConversationMinAggregateOutputType | null
    _max: AIConversationMaxAggregateOutputType | null
  }

  export type AIConversationAvgAggregateOutputType = {
    tokensUsed: number | null
    costUsd: Decimal | null
  }

  export type AIConversationSumAggregateOutputType = {
    tokensUsed: number | null
    costUsd: Decimal | null
  }

  export type AIConversationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    provider: string | null
    model: string | null
    tokensUsed: number | null
    costUsd: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIConversationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    provider: string | null
    model: string | null
    tokensUsed: number | null
    costUsd: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIConversationCountAggregateOutputType = {
    id: number
    userId: number
    sessionId: number
    provider: number
    model: number
    messages: number
    context: number
    tokensUsed: number
    costUsd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIConversationAvgAggregateInputType = {
    tokensUsed?: true
    costUsd?: true
  }

  export type AIConversationSumAggregateInputType = {
    tokensUsed?: true
    costUsd?: true
  }

  export type AIConversationMinAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    provider?: true
    model?: true
    tokensUsed?: true
    costUsd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIConversationMaxAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    provider?: true
    model?: true
    tokensUsed?: true
    costUsd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIConversationCountAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    provider?: true
    model?: true
    messages?: true
    context?: true
    tokensUsed?: true
    costUsd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIConversation to aggregate.
     */
    where?: AIConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIConversations to fetch.
     */
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIConversations
    **/
    _count?: true | AIConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIConversationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIConversationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIConversationMaxAggregateInputType
  }

  export type GetAIConversationAggregateType<T extends AIConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateAIConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIConversation[P]>
      : GetScalarType<T[P], AggregateAIConversation[P]>
  }




  export type AIConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIConversationWhereInput
    orderBy?: AIConversationOrderByWithAggregationInput | AIConversationOrderByWithAggregationInput[]
    by: AIConversationScalarFieldEnum[] | AIConversationScalarFieldEnum
    having?: AIConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIConversationCountAggregateInputType | true
    _avg?: AIConversationAvgAggregateInputType
    _sum?: AIConversationSumAggregateInputType
    _min?: AIConversationMinAggregateInputType
    _max?: AIConversationMaxAggregateInputType
  }

  export type AIConversationGroupByOutputType = {
    id: string
    userId: string
    sessionId: string
    provider: string
    model: string
    messages: JsonValue
    context: JsonValue | null
    tokensUsed: number
    costUsd: Decimal
    createdAt: Date
    updatedAt: Date
    _count: AIConversationCountAggregateOutputType | null
    _avg: AIConversationAvgAggregateOutputType | null
    _sum: AIConversationSumAggregateOutputType | null
    _min: AIConversationMinAggregateOutputType | null
    _max: AIConversationMaxAggregateOutputType | null
  }

  type GetAIConversationGroupByPayload<T extends AIConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIConversationGroupByOutputType[P]>
            : GetScalarType<T[P], AIConversationGroupByOutputType[P]>
        }
      >
    >


  export type AIConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    provider?: boolean
    model?: boolean
    messages?: boolean
    context?: boolean
    tokensUsed?: boolean
    costUsd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIConversation"]>

  export type AIConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    provider?: boolean
    model?: boolean
    messages?: boolean
    context?: boolean
    tokensUsed?: boolean
    costUsd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIConversation"]>

  export type AIConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    provider?: boolean
    model?: boolean
    messages?: boolean
    context?: boolean
    tokensUsed?: boolean
    costUsd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIConversation"]>

  export type AIConversationSelectScalar = {
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    provider?: boolean
    model?: boolean
    messages?: boolean
    context?: boolean
    tokensUsed?: boolean
    costUsd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "sessionId" | "provider" | "model" | "messages" | "context" | "tokensUsed" | "costUsd" | "createdAt" | "updatedAt", ExtArgs["result"]["aIConversation"]>
  export type AIConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AIConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AIConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AIConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIConversation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      sessionId: string
      provider: string
      model: string
      messages: Prisma.JsonValue
      context: Prisma.JsonValue | null
      tokensUsed: number
      costUsd: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIConversation"]>
    composites: {}
  }

  type AIConversationGetPayload<S extends boolean | null | undefined | AIConversationDefaultArgs> = $Result.GetResult<Prisma.$AIConversationPayload, S>

  type AIConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIConversationCountAggregateInputType | true
    }

  export interface AIConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIConversation'], meta: { name: 'AIConversation' } }
    /**
     * Find zero or one AIConversation that matches the filter.
     * @param {AIConversationFindUniqueArgs} args - Arguments to find a AIConversation
     * @example
     * // Get one AIConversation
     * const aIConversation = await prisma.aIConversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIConversationFindUniqueArgs>(args: SelectSubset<T, AIConversationFindUniqueArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIConversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIConversationFindUniqueOrThrowArgs} args - Arguments to find a AIConversation
     * @example
     * // Get one AIConversation
     * const aIConversation = await prisma.aIConversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, AIConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIConversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationFindFirstArgs} args - Arguments to find a AIConversation
     * @example
     * // Get one AIConversation
     * const aIConversation = await prisma.aIConversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIConversationFindFirstArgs>(args?: SelectSubset<T, AIConversationFindFirstArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIConversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationFindFirstOrThrowArgs} args - Arguments to find a AIConversation
     * @example
     * // Get one AIConversation
     * const aIConversation = await prisma.aIConversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, AIConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIConversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIConversations
     * const aIConversations = await prisma.aIConversation.findMany()
     * 
     * // Get first 10 AIConversations
     * const aIConversations = await prisma.aIConversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIConversationWithIdOnly = await prisma.aIConversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIConversationFindManyArgs>(args?: SelectSubset<T, AIConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIConversation.
     * @param {AIConversationCreateArgs} args - Arguments to create a AIConversation.
     * @example
     * // Create one AIConversation
     * const AIConversation = await prisma.aIConversation.create({
     *   data: {
     *     // ... data to create a AIConversation
     *   }
     * })
     * 
     */
    create<T extends AIConversationCreateArgs>(args: SelectSubset<T, AIConversationCreateArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIConversations.
     * @param {AIConversationCreateManyArgs} args - Arguments to create many AIConversations.
     * @example
     * // Create many AIConversations
     * const aIConversation = await prisma.aIConversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIConversationCreateManyArgs>(args?: SelectSubset<T, AIConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIConversations and returns the data saved in the database.
     * @param {AIConversationCreateManyAndReturnArgs} args - Arguments to create many AIConversations.
     * @example
     * // Create many AIConversations
     * const aIConversation = await prisma.aIConversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIConversations and only return the `id`
     * const aIConversationWithIdOnly = await prisma.aIConversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, AIConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIConversation.
     * @param {AIConversationDeleteArgs} args - Arguments to delete one AIConversation.
     * @example
     * // Delete one AIConversation
     * const AIConversation = await prisma.aIConversation.delete({
     *   where: {
     *     // ... filter to delete one AIConversation
     *   }
     * })
     * 
     */
    delete<T extends AIConversationDeleteArgs>(args: SelectSubset<T, AIConversationDeleteArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIConversation.
     * @param {AIConversationUpdateArgs} args - Arguments to update one AIConversation.
     * @example
     * // Update one AIConversation
     * const aIConversation = await prisma.aIConversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIConversationUpdateArgs>(args: SelectSubset<T, AIConversationUpdateArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIConversations.
     * @param {AIConversationDeleteManyArgs} args - Arguments to filter AIConversations to delete.
     * @example
     * // Delete a few AIConversations
     * const { count } = await prisma.aIConversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIConversationDeleteManyArgs>(args?: SelectSubset<T, AIConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIConversations
     * const aIConversation = await prisma.aIConversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIConversationUpdateManyArgs>(args: SelectSubset<T, AIConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIConversations and returns the data updated in the database.
     * @param {AIConversationUpdateManyAndReturnArgs} args - Arguments to update many AIConversations.
     * @example
     * // Update many AIConversations
     * const aIConversation = await prisma.aIConversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIConversations and only return the `id`
     * const aIConversationWithIdOnly = await prisma.aIConversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, AIConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIConversation.
     * @param {AIConversationUpsertArgs} args - Arguments to update or create a AIConversation.
     * @example
     * // Update or create a AIConversation
     * const aIConversation = await prisma.aIConversation.upsert({
     *   create: {
     *     // ... data to create a AIConversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIConversation we want to update
     *   }
     * })
     */
    upsert<T extends AIConversationUpsertArgs>(args: SelectSubset<T, AIConversationUpsertArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationCountArgs} args - Arguments to filter AIConversations to count.
     * @example
     * // Count the number of AIConversations
     * const count = await prisma.aIConversation.count({
     *   where: {
     *     // ... the filter for the AIConversations we want to count
     *   }
     * })
    **/
    count<T extends AIConversationCountArgs>(
      args?: Subset<T, AIConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIConversationAggregateArgs>(args: Subset<T, AIConversationAggregateArgs>): Prisma.PrismaPromise<GetAIConversationAggregateType<T>>

    /**
     * Group by AIConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIConversationGroupByArgs['orderBy'] }
        : { orderBy?: AIConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIConversation model
   */
  readonly fields: AIConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIConversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIConversation model
   */
  interface AIConversationFieldRefs {
    readonly id: FieldRef<"AIConversation", 'String'>
    readonly userId: FieldRef<"AIConversation", 'String'>
    readonly sessionId: FieldRef<"AIConversation", 'String'>
    readonly provider: FieldRef<"AIConversation", 'String'>
    readonly model: FieldRef<"AIConversation", 'String'>
    readonly messages: FieldRef<"AIConversation", 'Json'>
    readonly context: FieldRef<"AIConversation", 'Json'>
    readonly tokensUsed: FieldRef<"AIConversation", 'Int'>
    readonly costUsd: FieldRef<"AIConversation", 'Decimal'>
    readonly createdAt: FieldRef<"AIConversation", 'DateTime'>
    readonly updatedAt: FieldRef<"AIConversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIConversation findUnique
   */
  export type AIConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * Filter, which AIConversation to fetch.
     */
    where: AIConversationWhereUniqueInput
  }

  /**
   * AIConversation findUniqueOrThrow
   */
  export type AIConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * Filter, which AIConversation to fetch.
     */
    where: AIConversationWhereUniqueInput
  }

  /**
   * AIConversation findFirst
   */
  export type AIConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * Filter, which AIConversation to fetch.
     */
    where?: AIConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIConversations to fetch.
     */
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIConversations.
     */
    cursor?: AIConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIConversations.
     */
    distinct?: AIConversationScalarFieldEnum | AIConversationScalarFieldEnum[]
  }

  /**
   * AIConversation findFirstOrThrow
   */
  export type AIConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * Filter, which AIConversation to fetch.
     */
    where?: AIConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIConversations to fetch.
     */
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIConversations.
     */
    cursor?: AIConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIConversations.
     */
    distinct?: AIConversationScalarFieldEnum | AIConversationScalarFieldEnum[]
  }

  /**
   * AIConversation findMany
   */
  export type AIConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * Filter, which AIConversations to fetch.
     */
    where?: AIConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIConversations to fetch.
     */
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIConversations.
     */
    cursor?: AIConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIConversations.
     */
    skip?: number
    distinct?: AIConversationScalarFieldEnum | AIConversationScalarFieldEnum[]
  }

  /**
   * AIConversation create
   */
  export type AIConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a AIConversation.
     */
    data: XOR<AIConversationCreateInput, AIConversationUncheckedCreateInput>
  }

  /**
   * AIConversation createMany
   */
  export type AIConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIConversations.
     */
    data: AIConversationCreateManyInput | AIConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIConversation createManyAndReturn
   */
  export type AIConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * The data used to create many AIConversations.
     */
    data: AIConversationCreateManyInput | AIConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIConversation update
   */
  export type AIConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a AIConversation.
     */
    data: XOR<AIConversationUpdateInput, AIConversationUncheckedUpdateInput>
    /**
     * Choose, which AIConversation to update.
     */
    where: AIConversationWhereUniqueInput
  }

  /**
   * AIConversation updateMany
   */
  export type AIConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIConversations.
     */
    data: XOR<AIConversationUpdateManyMutationInput, AIConversationUncheckedUpdateManyInput>
    /**
     * Filter which AIConversations to update
     */
    where?: AIConversationWhereInput
    /**
     * Limit how many AIConversations to update.
     */
    limit?: number
  }

  /**
   * AIConversation updateManyAndReturn
   */
  export type AIConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * The data used to update AIConversations.
     */
    data: XOR<AIConversationUpdateManyMutationInput, AIConversationUncheckedUpdateManyInput>
    /**
     * Filter which AIConversations to update
     */
    where?: AIConversationWhereInput
    /**
     * Limit how many AIConversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIConversation upsert
   */
  export type AIConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the AIConversation to update in case it exists.
     */
    where: AIConversationWhereUniqueInput
    /**
     * In case the AIConversation found by the `where` argument doesn't exist, create a new AIConversation with this data.
     */
    create: XOR<AIConversationCreateInput, AIConversationUncheckedCreateInput>
    /**
     * In case the AIConversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIConversationUpdateInput, AIConversationUncheckedUpdateInput>
  }

  /**
   * AIConversation delete
   */
  export type AIConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * Filter which AIConversation to delete.
     */
    where: AIConversationWhereUniqueInput
  }

  /**
   * AIConversation deleteMany
   */
  export type AIConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIConversations to delete
     */
    where?: AIConversationWhereInput
    /**
     * Limit how many AIConversations to delete.
     */
    limit?: number
  }

  /**
   * AIConversation without action
   */
  export type AIConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
  }


  /**
   * Model AIInsight
   */

  export type AggregateAIInsight = {
    _count: AIInsightCountAggregateOutputType | null
    _avg: AIInsightAvgAggregateOutputType | null
    _sum: AIInsightSumAggregateOutputType | null
    _min: AIInsightMinAggregateOutputType | null
    _max: AIInsightMaxAggregateOutputType | null
  }

  export type AIInsightAvgAggregateOutputType = {
    confidenceScore: Decimal | null
  }

  export type AIInsightSumAggregateOutputType = {
    confidenceScore: Decimal | null
  }

  export type AIInsightMinAggregateOutputType = {
    id: string | null
    userId: string | null
    insightType: string | null
    category: string | null
    confidenceScore: Decimal | null
    provider: string | null
    model: string | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type AIInsightMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    insightType: string | null
    category: string | null
    confidenceScore: Decimal | null
    provider: string | null
    model: string | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type AIInsightCountAggregateOutputType = {
    id: number
    userId: number
    insightType: number
    category: number
    content: number
    confidenceScore: number
    sourceDataIds: number
    provider: number
    model: number
    isActive: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type AIInsightAvgAggregateInputType = {
    confidenceScore?: true
  }

  export type AIInsightSumAggregateInputType = {
    confidenceScore?: true
  }

  export type AIInsightMinAggregateInputType = {
    id?: true
    userId?: true
    insightType?: true
    category?: true
    confidenceScore?: true
    provider?: true
    model?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
  }

  export type AIInsightMaxAggregateInputType = {
    id?: true
    userId?: true
    insightType?: true
    category?: true
    confidenceScore?: true
    provider?: true
    model?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
  }

  export type AIInsightCountAggregateInputType = {
    id?: true
    userId?: true
    insightType?: true
    category?: true
    content?: true
    confidenceScore?: true
    sourceDataIds?: true
    provider?: true
    model?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type AIInsightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIInsight to aggregate.
     */
    where?: AIInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIInsights to fetch.
     */
    orderBy?: AIInsightOrderByWithRelationInput | AIInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIInsights
    **/
    _count?: true | AIInsightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIInsightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIInsightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIInsightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIInsightMaxAggregateInputType
  }

  export type GetAIInsightAggregateType<T extends AIInsightAggregateArgs> = {
        [P in keyof T & keyof AggregateAIInsight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIInsight[P]>
      : GetScalarType<T[P], AggregateAIInsight[P]>
  }




  export type AIInsightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIInsightWhereInput
    orderBy?: AIInsightOrderByWithAggregationInput | AIInsightOrderByWithAggregationInput[]
    by: AIInsightScalarFieldEnum[] | AIInsightScalarFieldEnum
    having?: AIInsightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIInsightCountAggregateInputType | true
    _avg?: AIInsightAvgAggregateInputType
    _sum?: AIInsightSumAggregateInputType
    _min?: AIInsightMinAggregateInputType
    _max?: AIInsightMaxAggregateInputType
  }

  export type AIInsightGroupByOutputType = {
    id: string
    userId: string
    insightType: string
    category: string
    content: JsonValue
    confidenceScore: Decimal | null
    sourceDataIds: string[]
    provider: string
    model: string
    isActive: boolean
    expiresAt: Date | null
    createdAt: Date
    _count: AIInsightCountAggregateOutputType | null
    _avg: AIInsightAvgAggregateOutputType | null
    _sum: AIInsightSumAggregateOutputType | null
    _min: AIInsightMinAggregateOutputType | null
    _max: AIInsightMaxAggregateOutputType | null
  }

  type GetAIInsightGroupByPayload<T extends AIInsightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIInsightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIInsightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIInsightGroupByOutputType[P]>
            : GetScalarType<T[P], AIInsightGroupByOutputType[P]>
        }
      >
    >


  export type AIInsightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    insightType?: boolean
    category?: boolean
    content?: boolean
    confidenceScore?: boolean
    sourceDataIds?: boolean
    provider?: boolean
    model?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIInsight"]>

  export type AIInsightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    insightType?: boolean
    category?: boolean
    content?: boolean
    confidenceScore?: boolean
    sourceDataIds?: boolean
    provider?: boolean
    model?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIInsight"]>

  export type AIInsightSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    insightType?: boolean
    category?: boolean
    content?: boolean
    confidenceScore?: boolean
    sourceDataIds?: boolean
    provider?: boolean
    model?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIInsight"]>

  export type AIInsightSelectScalar = {
    id?: boolean
    userId?: boolean
    insightType?: boolean
    category?: boolean
    content?: boolean
    confidenceScore?: boolean
    sourceDataIds?: boolean
    provider?: boolean
    model?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type AIInsightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "insightType" | "category" | "content" | "confidenceScore" | "sourceDataIds" | "provider" | "model" | "isActive" | "expiresAt" | "createdAt", ExtArgs["result"]["aIInsight"]>
  export type AIInsightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AIInsightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AIInsightIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AIInsightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIInsight"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      insightType: string
      category: string
      content: Prisma.JsonValue
      confidenceScore: Prisma.Decimal | null
      sourceDataIds: string[]
      provider: string
      model: string
      isActive: boolean
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["aIInsight"]>
    composites: {}
  }

  type AIInsightGetPayload<S extends boolean | null | undefined | AIInsightDefaultArgs> = $Result.GetResult<Prisma.$AIInsightPayload, S>

  type AIInsightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIInsightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIInsightCountAggregateInputType | true
    }

  export interface AIInsightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIInsight'], meta: { name: 'AIInsight' } }
    /**
     * Find zero or one AIInsight that matches the filter.
     * @param {AIInsightFindUniqueArgs} args - Arguments to find a AIInsight
     * @example
     * // Get one AIInsight
     * const aIInsight = await prisma.aIInsight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIInsightFindUniqueArgs>(args: SelectSubset<T, AIInsightFindUniqueArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIInsight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIInsightFindUniqueOrThrowArgs} args - Arguments to find a AIInsight
     * @example
     * // Get one AIInsight
     * const aIInsight = await prisma.aIInsight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIInsightFindUniqueOrThrowArgs>(args: SelectSubset<T, AIInsightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIInsight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightFindFirstArgs} args - Arguments to find a AIInsight
     * @example
     * // Get one AIInsight
     * const aIInsight = await prisma.aIInsight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIInsightFindFirstArgs>(args?: SelectSubset<T, AIInsightFindFirstArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIInsight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightFindFirstOrThrowArgs} args - Arguments to find a AIInsight
     * @example
     * // Get one AIInsight
     * const aIInsight = await prisma.aIInsight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIInsightFindFirstOrThrowArgs>(args?: SelectSubset<T, AIInsightFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIInsights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIInsights
     * const aIInsights = await prisma.aIInsight.findMany()
     * 
     * // Get first 10 AIInsights
     * const aIInsights = await prisma.aIInsight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIInsightWithIdOnly = await prisma.aIInsight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIInsightFindManyArgs>(args?: SelectSubset<T, AIInsightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIInsight.
     * @param {AIInsightCreateArgs} args - Arguments to create a AIInsight.
     * @example
     * // Create one AIInsight
     * const AIInsight = await prisma.aIInsight.create({
     *   data: {
     *     // ... data to create a AIInsight
     *   }
     * })
     * 
     */
    create<T extends AIInsightCreateArgs>(args: SelectSubset<T, AIInsightCreateArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIInsights.
     * @param {AIInsightCreateManyArgs} args - Arguments to create many AIInsights.
     * @example
     * // Create many AIInsights
     * const aIInsight = await prisma.aIInsight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIInsightCreateManyArgs>(args?: SelectSubset<T, AIInsightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIInsights and returns the data saved in the database.
     * @param {AIInsightCreateManyAndReturnArgs} args - Arguments to create many AIInsights.
     * @example
     * // Create many AIInsights
     * const aIInsight = await prisma.aIInsight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIInsights and only return the `id`
     * const aIInsightWithIdOnly = await prisma.aIInsight.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIInsightCreateManyAndReturnArgs>(args?: SelectSubset<T, AIInsightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIInsight.
     * @param {AIInsightDeleteArgs} args - Arguments to delete one AIInsight.
     * @example
     * // Delete one AIInsight
     * const AIInsight = await prisma.aIInsight.delete({
     *   where: {
     *     // ... filter to delete one AIInsight
     *   }
     * })
     * 
     */
    delete<T extends AIInsightDeleteArgs>(args: SelectSubset<T, AIInsightDeleteArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIInsight.
     * @param {AIInsightUpdateArgs} args - Arguments to update one AIInsight.
     * @example
     * // Update one AIInsight
     * const aIInsight = await prisma.aIInsight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIInsightUpdateArgs>(args: SelectSubset<T, AIInsightUpdateArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIInsights.
     * @param {AIInsightDeleteManyArgs} args - Arguments to filter AIInsights to delete.
     * @example
     * // Delete a few AIInsights
     * const { count } = await prisma.aIInsight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIInsightDeleteManyArgs>(args?: SelectSubset<T, AIInsightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIInsights
     * const aIInsight = await prisma.aIInsight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIInsightUpdateManyArgs>(args: SelectSubset<T, AIInsightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIInsights and returns the data updated in the database.
     * @param {AIInsightUpdateManyAndReturnArgs} args - Arguments to update many AIInsights.
     * @example
     * // Update many AIInsights
     * const aIInsight = await prisma.aIInsight.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIInsights and only return the `id`
     * const aIInsightWithIdOnly = await prisma.aIInsight.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIInsightUpdateManyAndReturnArgs>(args: SelectSubset<T, AIInsightUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIInsight.
     * @param {AIInsightUpsertArgs} args - Arguments to update or create a AIInsight.
     * @example
     * // Update or create a AIInsight
     * const aIInsight = await prisma.aIInsight.upsert({
     *   create: {
     *     // ... data to create a AIInsight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIInsight we want to update
     *   }
     * })
     */
    upsert<T extends AIInsightUpsertArgs>(args: SelectSubset<T, AIInsightUpsertArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightCountArgs} args - Arguments to filter AIInsights to count.
     * @example
     * // Count the number of AIInsights
     * const count = await prisma.aIInsight.count({
     *   where: {
     *     // ... the filter for the AIInsights we want to count
     *   }
     * })
    **/
    count<T extends AIInsightCountArgs>(
      args?: Subset<T, AIInsightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIInsightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIInsightAggregateArgs>(args: Subset<T, AIInsightAggregateArgs>): Prisma.PrismaPromise<GetAIInsightAggregateType<T>>

    /**
     * Group by AIInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIInsightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIInsightGroupByArgs['orderBy'] }
        : { orderBy?: AIInsightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIInsightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIInsightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIInsight model
   */
  readonly fields: AIInsightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIInsight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIInsightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIInsight model
   */
  interface AIInsightFieldRefs {
    readonly id: FieldRef<"AIInsight", 'String'>
    readonly userId: FieldRef<"AIInsight", 'String'>
    readonly insightType: FieldRef<"AIInsight", 'String'>
    readonly category: FieldRef<"AIInsight", 'String'>
    readonly content: FieldRef<"AIInsight", 'Json'>
    readonly confidenceScore: FieldRef<"AIInsight", 'Decimal'>
    readonly sourceDataIds: FieldRef<"AIInsight", 'String[]'>
    readonly provider: FieldRef<"AIInsight", 'String'>
    readonly model: FieldRef<"AIInsight", 'String'>
    readonly isActive: FieldRef<"AIInsight", 'Boolean'>
    readonly expiresAt: FieldRef<"AIInsight", 'DateTime'>
    readonly createdAt: FieldRef<"AIInsight", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIInsight findUnique
   */
  export type AIInsightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    /**
     * Filter, which AIInsight to fetch.
     */
    where: AIInsightWhereUniqueInput
  }

  /**
   * AIInsight findUniqueOrThrow
   */
  export type AIInsightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    /**
     * Filter, which AIInsight to fetch.
     */
    where: AIInsightWhereUniqueInput
  }

  /**
   * AIInsight findFirst
   */
  export type AIInsightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    /**
     * Filter, which AIInsight to fetch.
     */
    where?: AIInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIInsights to fetch.
     */
    orderBy?: AIInsightOrderByWithRelationInput | AIInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIInsights.
     */
    cursor?: AIInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIInsights.
     */
    distinct?: AIInsightScalarFieldEnum | AIInsightScalarFieldEnum[]
  }

  /**
   * AIInsight findFirstOrThrow
   */
  export type AIInsightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    /**
     * Filter, which AIInsight to fetch.
     */
    where?: AIInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIInsights to fetch.
     */
    orderBy?: AIInsightOrderByWithRelationInput | AIInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIInsights.
     */
    cursor?: AIInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIInsights.
     */
    distinct?: AIInsightScalarFieldEnum | AIInsightScalarFieldEnum[]
  }

  /**
   * AIInsight findMany
   */
  export type AIInsightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    /**
     * Filter, which AIInsights to fetch.
     */
    where?: AIInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIInsights to fetch.
     */
    orderBy?: AIInsightOrderByWithRelationInput | AIInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIInsights.
     */
    cursor?: AIInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIInsights.
     */
    skip?: number
    distinct?: AIInsightScalarFieldEnum | AIInsightScalarFieldEnum[]
  }

  /**
   * AIInsight create
   */
  export type AIInsightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    /**
     * The data needed to create a AIInsight.
     */
    data: XOR<AIInsightCreateInput, AIInsightUncheckedCreateInput>
  }

  /**
   * AIInsight createMany
   */
  export type AIInsightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIInsights.
     */
    data: AIInsightCreateManyInput | AIInsightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIInsight createManyAndReturn
   */
  export type AIInsightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * The data used to create many AIInsights.
     */
    data: AIInsightCreateManyInput | AIInsightCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIInsight update
   */
  export type AIInsightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    /**
     * The data needed to update a AIInsight.
     */
    data: XOR<AIInsightUpdateInput, AIInsightUncheckedUpdateInput>
    /**
     * Choose, which AIInsight to update.
     */
    where: AIInsightWhereUniqueInput
  }

  /**
   * AIInsight updateMany
   */
  export type AIInsightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIInsights.
     */
    data: XOR<AIInsightUpdateManyMutationInput, AIInsightUncheckedUpdateManyInput>
    /**
     * Filter which AIInsights to update
     */
    where?: AIInsightWhereInput
    /**
     * Limit how many AIInsights to update.
     */
    limit?: number
  }

  /**
   * AIInsight updateManyAndReturn
   */
  export type AIInsightUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * The data used to update AIInsights.
     */
    data: XOR<AIInsightUpdateManyMutationInput, AIInsightUncheckedUpdateManyInput>
    /**
     * Filter which AIInsights to update
     */
    where?: AIInsightWhereInput
    /**
     * Limit how many AIInsights to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIInsight upsert
   */
  export type AIInsightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    /**
     * The filter to search for the AIInsight to update in case it exists.
     */
    where: AIInsightWhereUniqueInput
    /**
     * In case the AIInsight found by the `where` argument doesn't exist, create a new AIInsight with this data.
     */
    create: XOR<AIInsightCreateInput, AIInsightUncheckedCreateInput>
    /**
     * In case the AIInsight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIInsightUpdateInput, AIInsightUncheckedUpdateInput>
  }

  /**
   * AIInsight delete
   */
  export type AIInsightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    /**
     * Filter which AIInsight to delete.
     */
    where: AIInsightWhereUniqueInput
  }

  /**
   * AIInsight deleteMany
   */
  export type AIInsightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIInsights to delete
     */
    where?: AIInsightWhereInput
    /**
     * Limit how many AIInsights to delete.
     */
    limit?: number
  }

  /**
   * AIInsight without action
   */
  export type AIInsightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
  }


  /**
   * Model AIUsageTracking
   */

  export type AggregateAIUsageTracking = {
    _count: AIUsageTrackingCountAggregateOutputType | null
    _avg: AIUsageTrackingAvgAggregateOutputType | null
    _sum: AIUsageTrackingSumAggregateOutputType | null
    _min: AIUsageTrackingMinAggregateOutputType | null
    _max: AIUsageTrackingMaxAggregateOutputType | null
  }

  export type AIUsageTrackingAvgAggregateOutputType = {
    tokensInput: number | null
    tokensOutput: number | null
    costUsd: Decimal | null
    responseTimeMs: number | null
  }

  export type AIUsageTrackingSumAggregateOutputType = {
    tokensInput: number | null
    tokensOutput: number | null
    costUsd: Decimal | null
    responseTimeMs: number | null
  }

  export type AIUsageTrackingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    model: string | null
    operationType: string | null
    tokensInput: number | null
    tokensOutput: number | null
    costUsd: Decimal | null
    responseTimeMs: number | null
    success: boolean | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type AIUsageTrackingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    model: string | null
    operationType: string | null
    tokensInput: number | null
    tokensOutput: number | null
    costUsd: Decimal | null
    responseTimeMs: number | null
    success: boolean | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type AIUsageTrackingCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    model: number
    operationType: number
    tokensInput: number
    tokensOutput: number
    costUsd: number
    responseTimeMs: number
    success: number
    errorMessage: number
    createdAt: number
    _all: number
  }


  export type AIUsageTrackingAvgAggregateInputType = {
    tokensInput?: true
    tokensOutput?: true
    costUsd?: true
    responseTimeMs?: true
  }

  export type AIUsageTrackingSumAggregateInputType = {
    tokensInput?: true
    tokensOutput?: true
    costUsd?: true
    responseTimeMs?: true
  }

  export type AIUsageTrackingMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    model?: true
    operationType?: true
    tokensInput?: true
    tokensOutput?: true
    costUsd?: true
    responseTimeMs?: true
    success?: true
    errorMessage?: true
    createdAt?: true
  }

  export type AIUsageTrackingMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    model?: true
    operationType?: true
    tokensInput?: true
    tokensOutput?: true
    costUsd?: true
    responseTimeMs?: true
    success?: true
    errorMessage?: true
    createdAt?: true
  }

  export type AIUsageTrackingCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    model?: true
    operationType?: true
    tokensInput?: true
    tokensOutput?: true
    costUsd?: true
    responseTimeMs?: true
    success?: true
    errorMessage?: true
    createdAt?: true
    _all?: true
  }

  export type AIUsageTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIUsageTracking to aggregate.
     */
    where?: AIUsageTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageTrackings to fetch.
     */
    orderBy?: AIUsageTrackingOrderByWithRelationInput | AIUsageTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIUsageTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIUsageTrackings
    **/
    _count?: true | AIUsageTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIUsageTrackingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIUsageTrackingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIUsageTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIUsageTrackingMaxAggregateInputType
  }

  export type GetAIUsageTrackingAggregateType<T extends AIUsageTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateAIUsageTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIUsageTracking[P]>
      : GetScalarType<T[P], AggregateAIUsageTracking[P]>
  }




  export type AIUsageTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIUsageTrackingWhereInput
    orderBy?: AIUsageTrackingOrderByWithAggregationInput | AIUsageTrackingOrderByWithAggregationInput[]
    by: AIUsageTrackingScalarFieldEnum[] | AIUsageTrackingScalarFieldEnum
    having?: AIUsageTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIUsageTrackingCountAggregateInputType | true
    _avg?: AIUsageTrackingAvgAggregateInputType
    _sum?: AIUsageTrackingSumAggregateInputType
    _min?: AIUsageTrackingMinAggregateInputType
    _max?: AIUsageTrackingMaxAggregateInputType
  }

  export type AIUsageTrackingGroupByOutputType = {
    id: string
    userId: string
    provider: string
    model: string
    operationType: string
    tokensInput: number
    tokensOutput: number
    costUsd: Decimal
    responseTimeMs: number | null
    success: boolean
    errorMessage: string | null
    createdAt: Date
    _count: AIUsageTrackingCountAggregateOutputType | null
    _avg: AIUsageTrackingAvgAggregateOutputType | null
    _sum: AIUsageTrackingSumAggregateOutputType | null
    _min: AIUsageTrackingMinAggregateOutputType | null
    _max: AIUsageTrackingMaxAggregateOutputType | null
  }

  type GetAIUsageTrackingGroupByPayload<T extends AIUsageTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIUsageTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIUsageTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIUsageTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], AIUsageTrackingGroupByOutputType[P]>
        }
      >
    >


  export type AIUsageTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    model?: boolean
    operationType?: boolean
    tokensInput?: boolean
    tokensOutput?: boolean
    costUsd?: boolean
    responseTimeMs?: boolean
    success?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIUsageTracking"]>

  export type AIUsageTrackingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    model?: boolean
    operationType?: boolean
    tokensInput?: boolean
    tokensOutput?: boolean
    costUsd?: boolean
    responseTimeMs?: boolean
    success?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIUsageTracking"]>

  export type AIUsageTrackingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    model?: boolean
    operationType?: boolean
    tokensInput?: boolean
    tokensOutput?: boolean
    costUsd?: boolean
    responseTimeMs?: boolean
    success?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIUsageTracking"]>

  export type AIUsageTrackingSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    model?: boolean
    operationType?: boolean
    tokensInput?: boolean
    tokensOutput?: boolean
    costUsd?: boolean
    responseTimeMs?: boolean
    success?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }

  export type AIUsageTrackingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "provider" | "model" | "operationType" | "tokensInput" | "tokensOutput" | "costUsd" | "responseTimeMs" | "success" | "errorMessage" | "createdAt", ExtArgs["result"]["aIUsageTracking"]>
  export type AIUsageTrackingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AIUsageTrackingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AIUsageTrackingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AIUsageTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIUsageTracking"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      provider: string
      model: string
      operationType: string
      tokensInput: number
      tokensOutput: number
      costUsd: Prisma.Decimal
      responseTimeMs: number | null
      success: boolean
      errorMessage: string | null
      createdAt: Date
    }, ExtArgs["result"]["aIUsageTracking"]>
    composites: {}
  }

  type AIUsageTrackingGetPayload<S extends boolean | null | undefined | AIUsageTrackingDefaultArgs> = $Result.GetResult<Prisma.$AIUsageTrackingPayload, S>

  type AIUsageTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIUsageTrackingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIUsageTrackingCountAggregateInputType | true
    }

  export interface AIUsageTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIUsageTracking'], meta: { name: 'AIUsageTracking' } }
    /**
     * Find zero or one AIUsageTracking that matches the filter.
     * @param {AIUsageTrackingFindUniqueArgs} args - Arguments to find a AIUsageTracking
     * @example
     * // Get one AIUsageTracking
     * const aIUsageTracking = await prisma.aIUsageTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIUsageTrackingFindUniqueArgs>(args: SelectSubset<T, AIUsageTrackingFindUniqueArgs<ExtArgs>>): Prisma__AIUsageTrackingClient<$Result.GetResult<Prisma.$AIUsageTrackingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIUsageTracking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIUsageTrackingFindUniqueOrThrowArgs} args - Arguments to find a AIUsageTracking
     * @example
     * // Get one AIUsageTracking
     * const aIUsageTracking = await prisma.aIUsageTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIUsageTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, AIUsageTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIUsageTrackingClient<$Result.GetResult<Prisma.$AIUsageTrackingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIUsageTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageTrackingFindFirstArgs} args - Arguments to find a AIUsageTracking
     * @example
     * // Get one AIUsageTracking
     * const aIUsageTracking = await prisma.aIUsageTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIUsageTrackingFindFirstArgs>(args?: SelectSubset<T, AIUsageTrackingFindFirstArgs<ExtArgs>>): Prisma__AIUsageTrackingClient<$Result.GetResult<Prisma.$AIUsageTrackingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIUsageTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageTrackingFindFirstOrThrowArgs} args - Arguments to find a AIUsageTracking
     * @example
     * // Get one AIUsageTracking
     * const aIUsageTracking = await prisma.aIUsageTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIUsageTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, AIUsageTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIUsageTrackingClient<$Result.GetResult<Prisma.$AIUsageTrackingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIUsageTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIUsageTrackings
     * const aIUsageTrackings = await prisma.aIUsageTracking.findMany()
     * 
     * // Get first 10 AIUsageTrackings
     * const aIUsageTrackings = await prisma.aIUsageTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIUsageTrackingWithIdOnly = await prisma.aIUsageTracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIUsageTrackingFindManyArgs>(args?: SelectSubset<T, AIUsageTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIUsageTracking.
     * @param {AIUsageTrackingCreateArgs} args - Arguments to create a AIUsageTracking.
     * @example
     * // Create one AIUsageTracking
     * const AIUsageTracking = await prisma.aIUsageTracking.create({
     *   data: {
     *     // ... data to create a AIUsageTracking
     *   }
     * })
     * 
     */
    create<T extends AIUsageTrackingCreateArgs>(args: SelectSubset<T, AIUsageTrackingCreateArgs<ExtArgs>>): Prisma__AIUsageTrackingClient<$Result.GetResult<Prisma.$AIUsageTrackingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIUsageTrackings.
     * @param {AIUsageTrackingCreateManyArgs} args - Arguments to create many AIUsageTrackings.
     * @example
     * // Create many AIUsageTrackings
     * const aIUsageTracking = await prisma.aIUsageTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIUsageTrackingCreateManyArgs>(args?: SelectSubset<T, AIUsageTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIUsageTrackings and returns the data saved in the database.
     * @param {AIUsageTrackingCreateManyAndReturnArgs} args - Arguments to create many AIUsageTrackings.
     * @example
     * // Create many AIUsageTrackings
     * const aIUsageTracking = await prisma.aIUsageTracking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIUsageTrackings and only return the `id`
     * const aIUsageTrackingWithIdOnly = await prisma.aIUsageTracking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIUsageTrackingCreateManyAndReturnArgs>(args?: SelectSubset<T, AIUsageTrackingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageTrackingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIUsageTracking.
     * @param {AIUsageTrackingDeleteArgs} args - Arguments to delete one AIUsageTracking.
     * @example
     * // Delete one AIUsageTracking
     * const AIUsageTracking = await prisma.aIUsageTracking.delete({
     *   where: {
     *     // ... filter to delete one AIUsageTracking
     *   }
     * })
     * 
     */
    delete<T extends AIUsageTrackingDeleteArgs>(args: SelectSubset<T, AIUsageTrackingDeleteArgs<ExtArgs>>): Prisma__AIUsageTrackingClient<$Result.GetResult<Prisma.$AIUsageTrackingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIUsageTracking.
     * @param {AIUsageTrackingUpdateArgs} args - Arguments to update one AIUsageTracking.
     * @example
     * // Update one AIUsageTracking
     * const aIUsageTracking = await prisma.aIUsageTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIUsageTrackingUpdateArgs>(args: SelectSubset<T, AIUsageTrackingUpdateArgs<ExtArgs>>): Prisma__AIUsageTrackingClient<$Result.GetResult<Prisma.$AIUsageTrackingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIUsageTrackings.
     * @param {AIUsageTrackingDeleteManyArgs} args - Arguments to filter AIUsageTrackings to delete.
     * @example
     * // Delete a few AIUsageTrackings
     * const { count } = await prisma.aIUsageTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIUsageTrackingDeleteManyArgs>(args?: SelectSubset<T, AIUsageTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIUsageTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIUsageTrackings
     * const aIUsageTracking = await prisma.aIUsageTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIUsageTrackingUpdateManyArgs>(args: SelectSubset<T, AIUsageTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIUsageTrackings and returns the data updated in the database.
     * @param {AIUsageTrackingUpdateManyAndReturnArgs} args - Arguments to update many AIUsageTrackings.
     * @example
     * // Update many AIUsageTrackings
     * const aIUsageTracking = await prisma.aIUsageTracking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIUsageTrackings and only return the `id`
     * const aIUsageTrackingWithIdOnly = await prisma.aIUsageTracking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIUsageTrackingUpdateManyAndReturnArgs>(args: SelectSubset<T, AIUsageTrackingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageTrackingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIUsageTracking.
     * @param {AIUsageTrackingUpsertArgs} args - Arguments to update or create a AIUsageTracking.
     * @example
     * // Update or create a AIUsageTracking
     * const aIUsageTracking = await prisma.aIUsageTracking.upsert({
     *   create: {
     *     // ... data to create a AIUsageTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIUsageTracking we want to update
     *   }
     * })
     */
    upsert<T extends AIUsageTrackingUpsertArgs>(args: SelectSubset<T, AIUsageTrackingUpsertArgs<ExtArgs>>): Prisma__AIUsageTrackingClient<$Result.GetResult<Prisma.$AIUsageTrackingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIUsageTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageTrackingCountArgs} args - Arguments to filter AIUsageTrackings to count.
     * @example
     * // Count the number of AIUsageTrackings
     * const count = await prisma.aIUsageTracking.count({
     *   where: {
     *     // ... the filter for the AIUsageTrackings we want to count
     *   }
     * })
    **/
    count<T extends AIUsageTrackingCountArgs>(
      args?: Subset<T, AIUsageTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIUsageTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIUsageTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIUsageTrackingAggregateArgs>(args: Subset<T, AIUsageTrackingAggregateArgs>): Prisma.PrismaPromise<GetAIUsageTrackingAggregateType<T>>

    /**
     * Group by AIUsageTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIUsageTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIUsageTrackingGroupByArgs['orderBy'] }
        : { orderBy?: AIUsageTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIUsageTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIUsageTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIUsageTracking model
   */
  readonly fields: AIUsageTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIUsageTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIUsageTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIUsageTracking model
   */
  interface AIUsageTrackingFieldRefs {
    readonly id: FieldRef<"AIUsageTracking", 'String'>
    readonly userId: FieldRef<"AIUsageTracking", 'String'>
    readonly provider: FieldRef<"AIUsageTracking", 'String'>
    readonly model: FieldRef<"AIUsageTracking", 'String'>
    readonly operationType: FieldRef<"AIUsageTracking", 'String'>
    readonly tokensInput: FieldRef<"AIUsageTracking", 'Int'>
    readonly tokensOutput: FieldRef<"AIUsageTracking", 'Int'>
    readonly costUsd: FieldRef<"AIUsageTracking", 'Decimal'>
    readonly responseTimeMs: FieldRef<"AIUsageTracking", 'Int'>
    readonly success: FieldRef<"AIUsageTracking", 'Boolean'>
    readonly errorMessage: FieldRef<"AIUsageTracking", 'String'>
    readonly createdAt: FieldRef<"AIUsageTracking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIUsageTracking findUnique
   */
  export type AIUsageTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageTracking
     */
    select?: AIUsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageTracking
     */
    omit?: AIUsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageTrackingInclude<ExtArgs> | null
    /**
     * Filter, which AIUsageTracking to fetch.
     */
    where: AIUsageTrackingWhereUniqueInput
  }

  /**
   * AIUsageTracking findUniqueOrThrow
   */
  export type AIUsageTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageTracking
     */
    select?: AIUsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageTracking
     */
    omit?: AIUsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageTrackingInclude<ExtArgs> | null
    /**
     * Filter, which AIUsageTracking to fetch.
     */
    where: AIUsageTrackingWhereUniqueInput
  }

  /**
   * AIUsageTracking findFirst
   */
  export type AIUsageTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageTracking
     */
    select?: AIUsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageTracking
     */
    omit?: AIUsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageTrackingInclude<ExtArgs> | null
    /**
     * Filter, which AIUsageTracking to fetch.
     */
    where?: AIUsageTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageTrackings to fetch.
     */
    orderBy?: AIUsageTrackingOrderByWithRelationInput | AIUsageTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIUsageTrackings.
     */
    cursor?: AIUsageTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIUsageTrackings.
     */
    distinct?: AIUsageTrackingScalarFieldEnum | AIUsageTrackingScalarFieldEnum[]
  }

  /**
   * AIUsageTracking findFirstOrThrow
   */
  export type AIUsageTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageTracking
     */
    select?: AIUsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageTracking
     */
    omit?: AIUsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageTrackingInclude<ExtArgs> | null
    /**
     * Filter, which AIUsageTracking to fetch.
     */
    where?: AIUsageTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageTrackings to fetch.
     */
    orderBy?: AIUsageTrackingOrderByWithRelationInput | AIUsageTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIUsageTrackings.
     */
    cursor?: AIUsageTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIUsageTrackings.
     */
    distinct?: AIUsageTrackingScalarFieldEnum | AIUsageTrackingScalarFieldEnum[]
  }

  /**
   * AIUsageTracking findMany
   */
  export type AIUsageTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageTracking
     */
    select?: AIUsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageTracking
     */
    omit?: AIUsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageTrackingInclude<ExtArgs> | null
    /**
     * Filter, which AIUsageTrackings to fetch.
     */
    where?: AIUsageTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageTrackings to fetch.
     */
    orderBy?: AIUsageTrackingOrderByWithRelationInput | AIUsageTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIUsageTrackings.
     */
    cursor?: AIUsageTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageTrackings.
     */
    skip?: number
    distinct?: AIUsageTrackingScalarFieldEnum | AIUsageTrackingScalarFieldEnum[]
  }

  /**
   * AIUsageTracking create
   */
  export type AIUsageTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageTracking
     */
    select?: AIUsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageTracking
     */
    omit?: AIUsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageTrackingInclude<ExtArgs> | null
    /**
     * The data needed to create a AIUsageTracking.
     */
    data: XOR<AIUsageTrackingCreateInput, AIUsageTrackingUncheckedCreateInput>
  }

  /**
   * AIUsageTracking createMany
   */
  export type AIUsageTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIUsageTrackings.
     */
    data: AIUsageTrackingCreateManyInput | AIUsageTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIUsageTracking createManyAndReturn
   */
  export type AIUsageTrackingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageTracking
     */
    select?: AIUsageTrackingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageTracking
     */
    omit?: AIUsageTrackingOmit<ExtArgs> | null
    /**
     * The data used to create many AIUsageTrackings.
     */
    data: AIUsageTrackingCreateManyInput | AIUsageTrackingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageTrackingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIUsageTracking update
   */
  export type AIUsageTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageTracking
     */
    select?: AIUsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageTracking
     */
    omit?: AIUsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageTrackingInclude<ExtArgs> | null
    /**
     * The data needed to update a AIUsageTracking.
     */
    data: XOR<AIUsageTrackingUpdateInput, AIUsageTrackingUncheckedUpdateInput>
    /**
     * Choose, which AIUsageTracking to update.
     */
    where: AIUsageTrackingWhereUniqueInput
  }

  /**
   * AIUsageTracking updateMany
   */
  export type AIUsageTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIUsageTrackings.
     */
    data: XOR<AIUsageTrackingUpdateManyMutationInput, AIUsageTrackingUncheckedUpdateManyInput>
    /**
     * Filter which AIUsageTrackings to update
     */
    where?: AIUsageTrackingWhereInput
    /**
     * Limit how many AIUsageTrackings to update.
     */
    limit?: number
  }

  /**
   * AIUsageTracking updateManyAndReturn
   */
  export type AIUsageTrackingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageTracking
     */
    select?: AIUsageTrackingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageTracking
     */
    omit?: AIUsageTrackingOmit<ExtArgs> | null
    /**
     * The data used to update AIUsageTrackings.
     */
    data: XOR<AIUsageTrackingUpdateManyMutationInput, AIUsageTrackingUncheckedUpdateManyInput>
    /**
     * Filter which AIUsageTrackings to update
     */
    where?: AIUsageTrackingWhereInput
    /**
     * Limit how many AIUsageTrackings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageTrackingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIUsageTracking upsert
   */
  export type AIUsageTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageTracking
     */
    select?: AIUsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageTracking
     */
    omit?: AIUsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageTrackingInclude<ExtArgs> | null
    /**
     * The filter to search for the AIUsageTracking to update in case it exists.
     */
    where: AIUsageTrackingWhereUniqueInput
    /**
     * In case the AIUsageTracking found by the `where` argument doesn't exist, create a new AIUsageTracking with this data.
     */
    create: XOR<AIUsageTrackingCreateInput, AIUsageTrackingUncheckedCreateInput>
    /**
     * In case the AIUsageTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIUsageTrackingUpdateInput, AIUsageTrackingUncheckedUpdateInput>
  }

  /**
   * AIUsageTracking delete
   */
  export type AIUsageTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageTracking
     */
    select?: AIUsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageTracking
     */
    omit?: AIUsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageTrackingInclude<ExtArgs> | null
    /**
     * Filter which AIUsageTracking to delete.
     */
    where: AIUsageTrackingWhereUniqueInput
  }

  /**
   * AIUsageTracking deleteMany
   */
  export type AIUsageTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIUsageTrackings to delete
     */
    where?: AIUsageTrackingWhereInput
    /**
     * Limit how many AIUsageTrackings to delete.
     */
    limit?: number
  }

  /**
   * AIUsageTracking without action
   */
  export type AIUsageTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageTracking
     */
    select?: AIUsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageTracking
     */
    omit?: AIUsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageTrackingInclude<ExtArgs> | null
  }


  /**
   * Model AICache
   */

  export type AggregateAICache = {
    _count: AICacheCountAggregateOutputType | null
    _avg: AICacheAvgAggregateOutputType | null
    _sum: AICacheSumAggregateOutputType | null
    _min: AICacheMinAggregateOutputType | null
    _max: AICacheMaxAggregateOutputType | null
  }

  export type AICacheAvgAggregateOutputType = {
    hitCount: number | null
  }

  export type AICacheSumAggregateOutputType = {
    hitCount: number | null
  }

  export type AICacheMinAggregateOutputType = {
    id: string | null
    cacheKey: string | null
    operationType: string | null
    inputHash: string | null
    provider: string | null
    model: string | null
    hitCount: number | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type AICacheMaxAggregateOutputType = {
    id: string | null
    cacheKey: string | null
    operationType: string | null
    inputHash: string | null
    provider: string | null
    model: string | null
    hitCount: number | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type AICacheCountAggregateOutputType = {
    id: number
    cacheKey: number
    operationType: number
    inputHash: number
    response: number
    provider: number
    model: number
    hitCount: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type AICacheAvgAggregateInputType = {
    hitCount?: true
  }

  export type AICacheSumAggregateInputType = {
    hitCount?: true
  }

  export type AICacheMinAggregateInputType = {
    id?: true
    cacheKey?: true
    operationType?: true
    inputHash?: true
    provider?: true
    model?: true
    hitCount?: true
    expiresAt?: true
    createdAt?: true
  }

  export type AICacheMaxAggregateInputType = {
    id?: true
    cacheKey?: true
    operationType?: true
    inputHash?: true
    provider?: true
    model?: true
    hitCount?: true
    expiresAt?: true
    createdAt?: true
  }

  export type AICacheCountAggregateInputType = {
    id?: true
    cacheKey?: true
    operationType?: true
    inputHash?: true
    response?: true
    provider?: true
    model?: true
    hitCount?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type AICacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AICache to aggregate.
     */
    where?: AICacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AICaches to fetch.
     */
    orderBy?: AICacheOrderByWithRelationInput | AICacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AICacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AICaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AICaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AICaches
    **/
    _count?: true | AICacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AICacheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AICacheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AICacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AICacheMaxAggregateInputType
  }

  export type GetAICacheAggregateType<T extends AICacheAggregateArgs> = {
        [P in keyof T & keyof AggregateAICache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAICache[P]>
      : GetScalarType<T[P], AggregateAICache[P]>
  }




  export type AICacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AICacheWhereInput
    orderBy?: AICacheOrderByWithAggregationInput | AICacheOrderByWithAggregationInput[]
    by: AICacheScalarFieldEnum[] | AICacheScalarFieldEnum
    having?: AICacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AICacheCountAggregateInputType | true
    _avg?: AICacheAvgAggregateInputType
    _sum?: AICacheSumAggregateInputType
    _min?: AICacheMinAggregateInputType
    _max?: AICacheMaxAggregateInputType
  }

  export type AICacheGroupByOutputType = {
    id: string
    cacheKey: string
    operationType: string
    inputHash: string
    response: JsonValue
    provider: string
    model: string
    hitCount: number
    expiresAt: Date
    createdAt: Date
    _count: AICacheCountAggregateOutputType | null
    _avg: AICacheAvgAggregateOutputType | null
    _sum: AICacheSumAggregateOutputType | null
    _min: AICacheMinAggregateOutputType | null
    _max: AICacheMaxAggregateOutputType | null
  }

  type GetAICacheGroupByPayload<T extends AICacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AICacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AICacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AICacheGroupByOutputType[P]>
            : GetScalarType<T[P], AICacheGroupByOutputType[P]>
        }
      >
    >


  export type AICacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cacheKey?: boolean
    operationType?: boolean
    inputHash?: boolean
    response?: boolean
    provider?: boolean
    model?: boolean
    hitCount?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aICache"]>

  export type AICacheSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cacheKey?: boolean
    operationType?: boolean
    inputHash?: boolean
    response?: boolean
    provider?: boolean
    model?: boolean
    hitCount?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aICache"]>

  export type AICacheSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cacheKey?: boolean
    operationType?: boolean
    inputHash?: boolean
    response?: boolean
    provider?: boolean
    model?: boolean
    hitCount?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aICache"]>

  export type AICacheSelectScalar = {
    id?: boolean
    cacheKey?: boolean
    operationType?: boolean
    inputHash?: boolean
    response?: boolean
    provider?: boolean
    model?: boolean
    hitCount?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type AICacheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cacheKey" | "operationType" | "inputHash" | "response" | "provider" | "model" | "hitCount" | "expiresAt" | "createdAt", ExtArgs["result"]["aICache"]>

  export type $AICachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AICache"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cacheKey: string
      operationType: string
      inputHash: string
      response: Prisma.JsonValue
      provider: string
      model: string
      hitCount: number
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["aICache"]>
    composites: {}
  }

  type AICacheGetPayload<S extends boolean | null | undefined | AICacheDefaultArgs> = $Result.GetResult<Prisma.$AICachePayload, S>

  type AICacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AICacheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AICacheCountAggregateInputType | true
    }

  export interface AICacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AICache'], meta: { name: 'AICache' } }
    /**
     * Find zero or one AICache that matches the filter.
     * @param {AICacheFindUniqueArgs} args - Arguments to find a AICache
     * @example
     * // Get one AICache
     * const aICache = await prisma.aICache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AICacheFindUniqueArgs>(args: SelectSubset<T, AICacheFindUniqueArgs<ExtArgs>>): Prisma__AICacheClient<$Result.GetResult<Prisma.$AICachePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AICache that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AICacheFindUniqueOrThrowArgs} args - Arguments to find a AICache
     * @example
     * // Get one AICache
     * const aICache = await prisma.aICache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AICacheFindUniqueOrThrowArgs>(args: SelectSubset<T, AICacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AICacheClient<$Result.GetResult<Prisma.$AICachePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AICache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICacheFindFirstArgs} args - Arguments to find a AICache
     * @example
     * // Get one AICache
     * const aICache = await prisma.aICache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AICacheFindFirstArgs>(args?: SelectSubset<T, AICacheFindFirstArgs<ExtArgs>>): Prisma__AICacheClient<$Result.GetResult<Prisma.$AICachePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AICache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICacheFindFirstOrThrowArgs} args - Arguments to find a AICache
     * @example
     * // Get one AICache
     * const aICache = await prisma.aICache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AICacheFindFirstOrThrowArgs>(args?: SelectSubset<T, AICacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__AICacheClient<$Result.GetResult<Prisma.$AICachePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AICaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AICaches
     * const aICaches = await prisma.aICache.findMany()
     * 
     * // Get first 10 AICaches
     * const aICaches = await prisma.aICache.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aICacheWithIdOnly = await prisma.aICache.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AICacheFindManyArgs>(args?: SelectSubset<T, AICacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AICachePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AICache.
     * @param {AICacheCreateArgs} args - Arguments to create a AICache.
     * @example
     * // Create one AICache
     * const AICache = await prisma.aICache.create({
     *   data: {
     *     // ... data to create a AICache
     *   }
     * })
     * 
     */
    create<T extends AICacheCreateArgs>(args: SelectSubset<T, AICacheCreateArgs<ExtArgs>>): Prisma__AICacheClient<$Result.GetResult<Prisma.$AICachePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AICaches.
     * @param {AICacheCreateManyArgs} args - Arguments to create many AICaches.
     * @example
     * // Create many AICaches
     * const aICache = await prisma.aICache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AICacheCreateManyArgs>(args?: SelectSubset<T, AICacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AICaches and returns the data saved in the database.
     * @param {AICacheCreateManyAndReturnArgs} args - Arguments to create many AICaches.
     * @example
     * // Create many AICaches
     * const aICache = await prisma.aICache.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AICaches and only return the `id`
     * const aICacheWithIdOnly = await prisma.aICache.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AICacheCreateManyAndReturnArgs>(args?: SelectSubset<T, AICacheCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AICachePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AICache.
     * @param {AICacheDeleteArgs} args - Arguments to delete one AICache.
     * @example
     * // Delete one AICache
     * const AICache = await prisma.aICache.delete({
     *   where: {
     *     // ... filter to delete one AICache
     *   }
     * })
     * 
     */
    delete<T extends AICacheDeleteArgs>(args: SelectSubset<T, AICacheDeleteArgs<ExtArgs>>): Prisma__AICacheClient<$Result.GetResult<Prisma.$AICachePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AICache.
     * @param {AICacheUpdateArgs} args - Arguments to update one AICache.
     * @example
     * // Update one AICache
     * const aICache = await prisma.aICache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AICacheUpdateArgs>(args: SelectSubset<T, AICacheUpdateArgs<ExtArgs>>): Prisma__AICacheClient<$Result.GetResult<Prisma.$AICachePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AICaches.
     * @param {AICacheDeleteManyArgs} args - Arguments to filter AICaches to delete.
     * @example
     * // Delete a few AICaches
     * const { count } = await prisma.aICache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AICacheDeleteManyArgs>(args?: SelectSubset<T, AICacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AICaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AICaches
     * const aICache = await prisma.aICache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AICacheUpdateManyArgs>(args: SelectSubset<T, AICacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AICaches and returns the data updated in the database.
     * @param {AICacheUpdateManyAndReturnArgs} args - Arguments to update many AICaches.
     * @example
     * // Update many AICaches
     * const aICache = await prisma.aICache.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AICaches and only return the `id`
     * const aICacheWithIdOnly = await prisma.aICache.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AICacheUpdateManyAndReturnArgs>(args: SelectSubset<T, AICacheUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AICachePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AICache.
     * @param {AICacheUpsertArgs} args - Arguments to update or create a AICache.
     * @example
     * // Update or create a AICache
     * const aICache = await prisma.aICache.upsert({
     *   create: {
     *     // ... data to create a AICache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AICache we want to update
     *   }
     * })
     */
    upsert<T extends AICacheUpsertArgs>(args: SelectSubset<T, AICacheUpsertArgs<ExtArgs>>): Prisma__AICacheClient<$Result.GetResult<Prisma.$AICachePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AICaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICacheCountArgs} args - Arguments to filter AICaches to count.
     * @example
     * // Count the number of AICaches
     * const count = await prisma.aICache.count({
     *   where: {
     *     // ... the filter for the AICaches we want to count
     *   }
     * })
    **/
    count<T extends AICacheCountArgs>(
      args?: Subset<T, AICacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AICacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AICache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AICacheAggregateArgs>(args: Subset<T, AICacheAggregateArgs>): Prisma.PrismaPromise<GetAICacheAggregateType<T>>

    /**
     * Group by AICache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AICacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AICacheGroupByArgs['orderBy'] }
        : { orderBy?: AICacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AICacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAICacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AICache model
   */
  readonly fields: AICacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AICache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AICacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AICache model
   */
  interface AICacheFieldRefs {
    readonly id: FieldRef<"AICache", 'String'>
    readonly cacheKey: FieldRef<"AICache", 'String'>
    readonly operationType: FieldRef<"AICache", 'String'>
    readonly inputHash: FieldRef<"AICache", 'String'>
    readonly response: FieldRef<"AICache", 'Json'>
    readonly provider: FieldRef<"AICache", 'String'>
    readonly model: FieldRef<"AICache", 'String'>
    readonly hitCount: FieldRef<"AICache", 'Int'>
    readonly expiresAt: FieldRef<"AICache", 'DateTime'>
    readonly createdAt: FieldRef<"AICache", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AICache findUnique
   */
  export type AICacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICache
     */
    select?: AICacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICache
     */
    omit?: AICacheOmit<ExtArgs> | null
    /**
     * Filter, which AICache to fetch.
     */
    where: AICacheWhereUniqueInput
  }

  /**
   * AICache findUniqueOrThrow
   */
  export type AICacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICache
     */
    select?: AICacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICache
     */
    omit?: AICacheOmit<ExtArgs> | null
    /**
     * Filter, which AICache to fetch.
     */
    where: AICacheWhereUniqueInput
  }

  /**
   * AICache findFirst
   */
  export type AICacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICache
     */
    select?: AICacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICache
     */
    omit?: AICacheOmit<ExtArgs> | null
    /**
     * Filter, which AICache to fetch.
     */
    where?: AICacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AICaches to fetch.
     */
    orderBy?: AICacheOrderByWithRelationInput | AICacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AICaches.
     */
    cursor?: AICacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AICaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AICaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AICaches.
     */
    distinct?: AICacheScalarFieldEnum | AICacheScalarFieldEnum[]
  }

  /**
   * AICache findFirstOrThrow
   */
  export type AICacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICache
     */
    select?: AICacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICache
     */
    omit?: AICacheOmit<ExtArgs> | null
    /**
     * Filter, which AICache to fetch.
     */
    where?: AICacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AICaches to fetch.
     */
    orderBy?: AICacheOrderByWithRelationInput | AICacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AICaches.
     */
    cursor?: AICacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AICaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AICaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AICaches.
     */
    distinct?: AICacheScalarFieldEnum | AICacheScalarFieldEnum[]
  }

  /**
   * AICache findMany
   */
  export type AICacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICache
     */
    select?: AICacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICache
     */
    omit?: AICacheOmit<ExtArgs> | null
    /**
     * Filter, which AICaches to fetch.
     */
    where?: AICacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AICaches to fetch.
     */
    orderBy?: AICacheOrderByWithRelationInput | AICacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AICaches.
     */
    cursor?: AICacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AICaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AICaches.
     */
    skip?: number
    distinct?: AICacheScalarFieldEnum | AICacheScalarFieldEnum[]
  }

  /**
   * AICache create
   */
  export type AICacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICache
     */
    select?: AICacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICache
     */
    omit?: AICacheOmit<ExtArgs> | null
    /**
     * The data needed to create a AICache.
     */
    data: XOR<AICacheCreateInput, AICacheUncheckedCreateInput>
  }

  /**
   * AICache createMany
   */
  export type AICacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AICaches.
     */
    data: AICacheCreateManyInput | AICacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AICache createManyAndReturn
   */
  export type AICacheCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICache
     */
    select?: AICacheSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AICache
     */
    omit?: AICacheOmit<ExtArgs> | null
    /**
     * The data used to create many AICaches.
     */
    data: AICacheCreateManyInput | AICacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AICache update
   */
  export type AICacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICache
     */
    select?: AICacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICache
     */
    omit?: AICacheOmit<ExtArgs> | null
    /**
     * The data needed to update a AICache.
     */
    data: XOR<AICacheUpdateInput, AICacheUncheckedUpdateInput>
    /**
     * Choose, which AICache to update.
     */
    where: AICacheWhereUniqueInput
  }

  /**
   * AICache updateMany
   */
  export type AICacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AICaches.
     */
    data: XOR<AICacheUpdateManyMutationInput, AICacheUncheckedUpdateManyInput>
    /**
     * Filter which AICaches to update
     */
    where?: AICacheWhereInput
    /**
     * Limit how many AICaches to update.
     */
    limit?: number
  }

  /**
   * AICache updateManyAndReturn
   */
  export type AICacheUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICache
     */
    select?: AICacheSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AICache
     */
    omit?: AICacheOmit<ExtArgs> | null
    /**
     * The data used to update AICaches.
     */
    data: XOR<AICacheUpdateManyMutationInput, AICacheUncheckedUpdateManyInput>
    /**
     * Filter which AICaches to update
     */
    where?: AICacheWhereInput
    /**
     * Limit how many AICaches to update.
     */
    limit?: number
  }

  /**
   * AICache upsert
   */
  export type AICacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICache
     */
    select?: AICacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICache
     */
    omit?: AICacheOmit<ExtArgs> | null
    /**
     * The filter to search for the AICache to update in case it exists.
     */
    where: AICacheWhereUniqueInput
    /**
     * In case the AICache found by the `where` argument doesn't exist, create a new AICache with this data.
     */
    create: XOR<AICacheCreateInput, AICacheUncheckedCreateInput>
    /**
     * In case the AICache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AICacheUpdateInput, AICacheUncheckedUpdateInput>
  }

  /**
   * AICache delete
   */
  export type AICacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICache
     */
    select?: AICacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICache
     */
    omit?: AICacheOmit<ExtArgs> | null
    /**
     * Filter which AICache to delete.
     */
    where: AICacheWhereUniqueInput
  }

  /**
   * AICache deleteMany
   */
  export type AICacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AICaches to delete
     */
    where?: AICacheWhereInput
    /**
     * Limit how many AICaches to delete.
     */
    limit?: number
  }

  /**
   * AICache without action
   */
  export type AICacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICache
     */
    select?: AICacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICache
     */
    omit?: AICacheOmit<ExtArgs> | null
  }


  /**
   * Model AIProviderHealth
   */

  export type AggregateAIProviderHealth = {
    _count: AIProviderHealthCountAggregateOutputType | null
    _avg: AIProviderHealthAvgAggregateOutputType | null
    _sum: AIProviderHealthSumAggregateOutputType | null
    _min: AIProviderHealthMinAggregateOutputType | null
    _max: AIProviderHealthMaxAggregateOutputType | null
  }

  export type AIProviderHealthAvgAggregateOutputType = {
    consecutiveFailures: number | null
  }

  export type AIProviderHealthSumAggregateOutputType = {
    consecutiveFailures: number | null
  }

  export type AIProviderHealthMinAggregateOutputType = {
    id: string | null
    provider: string | null
    status: string | null
    consecutiveFailures: number | null
    lastFailureAt: Date | null
    lastSuccessAt: Date | null
    circuitOpenUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIProviderHealthMaxAggregateOutputType = {
    id: string | null
    provider: string | null
    status: string | null
    consecutiveFailures: number | null
    lastFailureAt: Date | null
    lastSuccessAt: Date | null
    circuitOpenUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIProviderHealthCountAggregateOutputType = {
    id: number
    provider: number
    status: number
    consecutiveFailures: number
    lastFailureAt: number
    lastSuccessAt: number
    circuitOpenUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIProviderHealthAvgAggregateInputType = {
    consecutiveFailures?: true
  }

  export type AIProviderHealthSumAggregateInputType = {
    consecutiveFailures?: true
  }

  export type AIProviderHealthMinAggregateInputType = {
    id?: true
    provider?: true
    status?: true
    consecutiveFailures?: true
    lastFailureAt?: true
    lastSuccessAt?: true
    circuitOpenUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIProviderHealthMaxAggregateInputType = {
    id?: true
    provider?: true
    status?: true
    consecutiveFailures?: true
    lastFailureAt?: true
    lastSuccessAt?: true
    circuitOpenUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIProviderHealthCountAggregateInputType = {
    id?: true
    provider?: true
    status?: true
    consecutiveFailures?: true
    lastFailureAt?: true
    lastSuccessAt?: true
    circuitOpenUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIProviderHealthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIProviderHealth to aggregate.
     */
    where?: AIProviderHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIProviderHealths to fetch.
     */
    orderBy?: AIProviderHealthOrderByWithRelationInput | AIProviderHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIProviderHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIProviderHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIProviderHealths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIProviderHealths
    **/
    _count?: true | AIProviderHealthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIProviderHealthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIProviderHealthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIProviderHealthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIProviderHealthMaxAggregateInputType
  }

  export type GetAIProviderHealthAggregateType<T extends AIProviderHealthAggregateArgs> = {
        [P in keyof T & keyof AggregateAIProviderHealth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIProviderHealth[P]>
      : GetScalarType<T[P], AggregateAIProviderHealth[P]>
  }




  export type AIProviderHealthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIProviderHealthWhereInput
    orderBy?: AIProviderHealthOrderByWithAggregationInput | AIProviderHealthOrderByWithAggregationInput[]
    by: AIProviderHealthScalarFieldEnum[] | AIProviderHealthScalarFieldEnum
    having?: AIProviderHealthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIProviderHealthCountAggregateInputType | true
    _avg?: AIProviderHealthAvgAggregateInputType
    _sum?: AIProviderHealthSumAggregateInputType
    _min?: AIProviderHealthMinAggregateInputType
    _max?: AIProviderHealthMaxAggregateInputType
  }

  export type AIProviderHealthGroupByOutputType = {
    id: string
    provider: string
    status: string
    consecutiveFailures: number
    lastFailureAt: Date | null
    lastSuccessAt: Date | null
    circuitOpenUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AIProviderHealthCountAggregateOutputType | null
    _avg: AIProviderHealthAvgAggregateOutputType | null
    _sum: AIProviderHealthSumAggregateOutputType | null
    _min: AIProviderHealthMinAggregateOutputType | null
    _max: AIProviderHealthMaxAggregateOutputType | null
  }

  type GetAIProviderHealthGroupByPayload<T extends AIProviderHealthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIProviderHealthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIProviderHealthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIProviderHealthGroupByOutputType[P]>
            : GetScalarType<T[P], AIProviderHealthGroupByOutputType[P]>
        }
      >
    >


  export type AIProviderHealthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    status?: boolean
    consecutiveFailures?: boolean
    lastFailureAt?: boolean
    lastSuccessAt?: boolean
    circuitOpenUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIProviderHealth"]>

  export type AIProviderHealthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    status?: boolean
    consecutiveFailures?: boolean
    lastFailureAt?: boolean
    lastSuccessAt?: boolean
    circuitOpenUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIProviderHealth"]>

  export type AIProviderHealthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    status?: boolean
    consecutiveFailures?: boolean
    lastFailureAt?: boolean
    lastSuccessAt?: boolean
    circuitOpenUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIProviderHealth"]>

  export type AIProviderHealthSelectScalar = {
    id?: boolean
    provider?: boolean
    status?: boolean
    consecutiveFailures?: boolean
    lastFailureAt?: boolean
    lastSuccessAt?: boolean
    circuitOpenUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIProviderHealthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider" | "status" | "consecutiveFailures" | "lastFailureAt" | "lastSuccessAt" | "circuitOpenUntil" | "createdAt" | "updatedAt", ExtArgs["result"]["aIProviderHealth"]>

  export type $AIProviderHealthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIProviderHealth"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: string
      status: string
      consecutiveFailures: number
      lastFailureAt: Date | null
      lastSuccessAt: Date | null
      circuitOpenUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIProviderHealth"]>
    composites: {}
  }

  type AIProviderHealthGetPayload<S extends boolean | null | undefined | AIProviderHealthDefaultArgs> = $Result.GetResult<Prisma.$AIProviderHealthPayload, S>

  type AIProviderHealthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIProviderHealthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIProviderHealthCountAggregateInputType | true
    }

  export interface AIProviderHealthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIProviderHealth'], meta: { name: 'AIProviderHealth' } }
    /**
     * Find zero or one AIProviderHealth that matches the filter.
     * @param {AIProviderHealthFindUniqueArgs} args - Arguments to find a AIProviderHealth
     * @example
     * // Get one AIProviderHealth
     * const aIProviderHealth = await prisma.aIProviderHealth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIProviderHealthFindUniqueArgs>(args: SelectSubset<T, AIProviderHealthFindUniqueArgs<ExtArgs>>): Prisma__AIProviderHealthClient<$Result.GetResult<Prisma.$AIProviderHealthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIProviderHealth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIProviderHealthFindUniqueOrThrowArgs} args - Arguments to find a AIProviderHealth
     * @example
     * // Get one AIProviderHealth
     * const aIProviderHealth = await prisma.aIProviderHealth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIProviderHealthFindUniqueOrThrowArgs>(args: SelectSubset<T, AIProviderHealthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIProviderHealthClient<$Result.GetResult<Prisma.$AIProviderHealthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIProviderHealth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderHealthFindFirstArgs} args - Arguments to find a AIProviderHealth
     * @example
     * // Get one AIProviderHealth
     * const aIProviderHealth = await prisma.aIProviderHealth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIProviderHealthFindFirstArgs>(args?: SelectSubset<T, AIProviderHealthFindFirstArgs<ExtArgs>>): Prisma__AIProviderHealthClient<$Result.GetResult<Prisma.$AIProviderHealthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIProviderHealth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderHealthFindFirstOrThrowArgs} args - Arguments to find a AIProviderHealth
     * @example
     * // Get one AIProviderHealth
     * const aIProviderHealth = await prisma.aIProviderHealth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIProviderHealthFindFirstOrThrowArgs>(args?: SelectSubset<T, AIProviderHealthFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIProviderHealthClient<$Result.GetResult<Prisma.$AIProviderHealthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIProviderHealths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderHealthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIProviderHealths
     * const aIProviderHealths = await prisma.aIProviderHealth.findMany()
     * 
     * // Get first 10 AIProviderHealths
     * const aIProviderHealths = await prisma.aIProviderHealth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIProviderHealthWithIdOnly = await prisma.aIProviderHealth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIProviderHealthFindManyArgs>(args?: SelectSubset<T, AIProviderHealthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIProviderHealthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIProviderHealth.
     * @param {AIProviderHealthCreateArgs} args - Arguments to create a AIProviderHealth.
     * @example
     * // Create one AIProviderHealth
     * const AIProviderHealth = await prisma.aIProviderHealth.create({
     *   data: {
     *     // ... data to create a AIProviderHealth
     *   }
     * })
     * 
     */
    create<T extends AIProviderHealthCreateArgs>(args: SelectSubset<T, AIProviderHealthCreateArgs<ExtArgs>>): Prisma__AIProviderHealthClient<$Result.GetResult<Prisma.$AIProviderHealthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIProviderHealths.
     * @param {AIProviderHealthCreateManyArgs} args - Arguments to create many AIProviderHealths.
     * @example
     * // Create many AIProviderHealths
     * const aIProviderHealth = await prisma.aIProviderHealth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIProviderHealthCreateManyArgs>(args?: SelectSubset<T, AIProviderHealthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIProviderHealths and returns the data saved in the database.
     * @param {AIProviderHealthCreateManyAndReturnArgs} args - Arguments to create many AIProviderHealths.
     * @example
     * // Create many AIProviderHealths
     * const aIProviderHealth = await prisma.aIProviderHealth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIProviderHealths and only return the `id`
     * const aIProviderHealthWithIdOnly = await prisma.aIProviderHealth.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIProviderHealthCreateManyAndReturnArgs>(args?: SelectSubset<T, AIProviderHealthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIProviderHealthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIProviderHealth.
     * @param {AIProviderHealthDeleteArgs} args - Arguments to delete one AIProviderHealth.
     * @example
     * // Delete one AIProviderHealth
     * const AIProviderHealth = await prisma.aIProviderHealth.delete({
     *   where: {
     *     // ... filter to delete one AIProviderHealth
     *   }
     * })
     * 
     */
    delete<T extends AIProviderHealthDeleteArgs>(args: SelectSubset<T, AIProviderHealthDeleteArgs<ExtArgs>>): Prisma__AIProviderHealthClient<$Result.GetResult<Prisma.$AIProviderHealthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIProviderHealth.
     * @param {AIProviderHealthUpdateArgs} args - Arguments to update one AIProviderHealth.
     * @example
     * // Update one AIProviderHealth
     * const aIProviderHealth = await prisma.aIProviderHealth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIProviderHealthUpdateArgs>(args: SelectSubset<T, AIProviderHealthUpdateArgs<ExtArgs>>): Prisma__AIProviderHealthClient<$Result.GetResult<Prisma.$AIProviderHealthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIProviderHealths.
     * @param {AIProviderHealthDeleteManyArgs} args - Arguments to filter AIProviderHealths to delete.
     * @example
     * // Delete a few AIProviderHealths
     * const { count } = await prisma.aIProviderHealth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIProviderHealthDeleteManyArgs>(args?: SelectSubset<T, AIProviderHealthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIProviderHealths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderHealthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIProviderHealths
     * const aIProviderHealth = await prisma.aIProviderHealth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIProviderHealthUpdateManyArgs>(args: SelectSubset<T, AIProviderHealthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIProviderHealths and returns the data updated in the database.
     * @param {AIProviderHealthUpdateManyAndReturnArgs} args - Arguments to update many AIProviderHealths.
     * @example
     * // Update many AIProviderHealths
     * const aIProviderHealth = await prisma.aIProviderHealth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIProviderHealths and only return the `id`
     * const aIProviderHealthWithIdOnly = await prisma.aIProviderHealth.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIProviderHealthUpdateManyAndReturnArgs>(args: SelectSubset<T, AIProviderHealthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIProviderHealthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIProviderHealth.
     * @param {AIProviderHealthUpsertArgs} args - Arguments to update or create a AIProviderHealth.
     * @example
     * // Update or create a AIProviderHealth
     * const aIProviderHealth = await prisma.aIProviderHealth.upsert({
     *   create: {
     *     // ... data to create a AIProviderHealth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIProviderHealth we want to update
     *   }
     * })
     */
    upsert<T extends AIProviderHealthUpsertArgs>(args: SelectSubset<T, AIProviderHealthUpsertArgs<ExtArgs>>): Prisma__AIProviderHealthClient<$Result.GetResult<Prisma.$AIProviderHealthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIProviderHealths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderHealthCountArgs} args - Arguments to filter AIProviderHealths to count.
     * @example
     * // Count the number of AIProviderHealths
     * const count = await prisma.aIProviderHealth.count({
     *   where: {
     *     // ... the filter for the AIProviderHealths we want to count
     *   }
     * })
    **/
    count<T extends AIProviderHealthCountArgs>(
      args?: Subset<T, AIProviderHealthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIProviderHealthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIProviderHealth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderHealthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIProviderHealthAggregateArgs>(args: Subset<T, AIProviderHealthAggregateArgs>): Prisma.PrismaPromise<GetAIProviderHealthAggregateType<T>>

    /**
     * Group by AIProviderHealth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderHealthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIProviderHealthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIProviderHealthGroupByArgs['orderBy'] }
        : { orderBy?: AIProviderHealthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIProviderHealthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIProviderHealthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIProviderHealth model
   */
  readonly fields: AIProviderHealthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIProviderHealth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIProviderHealthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIProviderHealth model
   */
  interface AIProviderHealthFieldRefs {
    readonly id: FieldRef<"AIProviderHealth", 'String'>
    readonly provider: FieldRef<"AIProviderHealth", 'String'>
    readonly status: FieldRef<"AIProviderHealth", 'String'>
    readonly consecutiveFailures: FieldRef<"AIProviderHealth", 'Int'>
    readonly lastFailureAt: FieldRef<"AIProviderHealth", 'DateTime'>
    readonly lastSuccessAt: FieldRef<"AIProviderHealth", 'DateTime'>
    readonly circuitOpenUntil: FieldRef<"AIProviderHealth", 'DateTime'>
    readonly createdAt: FieldRef<"AIProviderHealth", 'DateTime'>
    readonly updatedAt: FieldRef<"AIProviderHealth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIProviderHealth findUnique
   */
  export type AIProviderHealthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderHealth
     */
    select?: AIProviderHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderHealth
     */
    omit?: AIProviderHealthOmit<ExtArgs> | null
    /**
     * Filter, which AIProviderHealth to fetch.
     */
    where: AIProviderHealthWhereUniqueInput
  }

  /**
   * AIProviderHealth findUniqueOrThrow
   */
  export type AIProviderHealthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderHealth
     */
    select?: AIProviderHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderHealth
     */
    omit?: AIProviderHealthOmit<ExtArgs> | null
    /**
     * Filter, which AIProviderHealth to fetch.
     */
    where: AIProviderHealthWhereUniqueInput
  }

  /**
   * AIProviderHealth findFirst
   */
  export type AIProviderHealthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderHealth
     */
    select?: AIProviderHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderHealth
     */
    omit?: AIProviderHealthOmit<ExtArgs> | null
    /**
     * Filter, which AIProviderHealth to fetch.
     */
    where?: AIProviderHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIProviderHealths to fetch.
     */
    orderBy?: AIProviderHealthOrderByWithRelationInput | AIProviderHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIProviderHealths.
     */
    cursor?: AIProviderHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIProviderHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIProviderHealths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIProviderHealths.
     */
    distinct?: AIProviderHealthScalarFieldEnum | AIProviderHealthScalarFieldEnum[]
  }

  /**
   * AIProviderHealth findFirstOrThrow
   */
  export type AIProviderHealthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderHealth
     */
    select?: AIProviderHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderHealth
     */
    omit?: AIProviderHealthOmit<ExtArgs> | null
    /**
     * Filter, which AIProviderHealth to fetch.
     */
    where?: AIProviderHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIProviderHealths to fetch.
     */
    orderBy?: AIProviderHealthOrderByWithRelationInput | AIProviderHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIProviderHealths.
     */
    cursor?: AIProviderHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIProviderHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIProviderHealths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIProviderHealths.
     */
    distinct?: AIProviderHealthScalarFieldEnum | AIProviderHealthScalarFieldEnum[]
  }

  /**
   * AIProviderHealth findMany
   */
  export type AIProviderHealthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderHealth
     */
    select?: AIProviderHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderHealth
     */
    omit?: AIProviderHealthOmit<ExtArgs> | null
    /**
     * Filter, which AIProviderHealths to fetch.
     */
    where?: AIProviderHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIProviderHealths to fetch.
     */
    orderBy?: AIProviderHealthOrderByWithRelationInput | AIProviderHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIProviderHealths.
     */
    cursor?: AIProviderHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIProviderHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIProviderHealths.
     */
    skip?: number
    distinct?: AIProviderHealthScalarFieldEnum | AIProviderHealthScalarFieldEnum[]
  }

  /**
   * AIProviderHealth create
   */
  export type AIProviderHealthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderHealth
     */
    select?: AIProviderHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderHealth
     */
    omit?: AIProviderHealthOmit<ExtArgs> | null
    /**
     * The data needed to create a AIProviderHealth.
     */
    data: XOR<AIProviderHealthCreateInput, AIProviderHealthUncheckedCreateInput>
  }

  /**
   * AIProviderHealth createMany
   */
  export type AIProviderHealthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIProviderHealths.
     */
    data: AIProviderHealthCreateManyInput | AIProviderHealthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIProviderHealth createManyAndReturn
   */
  export type AIProviderHealthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderHealth
     */
    select?: AIProviderHealthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderHealth
     */
    omit?: AIProviderHealthOmit<ExtArgs> | null
    /**
     * The data used to create many AIProviderHealths.
     */
    data: AIProviderHealthCreateManyInput | AIProviderHealthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIProviderHealth update
   */
  export type AIProviderHealthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderHealth
     */
    select?: AIProviderHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderHealth
     */
    omit?: AIProviderHealthOmit<ExtArgs> | null
    /**
     * The data needed to update a AIProviderHealth.
     */
    data: XOR<AIProviderHealthUpdateInput, AIProviderHealthUncheckedUpdateInput>
    /**
     * Choose, which AIProviderHealth to update.
     */
    where: AIProviderHealthWhereUniqueInput
  }

  /**
   * AIProviderHealth updateMany
   */
  export type AIProviderHealthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIProviderHealths.
     */
    data: XOR<AIProviderHealthUpdateManyMutationInput, AIProviderHealthUncheckedUpdateManyInput>
    /**
     * Filter which AIProviderHealths to update
     */
    where?: AIProviderHealthWhereInput
    /**
     * Limit how many AIProviderHealths to update.
     */
    limit?: number
  }

  /**
   * AIProviderHealth updateManyAndReturn
   */
  export type AIProviderHealthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderHealth
     */
    select?: AIProviderHealthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderHealth
     */
    omit?: AIProviderHealthOmit<ExtArgs> | null
    /**
     * The data used to update AIProviderHealths.
     */
    data: XOR<AIProviderHealthUpdateManyMutationInput, AIProviderHealthUncheckedUpdateManyInput>
    /**
     * Filter which AIProviderHealths to update
     */
    where?: AIProviderHealthWhereInput
    /**
     * Limit how many AIProviderHealths to update.
     */
    limit?: number
  }

  /**
   * AIProviderHealth upsert
   */
  export type AIProviderHealthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderHealth
     */
    select?: AIProviderHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderHealth
     */
    omit?: AIProviderHealthOmit<ExtArgs> | null
    /**
     * The filter to search for the AIProviderHealth to update in case it exists.
     */
    where: AIProviderHealthWhereUniqueInput
    /**
     * In case the AIProviderHealth found by the `where` argument doesn't exist, create a new AIProviderHealth with this data.
     */
    create: XOR<AIProviderHealthCreateInput, AIProviderHealthUncheckedCreateInput>
    /**
     * In case the AIProviderHealth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIProviderHealthUpdateInput, AIProviderHealthUncheckedUpdateInput>
  }

  /**
   * AIProviderHealth delete
   */
  export type AIProviderHealthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderHealth
     */
    select?: AIProviderHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderHealth
     */
    omit?: AIProviderHealthOmit<ExtArgs> | null
    /**
     * Filter which AIProviderHealth to delete.
     */
    where: AIProviderHealthWhereUniqueInput
  }

  /**
   * AIProviderHealth deleteMany
   */
  export type AIProviderHealthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIProviderHealths to delete
     */
    where?: AIProviderHealthWhereInput
    /**
     * Limit how many AIProviderHealths to delete.
     */
    limit?: number
  }

  /**
   * AIProviderHealth without action
   */
  export type AIProviderHealthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderHealth
     */
    select?: AIProviderHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderHealth
     */
    omit?: AIProviderHealthOmit<ExtArgs> | null
  }


  /**
   * Model basiq_users
   */

  export type AggregateBasiq_users = {
    _count: Basiq_usersCountAggregateOutputType | null
    _min: Basiq_usersMinAggregateOutputType | null
    _max: Basiq_usersMaxAggregateOutputType | null
  }

  export type Basiq_usersMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    basiq_user_id: string | null
    email: string | null
    mobile: string | null
    connection_status: string | null
    consent_id: string | null
    consent_status: string | null
    consent_expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Basiq_usersMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    basiq_user_id: string | null
    email: string | null
    mobile: string | null
    connection_status: string | null
    consent_id: string | null
    consent_status: string | null
    consent_expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Basiq_usersCountAggregateOutputType = {
    id: number
    user_id: number
    basiq_user_id: number
    email: number
    mobile: number
    connection_status: number
    consent_id: number
    consent_status: number
    consent_expires_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Basiq_usersMinAggregateInputType = {
    id?: true
    user_id?: true
    basiq_user_id?: true
    email?: true
    mobile?: true
    connection_status?: true
    consent_id?: true
    consent_status?: true
    consent_expires_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Basiq_usersMaxAggregateInputType = {
    id?: true
    user_id?: true
    basiq_user_id?: true
    email?: true
    mobile?: true
    connection_status?: true
    consent_id?: true
    consent_status?: true
    consent_expires_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Basiq_usersCountAggregateInputType = {
    id?: true
    user_id?: true
    basiq_user_id?: true
    email?: true
    mobile?: true
    connection_status?: true
    consent_id?: true
    consent_status?: true
    consent_expires_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Basiq_usersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which basiq_users to aggregate.
     */
    where?: basiq_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basiq_users to fetch.
     */
    orderBy?: basiq_usersOrderByWithRelationInput | basiq_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: basiq_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basiq_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basiq_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned basiq_users
    **/
    _count?: true | Basiq_usersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Basiq_usersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Basiq_usersMaxAggregateInputType
  }

  export type GetBasiq_usersAggregateType<T extends Basiq_usersAggregateArgs> = {
        [P in keyof T & keyof AggregateBasiq_users]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBasiq_users[P]>
      : GetScalarType<T[P], AggregateBasiq_users[P]>
  }




  export type basiq_usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: basiq_usersWhereInput
    orderBy?: basiq_usersOrderByWithAggregationInput | basiq_usersOrderByWithAggregationInput[]
    by: Basiq_usersScalarFieldEnum[] | Basiq_usersScalarFieldEnum
    having?: basiq_usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Basiq_usersCountAggregateInputType | true
    _min?: Basiq_usersMinAggregateInputType
    _max?: Basiq_usersMaxAggregateInputType
  }

  export type Basiq_usersGroupByOutputType = {
    id: string
    user_id: string
    basiq_user_id: string
    email: string
    mobile: string | null
    connection_status: string | null
    consent_id: string | null
    consent_status: string | null
    consent_expires_at: Date | null
    created_at: Date
    updated_at: Date
    _count: Basiq_usersCountAggregateOutputType | null
    _min: Basiq_usersMinAggregateOutputType | null
    _max: Basiq_usersMaxAggregateOutputType | null
  }

  type GetBasiq_usersGroupByPayload<T extends basiq_usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Basiq_usersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Basiq_usersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Basiq_usersGroupByOutputType[P]>
            : GetScalarType<T[P], Basiq_usersGroupByOutputType[P]>
        }
      >
    >


  export type basiq_usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    basiq_user_id?: boolean
    email?: boolean
    mobile?: boolean
    connection_status?: boolean
    consent_id?: boolean
    consent_status?: boolean
    consent_expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bank_connections?: boolean | basiq_users$bank_connectionsArgs<ExtArgs>
    bank_accounts?: boolean | basiq_users$bank_accountsArgs<ExtArgs>
    _count?: boolean | Basiq_usersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["basiq_users"]>

  export type basiq_usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    basiq_user_id?: boolean
    email?: boolean
    mobile?: boolean
    connection_status?: boolean
    consent_id?: boolean
    consent_status?: boolean
    consent_expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["basiq_users"]>

  export type basiq_usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    basiq_user_id?: boolean
    email?: boolean
    mobile?: boolean
    connection_status?: boolean
    consent_id?: boolean
    consent_status?: boolean
    consent_expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["basiq_users"]>

  export type basiq_usersSelectScalar = {
    id?: boolean
    user_id?: boolean
    basiq_user_id?: boolean
    email?: boolean
    mobile?: boolean
    connection_status?: boolean
    consent_id?: boolean
    consent_status?: boolean
    consent_expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type basiq_usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "basiq_user_id" | "email" | "mobile" | "connection_status" | "consent_id" | "consent_status" | "consent_expires_at" | "created_at" | "updated_at", ExtArgs["result"]["basiq_users"]>
  export type basiq_usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bank_connections?: boolean | basiq_users$bank_connectionsArgs<ExtArgs>
    bank_accounts?: boolean | basiq_users$bank_accountsArgs<ExtArgs>
    _count?: boolean | Basiq_usersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type basiq_usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type basiq_usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $basiq_usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "basiq_users"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bank_connections: Prisma.$bank_connectionsPayload<ExtArgs>[]
      bank_accounts: Prisma.$bank_accountsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      basiq_user_id: string
      email: string
      /**
       * @encrypted
       */
      mobile: string | null
      connection_status: string | null
      consent_id: string | null
      consent_status: string | null
      consent_expires_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["basiq_users"]>
    composites: {}
  }

  type basiq_usersGetPayload<S extends boolean | null | undefined | basiq_usersDefaultArgs> = $Result.GetResult<Prisma.$basiq_usersPayload, S>

  type basiq_usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<basiq_usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Basiq_usersCountAggregateInputType | true
    }

  export interface basiq_usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['basiq_users'], meta: { name: 'basiq_users' } }
    /**
     * Find zero or one Basiq_users that matches the filter.
     * @param {basiq_usersFindUniqueArgs} args - Arguments to find a Basiq_users
     * @example
     * // Get one Basiq_users
     * const basiq_users = await prisma.basiq_users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends basiq_usersFindUniqueArgs>(args: SelectSubset<T, basiq_usersFindUniqueArgs<ExtArgs>>): Prisma__basiq_usersClient<$Result.GetResult<Prisma.$basiq_usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Basiq_users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {basiq_usersFindUniqueOrThrowArgs} args - Arguments to find a Basiq_users
     * @example
     * // Get one Basiq_users
     * const basiq_users = await prisma.basiq_users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends basiq_usersFindUniqueOrThrowArgs>(args: SelectSubset<T, basiq_usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__basiq_usersClient<$Result.GetResult<Prisma.$basiq_usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Basiq_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basiq_usersFindFirstArgs} args - Arguments to find a Basiq_users
     * @example
     * // Get one Basiq_users
     * const basiq_users = await prisma.basiq_users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends basiq_usersFindFirstArgs>(args?: SelectSubset<T, basiq_usersFindFirstArgs<ExtArgs>>): Prisma__basiq_usersClient<$Result.GetResult<Prisma.$basiq_usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Basiq_users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basiq_usersFindFirstOrThrowArgs} args - Arguments to find a Basiq_users
     * @example
     * // Get one Basiq_users
     * const basiq_users = await prisma.basiq_users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends basiq_usersFindFirstOrThrowArgs>(args?: SelectSubset<T, basiq_usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__basiq_usersClient<$Result.GetResult<Prisma.$basiq_usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Basiq_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basiq_usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Basiq_users
     * const basiq_users = await prisma.basiq_users.findMany()
     * 
     * // Get first 10 Basiq_users
     * const basiq_users = await prisma.basiq_users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const basiq_usersWithIdOnly = await prisma.basiq_users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends basiq_usersFindManyArgs>(args?: SelectSubset<T, basiq_usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$basiq_usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Basiq_users.
     * @param {basiq_usersCreateArgs} args - Arguments to create a Basiq_users.
     * @example
     * // Create one Basiq_users
     * const Basiq_users = await prisma.basiq_users.create({
     *   data: {
     *     // ... data to create a Basiq_users
     *   }
     * })
     * 
     */
    create<T extends basiq_usersCreateArgs>(args: SelectSubset<T, basiq_usersCreateArgs<ExtArgs>>): Prisma__basiq_usersClient<$Result.GetResult<Prisma.$basiq_usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Basiq_users.
     * @param {basiq_usersCreateManyArgs} args - Arguments to create many Basiq_users.
     * @example
     * // Create many Basiq_users
     * const basiq_users = await prisma.basiq_users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends basiq_usersCreateManyArgs>(args?: SelectSubset<T, basiq_usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Basiq_users and returns the data saved in the database.
     * @param {basiq_usersCreateManyAndReturnArgs} args - Arguments to create many Basiq_users.
     * @example
     * // Create many Basiq_users
     * const basiq_users = await prisma.basiq_users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Basiq_users and only return the `id`
     * const basiq_usersWithIdOnly = await prisma.basiq_users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends basiq_usersCreateManyAndReturnArgs>(args?: SelectSubset<T, basiq_usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$basiq_usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Basiq_users.
     * @param {basiq_usersDeleteArgs} args - Arguments to delete one Basiq_users.
     * @example
     * // Delete one Basiq_users
     * const Basiq_users = await prisma.basiq_users.delete({
     *   where: {
     *     // ... filter to delete one Basiq_users
     *   }
     * })
     * 
     */
    delete<T extends basiq_usersDeleteArgs>(args: SelectSubset<T, basiq_usersDeleteArgs<ExtArgs>>): Prisma__basiq_usersClient<$Result.GetResult<Prisma.$basiq_usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Basiq_users.
     * @param {basiq_usersUpdateArgs} args - Arguments to update one Basiq_users.
     * @example
     * // Update one Basiq_users
     * const basiq_users = await prisma.basiq_users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends basiq_usersUpdateArgs>(args: SelectSubset<T, basiq_usersUpdateArgs<ExtArgs>>): Prisma__basiq_usersClient<$Result.GetResult<Prisma.$basiq_usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Basiq_users.
     * @param {basiq_usersDeleteManyArgs} args - Arguments to filter Basiq_users to delete.
     * @example
     * // Delete a few Basiq_users
     * const { count } = await prisma.basiq_users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends basiq_usersDeleteManyArgs>(args?: SelectSubset<T, basiq_usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Basiq_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basiq_usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Basiq_users
     * const basiq_users = await prisma.basiq_users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends basiq_usersUpdateManyArgs>(args: SelectSubset<T, basiq_usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Basiq_users and returns the data updated in the database.
     * @param {basiq_usersUpdateManyAndReturnArgs} args - Arguments to update many Basiq_users.
     * @example
     * // Update many Basiq_users
     * const basiq_users = await prisma.basiq_users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Basiq_users and only return the `id`
     * const basiq_usersWithIdOnly = await prisma.basiq_users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends basiq_usersUpdateManyAndReturnArgs>(args: SelectSubset<T, basiq_usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$basiq_usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Basiq_users.
     * @param {basiq_usersUpsertArgs} args - Arguments to update or create a Basiq_users.
     * @example
     * // Update or create a Basiq_users
     * const basiq_users = await prisma.basiq_users.upsert({
     *   create: {
     *     // ... data to create a Basiq_users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Basiq_users we want to update
     *   }
     * })
     */
    upsert<T extends basiq_usersUpsertArgs>(args: SelectSubset<T, basiq_usersUpsertArgs<ExtArgs>>): Prisma__basiq_usersClient<$Result.GetResult<Prisma.$basiq_usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Basiq_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basiq_usersCountArgs} args - Arguments to filter Basiq_users to count.
     * @example
     * // Count the number of Basiq_users
     * const count = await prisma.basiq_users.count({
     *   where: {
     *     // ... the filter for the Basiq_users we want to count
     *   }
     * })
    **/
    count<T extends basiq_usersCountArgs>(
      args?: Subset<T, basiq_usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Basiq_usersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Basiq_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Basiq_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Basiq_usersAggregateArgs>(args: Subset<T, Basiq_usersAggregateArgs>): Prisma.PrismaPromise<GetBasiq_usersAggregateType<T>>

    /**
     * Group by Basiq_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basiq_usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends basiq_usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: basiq_usersGroupByArgs['orderBy'] }
        : { orderBy?: basiq_usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, basiq_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBasiq_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the basiq_users model
   */
  readonly fields: basiq_usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for basiq_users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__basiq_usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bank_connections<T extends basiq_users$bank_connectionsArgs<ExtArgs> = {}>(args?: Subset<T, basiq_users$bank_connectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bank_connectionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bank_accounts<T extends basiq_users$bank_accountsArgs<ExtArgs> = {}>(args?: Subset<T, basiq_users$bank_accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the basiq_users model
   */
  interface basiq_usersFieldRefs {
    readonly id: FieldRef<"basiq_users", 'String'>
    readonly user_id: FieldRef<"basiq_users", 'String'>
    readonly basiq_user_id: FieldRef<"basiq_users", 'String'>
    readonly email: FieldRef<"basiq_users", 'String'>
    readonly mobile: FieldRef<"basiq_users", 'String'>
    readonly connection_status: FieldRef<"basiq_users", 'String'>
    readonly consent_id: FieldRef<"basiq_users", 'String'>
    readonly consent_status: FieldRef<"basiq_users", 'String'>
    readonly consent_expires_at: FieldRef<"basiq_users", 'DateTime'>
    readonly created_at: FieldRef<"basiq_users", 'DateTime'>
    readonly updated_at: FieldRef<"basiq_users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * basiq_users findUnique
   */
  export type basiq_usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_users
     */
    select?: basiq_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_users
     */
    omit?: basiq_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_usersInclude<ExtArgs> | null
    /**
     * Filter, which basiq_users to fetch.
     */
    where: basiq_usersWhereUniqueInput
  }

  /**
   * basiq_users findUniqueOrThrow
   */
  export type basiq_usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_users
     */
    select?: basiq_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_users
     */
    omit?: basiq_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_usersInclude<ExtArgs> | null
    /**
     * Filter, which basiq_users to fetch.
     */
    where: basiq_usersWhereUniqueInput
  }

  /**
   * basiq_users findFirst
   */
  export type basiq_usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_users
     */
    select?: basiq_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_users
     */
    omit?: basiq_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_usersInclude<ExtArgs> | null
    /**
     * Filter, which basiq_users to fetch.
     */
    where?: basiq_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basiq_users to fetch.
     */
    orderBy?: basiq_usersOrderByWithRelationInput | basiq_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for basiq_users.
     */
    cursor?: basiq_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basiq_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basiq_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of basiq_users.
     */
    distinct?: Basiq_usersScalarFieldEnum | Basiq_usersScalarFieldEnum[]
  }

  /**
   * basiq_users findFirstOrThrow
   */
  export type basiq_usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_users
     */
    select?: basiq_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_users
     */
    omit?: basiq_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_usersInclude<ExtArgs> | null
    /**
     * Filter, which basiq_users to fetch.
     */
    where?: basiq_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basiq_users to fetch.
     */
    orderBy?: basiq_usersOrderByWithRelationInput | basiq_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for basiq_users.
     */
    cursor?: basiq_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basiq_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basiq_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of basiq_users.
     */
    distinct?: Basiq_usersScalarFieldEnum | Basiq_usersScalarFieldEnum[]
  }

  /**
   * basiq_users findMany
   */
  export type basiq_usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_users
     */
    select?: basiq_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_users
     */
    omit?: basiq_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_usersInclude<ExtArgs> | null
    /**
     * Filter, which basiq_users to fetch.
     */
    where?: basiq_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basiq_users to fetch.
     */
    orderBy?: basiq_usersOrderByWithRelationInput | basiq_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing basiq_users.
     */
    cursor?: basiq_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basiq_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basiq_users.
     */
    skip?: number
    distinct?: Basiq_usersScalarFieldEnum | Basiq_usersScalarFieldEnum[]
  }

  /**
   * basiq_users create
   */
  export type basiq_usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_users
     */
    select?: basiq_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_users
     */
    omit?: basiq_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_usersInclude<ExtArgs> | null
    /**
     * The data needed to create a basiq_users.
     */
    data: XOR<basiq_usersCreateInput, basiq_usersUncheckedCreateInput>
  }

  /**
   * basiq_users createMany
   */
  export type basiq_usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many basiq_users.
     */
    data: basiq_usersCreateManyInput | basiq_usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * basiq_users createManyAndReturn
   */
  export type basiq_usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_users
     */
    select?: basiq_usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_users
     */
    omit?: basiq_usersOmit<ExtArgs> | null
    /**
     * The data used to create many basiq_users.
     */
    data: basiq_usersCreateManyInput | basiq_usersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_usersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * basiq_users update
   */
  export type basiq_usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_users
     */
    select?: basiq_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_users
     */
    omit?: basiq_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_usersInclude<ExtArgs> | null
    /**
     * The data needed to update a basiq_users.
     */
    data: XOR<basiq_usersUpdateInput, basiq_usersUncheckedUpdateInput>
    /**
     * Choose, which basiq_users to update.
     */
    where: basiq_usersWhereUniqueInput
  }

  /**
   * basiq_users updateMany
   */
  export type basiq_usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update basiq_users.
     */
    data: XOR<basiq_usersUpdateManyMutationInput, basiq_usersUncheckedUpdateManyInput>
    /**
     * Filter which basiq_users to update
     */
    where?: basiq_usersWhereInput
    /**
     * Limit how many basiq_users to update.
     */
    limit?: number
  }

  /**
   * basiq_users updateManyAndReturn
   */
  export type basiq_usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_users
     */
    select?: basiq_usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_users
     */
    omit?: basiq_usersOmit<ExtArgs> | null
    /**
     * The data used to update basiq_users.
     */
    data: XOR<basiq_usersUpdateManyMutationInput, basiq_usersUncheckedUpdateManyInput>
    /**
     * Filter which basiq_users to update
     */
    where?: basiq_usersWhereInput
    /**
     * Limit how many basiq_users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_usersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * basiq_users upsert
   */
  export type basiq_usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_users
     */
    select?: basiq_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_users
     */
    omit?: basiq_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_usersInclude<ExtArgs> | null
    /**
     * The filter to search for the basiq_users to update in case it exists.
     */
    where: basiq_usersWhereUniqueInput
    /**
     * In case the basiq_users found by the `where` argument doesn't exist, create a new basiq_users with this data.
     */
    create: XOR<basiq_usersCreateInput, basiq_usersUncheckedCreateInput>
    /**
     * In case the basiq_users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<basiq_usersUpdateInput, basiq_usersUncheckedUpdateInput>
  }

  /**
   * basiq_users delete
   */
  export type basiq_usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_users
     */
    select?: basiq_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_users
     */
    omit?: basiq_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_usersInclude<ExtArgs> | null
    /**
     * Filter which basiq_users to delete.
     */
    where: basiq_usersWhereUniqueInput
  }

  /**
   * basiq_users deleteMany
   */
  export type basiq_usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which basiq_users to delete
     */
    where?: basiq_usersWhereInput
    /**
     * Limit how many basiq_users to delete.
     */
    limit?: number
  }

  /**
   * basiq_users.bank_connections
   */
  export type basiq_users$bank_connectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_connections
     */
    select?: bank_connectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_connections
     */
    omit?: bank_connectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_connectionsInclude<ExtArgs> | null
    where?: bank_connectionsWhereInput
    orderBy?: bank_connectionsOrderByWithRelationInput | bank_connectionsOrderByWithRelationInput[]
    cursor?: bank_connectionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bank_connectionsScalarFieldEnum | Bank_connectionsScalarFieldEnum[]
  }

  /**
   * basiq_users.bank_accounts
   */
  export type basiq_users$bank_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    where?: bank_accountsWhereInput
    orderBy?: bank_accountsOrderByWithRelationInput | bank_accountsOrderByWithRelationInput[]
    cursor?: bank_accountsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bank_accountsScalarFieldEnum | Bank_accountsScalarFieldEnum[]
  }

  /**
   * basiq_users without action
   */
  export type basiq_usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_users
     */
    select?: basiq_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_users
     */
    omit?: basiq_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_usersInclude<ExtArgs> | null
  }


  /**
   * Model bank_connections
   */

  export type AggregateBank_connections = {
    _count: Bank_connectionsCountAggregateOutputType | null
    _min: Bank_connectionsMinAggregateOutputType | null
    _max: Bank_connectionsMaxAggregateOutputType | null
  }

  export type Bank_connectionsMinAggregateOutputType = {
    id: string | null
    basiq_user_id: string | null
    connection_id: string | null
    institution_id: string | null
    institution_name: string | null
    institution_short_name: string | null
    institution_logo_url: string | null
    status: string | null
    last_synced: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bank_connectionsMaxAggregateOutputType = {
    id: string | null
    basiq_user_id: string | null
    connection_id: string | null
    institution_id: string | null
    institution_name: string | null
    institution_short_name: string | null
    institution_logo_url: string | null
    status: string | null
    last_synced: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bank_connectionsCountAggregateOutputType = {
    id: number
    basiq_user_id: number
    connection_id: number
    institution_id: number
    institution_name: number
    institution_short_name: number
    institution_logo_url: number
    status: number
    last_synced: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Bank_connectionsMinAggregateInputType = {
    id?: true
    basiq_user_id?: true
    connection_id?: true
    institution_id?: true
    institution_name?: true
    institution_short_name?: true
    institution_logo_url?: true
    status?: true
    last_synced?: true
    created_at?: true
    updated_at?: true
  }

  export type Bank_connectionsMaxAggregateInputType = {
    id?: true
    basiq_user_id?: true
    connection_id?: true
    institution_id?: true
    institution_name?: true
    institution_short_name?: true
    institution_logo_url?: true
    status?: true
    last_synced?: true
    created_at?: true
    updated_at?: true
  }

  export type Bank_connectionsCountAggregateInputType = {
    id?: true
    basiq_user_id?: true
    connection_id?: true
    institution_id?: true
    institution_name?: true
    institution_short_name?: true
    institution_logo_url?: true
    status?: true
    last_synced?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Bank_connectionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bank_connections to aggregate.
     */
    where?: bank_connectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_connections to fetch.
     */
    orderBy?: bank_connectionsOrderByWithRelationInput | bank_connectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bank_connectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bank_connections
    **/
    _count?: true | Bank_connectionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bank_connectionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bank_connectionsMaxAggregateInputType
  }

  export type GetBank_connectionsAggregateType<T extends Bank_connectionsAggregateArgs> = {
        [P in keyof T & keyof AggregateBank_connections]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBank_connections[P]>
      : GetScalarType<T[P], AggregateBank_connections[P]>
  }




  export type bank_connectionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bank_connectionsWhereInput
    orderBy?: bank_connectionsOrderByWithAggregationInput | bank_connectionsOrderByWithAggregationInput[]
    by: Bank_connectionsScalarFieldEnum[] | Bank_connectionsScalarFieldEnum
    having?: bank_connectionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bank_connectionsCountAggregateInputType | true
    _min?: Bank_connectionsMinAggregateInputType
    _max?: Bank_connectionsMaxAggregateInputType
  }

  export type Bank_connectionsGroupByOutputType = {
    id: string
    basiq_user_id: string
    connection_id: string
    institution_id: string
    institution_name: string
    institution_short_name: string | null
    institution_logo_url: string | null
    status: string | null
    last_synced: Date | null
    created_at: Date
    updated_at: Date
    _count: Bank_connectionsCountAggregateOutputType | null
    _min: Bank_connectionsMinAggregateOutputType | null
    _max: Bank_connectionsMaxAggregateOutputType | null
  }

  type GetBank_connectionsGroupByPayload<T extends bank_connectionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bank_connectionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bank_connectionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bank_connectionsGroupByOutputType[P]>
            : GetScalarType<T[P], Bank_connectionsGroupByOutputType[P]>
        }
      >
    >


  export type bank_connectionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    basiq_user_id?: boolean
    connection_id?: boolean
    institution_id?: boolean
    institution_name?: boolean
    institution_short_name?: boolean
    institution_logo_url?: boolean
    status?: boolean
    last_synced?: boolean
    created_at?: boolean
    updated_at?: boolean
    basiq_user?: boolean | basiq_usersDefaultArgs<ExtArgs>
    bank_accounts?: boolean | bank_connections$bank_accountsArgs<ExtArgs>
    _count?: boolean | Bank_connectionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bank_connections"]>

  export type bank_connectionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    basiq_user_id?: boolean
    connection_id?: boolean
    institution_id?: boolean
    institution_name?: boolean
    institution_short_name?: boolean
    institution_logo_url?: boolean
    status?: boolean
    last_synced?: boolean
    created_at?: boolean
    updated_at?: boolean
    basiq_user?: boolean | basiq_usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bank_connections"]>

  export type bank_connectionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    basiq_user_id?: boolean
    connection_id?: boolean
    institution_id?: boolean
    institution_name?: boolean
    institution_short_name?: boolean
    institution_logo_url?: boolean
    status?: boolean
    last_synced?: boolean
    created_at?: boolean
    updated_at?: boolean
    basiq_user?: boolean | basiq_usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bank_connections"]>

  export type bank_connectionsSelectScalar = {
    id?: boolean
    basiq_user_id?: boolean
    connection_id?: boolean
    institution_id?: boolean
    institution_name?: boolean
    institution_short_name?: boolean
    institution_logo_url?: boolean
    status?: boolean
    last_synced?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type bank_connectionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "basiq_user_id" | "connection_id" | "institution_id" | "institution_name" | "institution_short_name" | "institution_logo_url" | "status" | "last_synced" | "created_at" | "updated_at", ExtArgs["result"]["bank_connections"]>
  export type bank_connectionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    basiq_user?: boolean | basiq_usersDefaultArgs<ExtArgs>
    bank_accounts?: boolean | bank_connections$bank_accountsArgs<ExtArgs>
    _count?: boolean | Bank_connectionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type bank_connectionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    basiq_user?: boolean | basiq_usersDefaultArgs<ExtArgs>
  }
  export type bank_connectionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    basiq_user?: boolean | basiq_usersDefaultArgs<ExtArgs>
  }

  export type $bank_connectionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bank_connections"
    objects: {
      basiq_user: Prisma.$basiq_usersPayload<ExtArgs>
      bank_accounts: Prisma.$bank_accountsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      basiq_user_id: string
      connection_id: string
      institution_id: string
      institution_name: string
      institution_short_name: string | null
      institution_logo_url: string | null
      status: string | null
      last_synced: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["bank_connections"]>
    composites: {}
  }

  type bank_connectionsGetPayload<S extends boolean | null | undefined | bank_connectionsDefaultArgs> = $Result.GetResult<Prisma.$bank_connectionsPayload, S>

  type bank_connectionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bank_connectionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Bank_connectionsCountAggregateInputType | true
    }

  export interface bank_connectionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bank_connections'], meta: { name: 'bank_connections' } }
    /**
     * Find zero or one Bank_connections that matches the filter.
     * @param {bank_connectionsFindUniqueArgs} args - Arguments to find a Bank_connections
     * @example
     * // Get one Bank_connections
     * const bank_connections = await prisma.bank_connections.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bank_connectionsFindUniqueArgs>(args: SelectSubset<T, bank_connectionsFindUniqueArgs<ExtArgs>>): Prisma__bank_connectionsClient<$Result.GetResult<Prisma.$bank_connectionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bank_connections that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bank_connectionsFindUniqueOrThrowArgs} args - Arguments to find a Bank_connections
     * @example
     * // Get one Bank_connections
     * const bank_connections = await prisma.bank_connections.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bank_connectionsFindUniqueOrThrowArgs>(args: SelectSubset<T, bank_connectionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bank_connectionsClient<$Result.GetResult<Prisma.$bank_connectionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bank_connections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_connectionsFindFirstArgs} args - Arguments to find a Bank_connections
     * @example
     * // Get one Bank_connections
     * const bank_connections = await prisma.bank_connections.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bank_connectionsFindFirstArgs>(args?: SelectSubset<T, bank_connectionsFindFirstArgs<ExtArgs>>): Prisma__bank_connectionsClient<$Result.GetResult<Prisma.$bank_connectionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bank_connections that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_connectionsFindFirstOrThrowArgs} args - Arguments to find a Bank_connections
     * @example
     * // Get one Bank_connections
     * const bank_connections = await prisma.bank_connections.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bank_connectionsFindFirstOrThrowArgs>(args?: SelectSubset<T, bank_connectionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__bank_connectionsClient<$Result.GetResult<Prisma.$bank_connectionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bank_connections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_connectionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bank_connections
     * const bank_connections = await prisma.bank_connections.findMany()
     * 
     * // Get first 10 Bank_connections
     * const bank_connections = await prisma.bank_connections.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bank_connectionsWithIdOnly = await prisma.bank_connections.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bank_connectionsFindManyArgs>(args?: SelectSubset<T, bank_connectionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bank_connectionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bank_connections.
     * @param {bank_connectionsCreateArgs} args - Arguments to create a Bank_connections.
     * @example
     * // Create one Bank_connections
     * const Bank_connections = await prisma.bank_connections.create({
     *   data: {
     *     // ... data to create a Bank_connections
     *   }
     * })
     * 
     */
    create<T extends bank_connectionsCreateArgs>(args: SelectSubset<T, bank_connectionsCreateArgs<ExtArgs>>): Prisma__bank_connectionsClient<$Result.GetResult<Prisma.$bank_connectionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bank_connections.
     * @param {bank_connectionsCreateManyArgs} args - Arguments to create many Bank_connections.
     * @example
     * // Create many Bank_connections
     * const bank_connections = await prisma.bank_connections.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bank_connectionsCreateManyArgs>(args?: SelectSubset<T, bank_connectionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bank_connections and returns the data saved in the database.
     * @param {bank_connectionsCreateManyAndReturnArgs} args - Arguments to create many Bank_connections.
     * @example
     * // Create many Bank_connections
     * const bank_connections = await prisma.bank_connections.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bank_connections and only return the `id`
     * const bank_connectionsWithIdOnly = await prisma.bank_connections.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends bank_connectionsCreateManyAndReturnArgs>(args?: SelectSubset<T, bank_connectionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bank_connectionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bank_connections.
     * @param {bank_connectionsDeleteArgs} args - Arguments to delete one Bank_connections.
     * @example
     * // Delete one Bank_connections
     * const Bank_connections = await prisma.bank_connections.delete({
     *   where: {
     *     // ... filter to delete one Bank_connections
     *   }
     * })
     * 
     */
    delete<T extends bank_connectionsDeleteArgs>(args: SelectSubset<T, bank_connectionsDeleteArgs<ExtArgs>>): Prisma__bank_connectionsClient<$Result.GetResult<Prisma.$bank_connectionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bank_connections.
     * @param {bank_connectionsUpdateArgs} args - Arguments to update one Bank_connections.
     * @example
     * // Update one Bank_connections
     * const bank_connections = await prisma.bank_connections.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bank_connectionsUpdateArgs>(args: SelectSubset<T, bank_connectionsUpdateArgs<ExtArgs>>): Prisma__bank_connectionsClient<$Result.GetResult<Prisma.$bank_connectionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bank_connections.
     * @param {bank_connectionsDeleteManyArgs} args - Arguments to filter Bank_connections to delete.
     * @example
     * // Delete a few Bank_connections
     * const { count } = await prisma.bank_connections.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bank_connectionsDeleteManyArgs>(args?: SelectSubset<T, bank_connectionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bank_connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_connectionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bank_connections
     * const bank_connections = await prisma.bank_connections.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bank_connectionsUpdateManyArgs>(args: SelectSubset<T, bank_connectionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bank_connections and returns the data updated in the database.
     * @param {bank_connectionsUpdateManyAndReturnArgs} args - Arguments to update many Bank_connections.
     * @example
     * // Update many Bank_connections
     * const bank_connections = await prisma.bank_connections.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bank_connections and only return the `id`
     * const bank_connectionsWithIdOnly = await prisma.bank_connections.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends bank_connectionsUpdateManyAndReturnArgs>(args: SelectSubset<T, bank_connectionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bank_connectionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bank_connections.
     * @param {bank_connectionsUpsertArgs} args - Arguments to update or create a Bank_connections.
     * @example
     * // Update or create a Bank_connections
     * const bank_connections = await prisma.bank_connections.upsert({
     *   create: {
     *     // ... data to create a Bank_connections
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bank_connections we want to update
     *   }
     * })
     */
    upsert<T extends bank_connectionsUpsertArgs>(args: SelectSubset<T, bank_connectionsUpsertArgs<ExtArgs>>): Prisma__bank_connectionsClient<$Result.GetResult<Prisma.$bank_connectionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bank_connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_connectionsCountArgs} args - Arguments to filter Bank_connections to count.
     * @example
     * // Count the number of Bank_connections
     * const count = await prisma.bank_connections.count({
     *   where: {
     *     // ... the filter for the Bank_connections we want to count
     *   }
     * })
    **/
    count<T extends bank_connectionsCountArgs>(
      args?: Subset<T, bank_connectionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bank_connectionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bank_connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bank_connectionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bank_connectionsAggregateArgs>(args: Subset<T, Bank_connectionsAggregateArgs>): Prisma.PrismaPromise<GetBank_connectionsAggregateType<T>>

    /**
     * Group by Bank_connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_connectionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bank_connectionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bank_connectionsGroupByArgs['orderBy'] }
        : { orderBy?: bank_connectionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bank_connectionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBank_connectionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bank_connections model
   */
  readonly fields: bank_connectionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bank_connections.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bank_connectionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    basiq_user<T extends basiq_usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, basiq_usersDefaultArgs<ExtArgs>>): Prisma__basiq_usersClient<$Result.GetResult<Prisma.$basiq_usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bank_accounts<T extends bank_connections$bank_accountsArgs<ExtArgs> = {}>(args?: Subset<T, bank_connections$bank_accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bank_connections model
   */
  interface bank_connectionsFieldRefs {
    readonly id: FieldRef<"bank_connections", 'String'>
    readonly basiq_user_id: FieldRef<"bank_connections", 'String'>
    readonly connection_id: FieldRef<"bank_connections", 'String'>
    readonly institution_id: FieldRef<"bank_connections", 'String'>
    readonly institution_name: FieldRef<"bank_connections", 'String'>
    readonly institution_short_name: FieldRef<"bank_connections", 'String'>
    readonly institution_logo_url: FieldRef<"bank_connections", 'String'>
    readonly status: FieldRef<"bank_connections", 'String'>
    readonly last_synced: FieldRef<"bank_connections", 'DateTime'>
    readonly created_at: FieldRef<"bank_connections", 'DateTime'>
    readonly updated_at: FieldRef<"bank_connections", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * bank_connections findUnique
   */
  export type bank_connectionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_connections
     */
    select?: bank_connectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_connections
     */
    omit?: bank_connectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which bank_connections to fetch.
     */
    where: bank_connectionsWhereUniqueInput
  }

  /**
   * bank_connections findUniqueOrThrow
   */
  export type bank_connectionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_connections
     */
    select?: bank_connectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_connections
     */
    omit?: bank_connectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which bank_connections to fetch.
     */
    where: bank_connectionsWhereUniqueInput
  }

  /**
   * bank_connections findFirst
   */
  export type bank_connectionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_connections
     */
    select?: bank_connectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_connections
     */
    omit?: bank_connectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which bank_connections to fetch.
     */
    where?: bank_connectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_connections to fetch.
     */
    orderBy?: bank_connectionsOrderByWithRelationInput | bank_connectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bank_connections.
     */
    cursor?: bank_connectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bank_connections.
     */
    distinct?: Bank_connectionsScalarFieldEnum | Bank_connectionsScalarFieldEnum[]
  }

  /**
   * bank_connections findFirstOrThrow
   */
  export type bank_connectionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_connections
     */
    select?: bank_connectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_connections
     */
    omit?: bank_connectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which bank_connections to fetch.
     */
    where?: bank_connectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_connections to fetch.
     */
    orderBy?: bank_connectionsOrderByWithRelationInput | bank_connectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bank_connections.
     */
    cursor?: bank_connectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bank_connections.
     */
    distinct?: Bank_connectionsScalarFieldEnum | Bank_connectionsScalarFieldEnum[]
  }

  /**
   * bank_connections findMany
   */
  export type bank_connectionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_connections
     */
    select?: bank_connectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_connections
     */
    omit?: bank_connectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which bank_connections to fetch.
     */
    where?: bank_connectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_connections to fetch.
     */
    orderBy?: bank_connectionsOrderByWithRelationInput | bank_connectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bank_connections.
     */
    cursor?: bank_connectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_connections.
     */
    skip?: number
    distinct?: Bank_connectionsScalarFieldEnum | Bank_connectionsScalarFieldEnum[]
  }

  /**
   * bank_connections create
   */
  export type bank_connectionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_connections
     */
    select?: bank_connectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_connections
     */
    omit?: bank_connectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_connectionsInclude<ExtArgs> | null
    /**
     * The data needed to create a bank_connections.
     */
    data: XOR<bank_connectionsCreateInput, bank_connectionsUncheckedCreateInput>
  }

  /**
   * bank_connections createMany
   */
  export type bank_connectionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bank_connections.
     */
    data: bank_connectionsCreateManyInput | bank_connectionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bank_connections createManyAndReturn
   */
  export type bank_connectionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_connections
     */
    select?: bank_connectionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bank_connections
     */
    omit?: bank_connectionsOmit<ExtArgs> | null
    /**
     * The data used to create many bank_connections.
     */
    data: bank_connectionsCreateManyInput | bank_connectionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_connectionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * bank_connections update
   */
  export type bank_connectionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_connections
     */
    select?: bank_connectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_connections
     */
    omit?: bank_connectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_connectionsInclude<ExtArgs> | null
    /**
     * The data needed to update a bank_connections.
     */
    data: XOR<bank_connectionsUpdateInput, bank_connectionsUncheckedUpdateInput>
    /**
     * Choose, which bank_connections to update.
     */
    where: bank_connectionsWhereUniqueInput
  }

  /**
   * bank_connections updateMany
   */
  export type bank_connectionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bank_connections.
     */
    data: XOR<bank_connectionsUpdateManyMutationInput, bank_connectionsUncheckedUpdateManyInput>
    /**
     * Filter which bank_connections to update
     */
    where?: bank_connectionsWhereInput
    /**
     * Limit how many bank_connections to update.
     */
    limit?: number
  }

  /**
   * bank_connections updateManyAndReturn
   */
  export type bank_connectionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_connections
     */
    select?: bank_connectionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bank_connections
     */
    omit?: bank_connectionsOmit<ExtArgs> | null
    /**
     * The data used to update bank_connections.
     */
    data: XOR<bank_connectionsUpdateManyMutationInput, bank_connectionsUncheckedUpdateManyInput>
    /**
     * Filter which bank_connections to update
     */
    where?: bank_connectionsWhereInput
    /**
     * Limit how many bank_connections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_connectionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * bank_connections upsert
   */
  export type bank_connectionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_connections
     */
    select?: bank_connectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_connections
     */
    omit?: bank_connectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_connectionsInclude<ExtArgs> | null
    /**
     * The filter to search for the bank_connections to update in case it exists.
     */
    where: bank_connectionsWhereUniqueInput
    /**
     * In case the bank_connections found by the `where` argument doesn't exist, create a new bank_connections with this data.
     */
    create: XOR<bank_connectionsCreateInput, bank_connectionsUncheckedCreateInput>
    /**
     * In case the bank_connections was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bank_connectionsUpdateInput, bank_connectionsUncheckedUpdateInput>
  }

  /**
   * bank_connections delete
   */
  export type bank_connectionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_connections
     */
    select?: bank_connectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_connections
     */
    omit?: bank_connectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_connectionsInclude<ExtArgs> | null
    /**
     * Filter which bank_connections to delete.
     */
    where: bank_connectionsWhereUniqueInput
  }

  /**
   * bank_connections deleteMany
   */
  export type bank_connectionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bank_connections to delete
     */
    where?: bank_connectionsWhereInput
    /**
     * Limit how many bank_connections to delete.
     */
    limit?: number
  }

  /**
   * bank_connections.bank_accounts
   */
  export type bank_connections$bank_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    where?: bank_accountsWhereInput
    orderBy?: bank_accountsOrderByWithRelationInput | bank_accountsOrderByWithRelationInput[]
    cursor?: bank_accountsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bank_accountsScalarFieldEnum | Bank_accountsScalarFieldEnum[]
  }

  /**
   * bank_connections without action
   */
  export type bank_connectionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_connections
     */
    select?: bank_connectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_connections
     */
    omit?: bank_connectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_connectionsInclude<ExtArgs> | null
  }


  /**
   * Model bank_accounts
   */

  export type AggregateBank_accounts = {
    _count: Bank_accountsCountAggregateOutputType | null
    _avg: Bank_accountsAvgAggregateOutputType | null
    _sum: Bank_accountsSumAggregateOutputType | null
    _min: Bank_accountsMinAggregateOutputType | null
    _max: Bank_accountsMaxAggregateOutputType | null
  }

  export type Bank_accountsAvgAggregateOutputType = {
    balance_available: Decimal | null
    balance_current: Decimal | null
  }

  export type Bank_accountsSumAggregateOutputType = {
    balance_available: Decimal | null
    balance_current: Decimal | null
  }

  export type Bank_accountsMinAggregateOutputType = {
    id: string | null
    basiq_user_id: string | null
    connection_id: string | null
    basiq_account_id: string | null
    account_holder: string | null
    account_number: string | null
    bsb: string | null
    institution_name: string | null
    account_type: string | null
    account_name: string | null
    balance_available: Decimal | null
    balance_current: Decimal | null
    currency: string | null
    status: string | null
    is_business_account: boolean | null
    last_synced: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bank_accountsMaxAggregateOutputType = {
    id: string | null
    basiq_user_id: string | null
    connection_id: string | null
    basiq_account_id: string | null
    account_holder: string | null
    account_number: string | null
    bsb: string | null
    institution_name: string | null
    account_type: string | null
    account_name: string | null
    balance_available: Decimal | null
    balance_current: Decimal | null
    currency: string | null
    status: string | null
    is_business_account: boolean | null
    last_synced: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bank_accountsCountAggregateOutputType = {
    id: number
    basiq_user_id: number
    connection_id: number
    basiq_account_id: number
    account_holder: number
    account_number: number
    bsb: number
    institution_name: number
    account_type: number
    account_name: number
    balance_available: number
    balance_current: number
    currency: number
    status: number
    is_business_account: number
    last_synced: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Bank_accountsAvgAggregateInputType = {
    balance_available?: true
    balance_current?: true
  }

  export type Bank_accountsSumAggregateInputType = {
    balance_available?: true
    balance_current?: true
  }

  export type Bank_accountsMinAggregateInputType = {
    id?: true
    basiq_user_id?: true
    connection_id?: true
    basiq_account_id?: true
    account_holder?: true
    account_number?: true
    bsb?: true
    institution_name?: true
    account_type?: true
    account_name?: true
    balance_available?: true
    balance_current?: true
    currency?: true
    status?: true
    is_business_account?: true
    last_synced?: true
    created_at?: true
    updated_at?: true
  }

  export type Bank_accountsMaxAggregateInputType = {
    id?: true
    basiq_user_id?: true
    connection_id?: true
    basiq_account_id?: true
    account_holder?: true
    account_number?: true
    bsb?: true
    institution_name?: true
    account_type?: true
    account_name?: true
    balance_available?: true
    balance_current?: true
    currency?: true
    status?: true
    is_business_account?: true
    last_synced?: true
    created_at?: true
    updated_at?: true
  }

  export type Bank_accountsCountAggregateInputType = {
    id?: true
    basiq_user_id?: true
    connection_id?: true
    basiq_account_id?: true
    account_holder?: true
    account_number?: true
    bsb?: true
    institution_name?: true
    account_type?: true
    account_name?: true
    balance_available?: true
    balance_current?: true
    currency?: true
    status?: true
    is_business_account?: true
    last_synced?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Bank_accountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bank_accounts to aggregate.
     */
    where?: bank_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_accounts to fetch.
     */
    orderBy?: bank_accountsOrderByWithRelationInput | bank_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bank_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bank_accounts
    **/
    _count?: true | Bank_accountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bank_accountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bank_accountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bank_accountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bank_accountsMaxAggregateInputType
  }

  export type GetBank_accountsAggregateType<T extends Bank_accountsAggregateArgs> = {
        [P in keyof T & keyof AggregateBank_accounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBank_accounts[P]>
      : GetScalarType<T[P], AggregateBank_accounts[P]>
  }




  export type bank_accountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bank_accountsWhereInput
    orderBy?: bank_accountsOrderByWithAggregationInput | bank_accountsOrderByWithAggregationInput[]
    by: Bank_accountsScalarFieldEnum[] | Bank_accountsScalarFieldEnum
    having?: bank_accountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bank_accountsCountAggregateInputType | true
    _avg?: Bank_accountsAvgAggregateInputType
    _sum?: Bank_accountsSumAggregateInputType
    _min?: Bank_accountsMinAggregateInputType
    _max?: Bank_accountsMaxAggregateInputType
  }

  export type Bank_accountsGroupByOutputType = {
    id: string
    basiq_user_id: string
    connection_id: string
    basiq_account_id: string
    account_holder: string | null
    account_number: string | null
    bsb: string | null
    institution_name: string | null
    account_type: string | null
    account_name: string | null
    balance_available: Decimal | null
    balance_current: Decimal | null
    currency: string | null
    status: string | null
    is_business_account: boolean
    last_synced: Date | null
    created_at: Date
    updated_at: Date
    _count: Bank_accountsCountAggregateOutputType | null
    _avg: Bank_accountsAvgAggregateOutputType | null
    _sum: Bank_accountsSumAggregateOutputType | null
    _min: Bank_accountsMinAggregateOutputType | null
    _max: Bank_accountsMaxAggregateOutputType | null
  }

  type GetBank_accountsGroupByPayload<T extends bank_accountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bank_accountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bank_accountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bank_accountsGroupByOutputType[P]>
            : GetScalarType<T[P], Bank_accountsGroupByOutputType[P]>
        }
      >
    >


  export type bank_accountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    basiq_user_id?: boolean
    connection_id?: boolean
    basiq_account_id?: boolean
    account_holder?: boolean
    account_number?: boolean
    bsb?: boolean
    institution_name?: boolean
    account_type?: boolean
    account_name?: boolean
    balance_available?: boolean
    balance_current?: boolean
    currency?: boolean
    status?: boolean
    is_business_account?: boolean
    last_synced?: boolean
    created_at?: boolean
    updated_at?: boolean
    basiq_user?: boolean | basiq_usersDefaultArgs<ExtArgs>
    connection?: boolean | bank_connectionsDefaultArgs<ExtArgs>
    bank_transactions?: boolean | bank_accounts$bank_transactionsArgs<ExtArgs>
    _count?: boolean | Bank_accountsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bank_accounts"]>

  export type bank_accountsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    basiq_user_id?: boolean
    connection_id?: boolean
    basiq_account_id?: boolean
    account_holder?: boolean
    account_number?: boolean
    bsb?: boolean
    institution_name?: boolean
    account_type?: boolean
    account_name?: boolean
    balance_available?: boolean
    balance_current?: boolean
    currency?: boolean
    status?: boolean
    is_business_account?: boolean
    last_synced?: boolean
    created_at?: boolean
    updated_at?: boolean
    basiq_user?: boolean | basiq_usersDefaultArgs<ExtArgs>
    connection?: boolean | bank_connectionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bank_accounts"]>

  export type bank_accountsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    basiq_user_id?: boolean
    connection_id?: boolean
    basiq_account_id?: boolean
    account_holder?: boolean
    account_number?: boolean
    bsb?: boolean
    institution_name?: boolean
    account_type?: boolean
    account_name?: boolean
    balance_available?: boolean
    balance_current?: boolean
    currency?: boolean
    status?: boolean
    is_business_account?: boolean
    last_synced?: boolean
    created_at?: boolean
    updated_at?: boolean
    basiq_user?: boolean | basiq_usersDefaultArgs<ExtArgs>
    connection?: boolean | bank_connectionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bank_accounts"]>

  export type bank_accountsSelectScalar = {
    id?: boolean
    basiq_user_id?: boolean
    connection_id?: boolean
    basiq_account_id?: boolean
    account_holder?: boolean
    account_number?: boolean
    bsb?: boolean
    institution_name?: boolean
    account_type?: boolean
    account_name?: boolean
    balance_available?: boolean
    balance_current?: boolean
    currency?: boolean
    status?: boolean
    is_business_account?: boolean
    last_synced?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type bank_accountsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "basiq_user_id" | "connection_id" | "basiq_account_id" | "account_holder" | "account_number" | "bsb" | "institution_name" | "account_type" | "account_name" | "balance_available" | "balance_current" | "currency" | "status" | "is_business_account" | "last_synced" | "created_at" | "updated_at", ExtArgs["result"]["bank_accounts"]>
  export type bank_accountsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    basiq_user?: boolean | basiq_usersDefaultArgs<ExtArgs>
    connection?: boolean | bank_connectionsDefaultArgs<ExtArgs>
    bank_transactions?: boolean | bank_accounts$bank_transactionsArgs<ExtArgs>
    _count?: boolean | Bank_accountsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type bank_accountsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    basiq_user?: boolean | basiq_usersDefaultArgs<ExtArgs>
    connection?: boolean | bank_connectionsDefaultArgs<ExtArgs>
  }
  export type bank_accountsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    basiq_user?: boolean | basiq_usersDefaultArgs<ExtArgs>
    connection?: boolean | bank_connectionsDefaultArgs<ExtArgs>
  }

  export type $bank_accountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bank_accounts"
    objects: {
      basiq_user: Prisma.$basiq_usersPayload<ExtArgs>
      connection: Prisma.$bank_connectionsPayload<ExtArgs>
      bank_transactions: Prisma.$bank_transactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      basiq_user_id: string
      connection_id: string
      basiq_account_id: string
      account_holder: string | null
      /**
       * @encrypted
       */
      account_number: string | null
      /**
       * @encrypted
       */
      bsb: string | null
      institution_name: string | null
      account_type: string | null
      account_name: string | null
      balance_available: Prisma.Decimal | null
      balance_current: Prisma.Decimal | null
      currency: string | null
      status: string | null
      is_business_account: boolean
      last_synced: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["bank_accounts"]>
    composites: {}
  }

  type bank_accountsGetPayload<S extends boolean | null | undefined | bank_accountsDefaultArgs> = $Result.GetResult<Prisma.$bank_accountsPayload, S>

  type bank_accountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bank_accountsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Bank_accountsCountAggregateInputType | true
    }

  export interface bank_accountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bank_accounts'], meta: { name: 'bank_accounts' } }
    /**
     * Find zero or one Bank_accounts that matches the filter.
     * @param {bank_accountsFindUniqueArgs} args - Arguments to find a Bank_accounts
     * @example
     * // Get one Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bank_accountsFindUniqueArgs>(args: SelectSubset<T, bank_accountsFindUniqueArgs<ExtArgs>>): Prisma__bank_accountsClient<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bank_accounts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bank_accountsFindUniqueOrThrowArgs} args - Arguments to find a Bank_accounts
     * @example
     * // Get one Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bank_accountsFindUniqueOrThrowArgs>(args: SelectSubset<T, bank_accountsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bank_accountsClient<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bank_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_accountsFindFirstArgs} args - Arguments to find a Bank_accounts
     * @example
     * // Get one Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bank_accountsFindFirstArgs>(args?: SelectSubset<T, bank_accountsFindFirstArgs<ExtArgs>>): Prisma__bank_accountsClient<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bank_accounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_accountsFindFirstOrThrowArgs} args - Arguments to find a Bank_accounts
     * @example
     * // Get one Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bank_accountsFindFirstOrThrowArgs>(args?: SelectSubset<T, bank_accountsFindFirstOrThrowArgs<ExtArgs>>): Prisma__bank_accountsClient<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bank_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_accountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.findMany()
     * 
     * // Get first 10 Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bank_accountsWithIdOnly = await prisma.bank_accounts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bank_accountsFindManyArgs>(args?: SelectSubset<T, bank_accountsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bank_accounts.
     * @param {bank_accountsCreateArgs} args - Arguments to create a Bank_accounts.
     * @example
     * // Create one Bank_accounts
     * const Bank_accounts = await prisma.bank_accounts.create({
     *   data: {
     *     // ... data to create a Bank_accounts
     *   }
     * })
     * 
     */
    create<T extends bank_accountsCreateArgs>(args: SelectSubset<T, bank_accountsCreateArgs<ExtArgs>>): Prisma__bank_accountsClient<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bank_accounts.
     * @param {bank_accountsCreateManyArgs} args - Arguments to create many Bank_accounts.
     * @example
     * // Create many Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bank_accountsCreateManyArgs>(args?: SelectSubset<T, bank_accountsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bank_accounts and returns the data saved in the database.
     * @param {bank_accountsCreateManyAndReturnArgs} args - Arguments to create many Bank_accounts.
     * @example
     * // Create many Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bank_accounts and only return the `id`
     * const bank_accountsWithIdOnly = await prisma.bank_accounts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends bank_accountsCreateManyAndReturnArgs>(args?: SelectSubset<T, bank_accountsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bank_accounts.
     * @param {bank_accountsDeleteArgs} args - Arguments to delete one Bank_accounts.
     * @example
     * // Delete one Bank_accounts
     * const Bank_accounts = await prisma.bank_accounts.delete({
     *   where: {
     *     // ... filter to delete one Bank_accounts
     *   }
     * })
     * 
     */
    delete<T extends bank_accountsDeleteArgs>(args: SelectSubset<T, bank_accountsDeleteArgs<ExtArgs>>): Prisma__bank_accountsClient<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bank_accounts.
     * @param {bank_accountsUpdateArgs} args - Arguments to update one Bank_accounts.
     * @example
     * // Update one Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bank_accountsUpdateArgs>(args: SelectSubset<T, bank_accountsUpdateArgs<ExtArgs>>): Prisma__bank_accountsClient<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bank_accounts.
     * @param {bank_accountsDeleteManyArgs} args - Arguments to filter Bank_accounts to delete.
     * @example
     * // Delete a few Bank_accounts
     * const { count } = await prisma.bank_accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bank_accountsDeleteManyArgs>(args?: SelectSubset<T, bank_accountsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bank_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_accountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bank_accountsUpdateManyArgs>(args: SelectSubset<T, bank_accountsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bank_accounts and returns the data updated in the database.
     * @param {bank_accountsUpdateManyAndReturnArgs} args - Arguments to update many Bank_accounts.
     * @example
     * // Update many Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bank_accounts and only return the `id`
     * const bank_accountsWithIdOnly = await prisma.bank_accounts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends bank_accountsUpdateManyAndReturnArgs>(args: SelectSubset<T, bank_accountsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bank_accounts.
     * @param {bank_accountsUpsertArgs} args - Arguments to update or create a Bank_accounts.
     * @example
     * // Update or create a Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.upsert({
     *   create: {
     *     // ... data to create a Bank_accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bank_accounts we want to update
     *   }
     * })
     */
    upsert<T extends bank_accountsUpsertArgs>(args: SelectSubset<T, bank_accountsUpsertArgs<ExtArgs>>): Prisma__bank_accountsClient<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bank_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_accountsCountArgs} args - Arguments to filter Bank_accounts to count.
     * @example
     * // Count the number of Bank_accounts
     * const count = await prisma.bank_accounts.count({
     *   where: {
     *     // ... the filter for the Bank_accounts we want to count
     *   }
     * })
    **/
    count<T extends bank_accountsCountArgs>(
      args?: Subset<T, bank_accountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bank_accountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bank_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bank_accountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bank_accountsAggregateArgs>(args: Subset<T, Bank_accountsAggregateArgs>): Prisma.PrismaPromise<GetBank_accountsAggregateType<T>>

    /**
     * Group by Bank_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_accountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bank_accountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bank_accountsGroupByArgs['orderBy'] }
        : { orderBy?: bank_accountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bank_accountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBank_accountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bank_accounts model
   */
  readonly fields: bank_accountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bank_accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bank_accountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    basiq_user<T extends basiq_usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, basiq_usersDefaultArgs<ExtArgs>>): Prisma__basiq_usersClient<$Result.GetResult<Prisma.$basiq_usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    connection<T extends bank_connectionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bank_connectionsDefaultArgs<ExtArgs>>): Prisma__bank_connectionsClient<$Result.GetResult<Prisma.$bank_connectionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bank_transactions<T extends bank_accounts$bank_transactionsArgs<ExtArgs> = {}>(args?: Subset<T, bank_accounts$bank_transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bank_transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bank_accounts model
   */
  interface bank_accountsFieldRefs {
    readonly id: FieldRef<"bank_accounts", 'String'>
    readonly basiq_user_id: FieldRef<"bank_accounts", 'String'>
    readonly connection_id: FieldRef<"bank_accounts", 'String'>
    readonly basiq_account_id: FieldRef<"bank_accounts", 'String'>
    readonly account_holder: FieldRef<"bank_accounts", 'String'>
    readonly account_number: FieldRef<"bank_accounts", 'String'>
    readonly bsb: FieldRef<"bank_accounts", 'String'>
    readonly institution_name: FieldRef<"bank_accounts", 'String'>
    readonly account_type: FieldRef<"bank_accounts", 'String'>
    readonly account_name: FieldRef<"bank_accounts", 'String'>
    readonly balance_available: FieldRef<"bank_accounts", 'Decimal'>
    readonly balance_current: FieldRef<"bank_accounts", 'Decimal'>
    readonly currency: FieldRef<"bank_accounts", 'String'>
    readonly status: FieldRef<"bank_accounts", 'String'>
    readonly is_business_account: FieldRef<"bank_accounts", 'Boolean'>
    readonly last_synced: FieldRef<"bank_accounts", 'DateTime'>
    readonly created_at: FieldRef<"bank_accounts", 'DateTime'>
    readonly updated_at: FieldRef<"bank_accounts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * bank_accounts findUnique
   */
  export type bank_accountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    /**
     * Filter, which bank_accounts to fetch.
     */
    where: bank_accountsWhereUniqueInput
  }

  /**
   * bank_accounts findUniqueOrThrow
   */
  export type bank_accountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    /**
     * Filter, which bank_accounts to fetch.
     */
    where: bank_accountsWhereUniqueInput
  }

  /**
   * bank_accounts findFirst
   */
  export type bank_accountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    /**
     * Filter, which bank_accounts to fetch.
     */
    where?: bank_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_accounts to fetch.
     */
    orderBy?: bank_accountsOrderByWithRelationInput | bank_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bank_accounts.
     */
    cursor?: bank_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bank_accounts.
     */
    distinct?: Bank_accountsScalarFieldEnum | Bank_accountsScalarFieldEnum[]
  }

  /**
   * bank_accounts findFirstOrThrow
   */
  export type bank_accountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    /**
     * Filter, which bank_accounts to fetch.
     */
    where?: bank_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_accounts to fetch.
     */
    orderBy?: bank_accountsOrderByWithRelationInput | bank_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bank_accounts.
     */
    cursor?: bank_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bank_accounts.
     */
    distinct?: Bank_accountsScalarFieldEnum | Bank_accountsScalarFieldEnum[]
  }

  /**
   * bank_accounts findMany
   */
  export type bank_accountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    /**
     * Filter, which bank_accounts to fetch.
     */
    where?: bank_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_accounts to fetch.
     */
    orderBy?: bank_accountsOrderByWithRelationInput | bank_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bank_accounts.
     */
    cursor?: bank_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_accounts.
     */
    skip?: number
    distinct?: Bank_accountsScalarFieldEnum | Bank_accountsScalarFieldEnum[]
  }

  /**
   * bank_accounts create
   */
  export type bank_accountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    /**
     * The data needed to create a bank_accounts.
     */
    data: XOR<bank_accountsCreateInput, bank_accountsUncheckedCreateInput>
  }

  /**
   * bank_accounts createMany
   */
  export type bank_accountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bank_accounts.
     */
    data: bank_accountsCreateManyInput | bank_accountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bank_accounts createManyAndReturn
   */
  export type bank_accountsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * The data used to create many bank_accounts.
     */
    data: bank_accountsCreateManyInput | bank_accountsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * bank_accounts update
   */
  export type bank_accountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    /**
     * The data needed to update a bank_accounts.
     */
    data: XOR<bank_accountsUpdateInput, bank_accountsUncheckedUpdateInput>
    /**
     * Choose, which bank_accounts to update.
     */
    where: bank_accountsWhereUniqueInput
  }

  /**
   * bank_accounts updateMany
   */
  export type bank_accountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bank_accounts.
     */
    data: XOR<bank_accountsUpdateManyMutationInput, bank_accountsUncheckedUpdateManyInput>
    /**
     * Filter which bank_accounts to update
     */
    where?: bank_accountsWhereInput
    /**
     * Limit how many bank_accounts to update.
     */
    limit?: number
  }

  /**
   * bank_accounts updateManyAndReturn
   */
  export type bank_accountsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * The data used to update bank_accounts.
     */
    data: XOR<bank_accountsUpdateManyMutationInput, bank_accountsUncheckedUpdateManyInput>
    /**
     * Filter which bank_accounts to update
     */
    where?: bank_accountsWhereInput
    /**
     * Limit how many bank_accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * bank_accounts upsert
   */
  export type bank_accountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    /**
     * The filter to search for the bank_accounts to update in case it exists.
     */
    where: bank_accountsWhereUniqueInput
    /**
     * In case the bank_accounts found by the `where` argument doesn't exist, create a new bank_accounts with this data.
     */
    create: XOR<bank_accountsCreateInput, bank_accountsUncheckedCreateInput>
    /**
     * In case the bank_accounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bank_accountsUpdateInput, bank_accountsUncheckedUpdateInput>
  }

  /**
   * bank_accounts delete
   */
  export type bank_accountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    /**
     * Filter which bank_accounts to delete.
     */
    where: bank_accountsWhereUniqueInput
  }

  /**
   * bank_accounts deleteMany
   */
  export type bank_accountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bank_accounts to delete
     */
    where?: bank_accountsWhereInput
    /**
     * Limit how many bank_accounts to delete.
     */
    limit?: number
  }

  /**
   * bank_accounts.bank_transactions
   */
  export type bank_accounts$bank_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_transactions
     */
    select?: bank_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_transactions
     */
    omit?: bank_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_transactionsInclude<ExtArgs> | null
    where?: bank_transactionsWhereInput
    orderBy?: bank_transactionsOrderByWithRelationInput | bank_transactionsOrderByWithRelationInput[]
    cursor?: bank_transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bank_transactionsScalarFieldEnum | Bank_transactionsScalarFieldEnum[]
  }

  /**
   * bank_accounts without action
   */
  export type bank_accountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
  }


  /**
   * Model bank_transactions
   */

  export type AggregateBank_transactions = {
    _count: Bank_transactionsCountAggregateOutputType | null
    _avg: Bank_transactionsAvgAggregateOutputType | null
    _sum: Bank_transactionsSumAggregateOutputType | null
    _min: Bank_transactionsMinAggregateOutputType | null
    _max: Bank_transactionsMaxAggregateOutputType | null
  }

  export type Bank_transactionsAvgAggregateOutputType = {
    amount: Decimal | null
    balance: Decimal | null
    gst_amount: Decimal | null
  }

  export type Bank_transactionsSumAggregateOutputType = {
    amount: Decimal | null
    balance: Decimal | null
    gst_amount: Decimal | null
  }

  export type Bank_transactionsMinAggregateOutputType = {
    id: string | null
    bank_account_id: string | null
    basiq_transaction_id: string | null
    description: string | null
    amount: Decimal | null
    transaction_date: Date | null
    post_date: Date | null
    balance: Decimal | null
    transaction_type: string | null
    direction: string | null
    category: string | null
    subcategory: string | null
    merchant_name: string | null
    status: string | null
    is_business_expense: boolean | null
    tax_category: string | null
    gst_amount: Decimal | null
    receipt_id: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bank_transactionsMaxAggregateOutputType = {
    id: string | null
    bank_account_id: string | null
    basiq_transaction_id: string | null
    description: string | null
    amount: Decimal | null
    transaction_date: Date | null
    post_date: Date | null
    balance: Decimal | null
    transaction_type: string | null
    direction: string | null
    category: string | null
    subcategory: string | null
    merchant_name: string | null
    status: string | null
    is_business_expense: boolean | null
    tax_category: string | null
    gst_amount: Decimal | null
    receipt_id: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bank_transactionsCountAggregateOutputType = {
    id: number
    bank_account_id: number
    basiq_transaction_id: number
    description: number
    amount: number
    transaction_date: number
    post_date: number
    balance: number
    transaction_type: number
    direction: number
    category: number
    subcategory: number
    merchant_name: number
    status: number
    is_business_expense: number
    tax_category: number
    gst_amount: number
    receipt_id: number
    notes: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Bank_transactionsAvgAggregateInputType = {
    amount?: true
    balance?: true
    gst_amount?: true
  }

  export type Bank_transactionsSumAggregateInputType = {
    amount?: true
    balance?: true
    gst_amount?: true
  }

  export type Bank_transactionsMinAggregateInputType = {
    id?: true
    bank_account_id?: true
    basiq_transaction_id?: true
    description?: true
    amount?: true
    transaction_date?: true
    post_date?: true
    balance?: true
    transaction_type?: true
    direction?: true
    category?: true
    subcategory?: true
    merchant_name?: true
    status?: true
    is_business_expense?: true
    tax_category?: true
    gst_amount?: true
    receipt_id?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type Bank_transactionsMaxAggregateInputType = {
    id?: true
    bank_account_id?: true
    basiq_transaction_id?: true
    description?: true
    amount?: true
    transaction_date?: true
    post_date?: true
    balance?: true
    transaction_type?: true
    direction?: true
    category?: true
    subcategory?: true
    merchant_name?: true
    status?: true
    is_business_expense?: true
    tax_category?: true
    gst_amount?: true
    receipt_id?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type Bank_transactionsCountAggregateInputType = {
    id?: true
    bank_account_id?: true
    basiq_transaction_id?: true
    description?: true
    amount?: true
    transaction_date?: true
    post_date?: true
    balance?: true
    transaction_type?: true
    direction?: true
    category?: true
    subcategory?: true
    merchant_name?: true
    status?: true
    is_business_expense?: true
    tax_category?: true
    gst_amount?: true
    receipt_id?: true
    notes?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Bank_transactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bank_transactions to aggregate.
     */
    where?: bank_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_transactions to fetch.
     */
    orderBy?: bank_transactionsOrderByWithRelationInput | bank_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bank_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bank_transactions
    **/
    _count?: true | Bank_transactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bank_transactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bank_transactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bank_transactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bank_transactionsMaxAggregateInputType
  }

  export type GetBank_transactionsAggregateType<T extends Bank_transactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateBank_transactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBank_transactions[P]>
      : GetScalarType<T[P], AggregateBank_transactions[P]>
  }




  export type bank_transactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bank_transactionsWhereInput
    orderBy?: bank_transactionsOrderByWithAggregationInput | bank_transactionsOrderByWithAggregationInput[]
    by: Bank_transactionsScalarFieldEnum[] | Bank_transactionsScalarFieldEnum
    having?: bank_transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bank_transactionsCountAggregateInputType | true
    _avg?: Bank_transactionsAvgAggregateInputType
    _sum?: Bank_transactionsSumAggregateInputType
    _min?: Bank_transactionsMinAggregateInputType
    _max?: Bank_transactionsMaxAggregateInputType
  }

  export type Bank_transactionsGroupByOutputType = {
    id: string
    bank_account_id: string
    basiq_transaction_id: string
    description: string | null
    amount: Decimal
    transaction_date: Date
    post_date: Date | null
    balance: Decimal | null
    transaction_type: string | null
    direction: string | null
    category: string | null
    subcategory: string | null
    merchant_name: string | null
    status: string | null
    is_business_expense: boolean
    tax_category: string | null
    gst_amount: Decimal | null
    receipt_id: string | null
    notes: string | null
    created_at: Date
    updated_at: Date
    _count: Bank_transactionsCountAggregateOutputType | null
    _avg: Bank_transactionsAvgAggregateOutputType | null
    _sum: Bank_transactionsSumAggregateOutputType | null
    _min: Bank_transactionsMinAggregateOutputType | null
    _max: Bank_transactionsMaxAggregateOutputType | null
  }

  type GetBank_transactionsGroupByPayload<T extends bank_transactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bank_transactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bank_transactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bank_transactionsGroupByOutputType[P]>
            : GetScalarType<T[P], Bank_transactionsGroupByOutputType[P]>
        }
      >
    >


  export type bank_transactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bank_account_id?: boolean
    basiq_transaction_id?: boolean
    description?: boolean
    amount?: boolean
    transaction_date?: boolean
    post_date?: boolean
    balance?: boolean
    transaction_type?: boolean
    direction?: boolean
    category?: boolean
    subcategory?: boolean
    merchant_name?: boolean
    status?: boolean
    is_business_expense?: boolean
    tax_category?: boolean
    gst_amount?: boolean
    receipt_id?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    bank_account?: boolean | bank_accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bank_transactions"]>

  export type bank_transactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bank_account_id?: boolean
    basiq_transaction_id?: boolean
    description?: boolean
    amount?: boolean
    transaction_date?: boolean
    post_date?: boolean
    balance?: boolean
    transaction_type?: boolean
    direction?: boolean
    category?: boolean
    subcategory?: boolean
    merchant_name?: boolean
    status?: boolean
    is_business_expense?: boolean
    tax_category?: boolean
    gst_amount?: boolean
    receipt_id?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    bank_account?: boolean | bank_accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bank_transactions"]>

  export type bank_transactionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bank_account_id?: boolean
    basiq_transaction_id?: boolean
    description?: boolean
    amount?: boolean
    transaction_date?: boolean
    post_date?: boolean
    balance?: boolean
    transaction_type?: boolean
    direction?: boolean
    category?: boolean
    subcategory?: boolean
    merchant_name?: boolean
    status?: boolean
    is_business_expense?: boolean
    tax_category?: boolean
    gst_amount?: boolean
    receipt_id?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    bank_account?: boolean | bank_accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bank_transactions"]>

  export type bank_transactionsSelectScalar = {
    id?: boolean
    bank_account_id?: boolean
    basiq_transaction_id?: boolean
    description?: boolean
    amount?: boolean
    transaction_date?: boolean
    post_date?: boolean
    balance?: boolean
    transaction_type?: boolean
    direction?: boolean
    category?: boolean
    subcategory?: boolean
    merchant_name?: boolean
    status?: boolean
    is_business_expense?: boolean
    tax_category?: boolean
    gst_amount?: boolean
    receipt_id?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type bank_transactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bank_account_id" | "basiq_transaction_id" | "description" | "amount" | "transaction_date" | "post_date" | "balance" | "transaction_type" | "direction" | "category" | "subcategory" | "merchant_name" | "status" | "is_business_expense" | "tax_category" | "gst_amount" | "receipt_id" | "notes" | "created_at" | "updated_at", ExtArgs["result"]["bank_transactions"]>
  export type bank_transactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bank_account?: boolean | bank_accountsDefaultArgs<ExtArgs>
  }
  export type bank_transactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bank_account?: boolean | bank_accountsDefaultArgs<ExtArgs>
  }
  export type bank_transactionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bank_account?: boolean | bank_accountsDefaultArgs<ExtArgs>
  }

  export type $bank_transactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bank_transactions"
    objects: {
      bank_account: Prisma.$bank_accountsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bank_account_id: string
      basiq_transaction_id: string
      description: string | null
      amount: Prisma.Decimal
      transaction_date: Date
      post_date: Date | null
      balance: Prisma.Decimal | null
      transaction_type: string | null
      direction: string | null
      category: string | null
      subcategory: string | null
      merchant_name: string | null
      status: string | null
      is_business_expense: boolean
      tax_category: string | null
      gst_amount: Prisma.Decimal | null
      receipt_id: string | null
      notes: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["bank_transactions"]>
    composites: {}
  }

  type bank_transactionsGetPayload<S extends boolean | null | undefined | bank_transactionsDefaultArgs> = $Result.GetResult<Prisma.$bank_transactionsPayload, S>

  type bank_transactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bank_transactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Bank_transactionsCountAggregateInputType | true
    }

  export interface bank_transactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bank_transactions'], meta: { name: 'bank_transactions' } }
    /**
     * Find zero or one Bank_transactions that matches the filter.
     * @param {bank_transactionsFindUniqueArgs} args - Arguments to find a Bank_transactions
     * @example
     * // Get one Bank_transactions
     * const bank_transactions = await prisma.bank_transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bank_transactionsFindUniqueArgs>(args: SelectSubset<T, bank_transactionsFindUniqueArgs<ExtArgs>>): Prisma__bank_transactionsClient<$Result.GetResult<Prisma.$bank_transactionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bank_transactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bank_transactionsFindUniqueOrThrowArgs} args - Arguments to find a Bank_transactions
     * @example
     * // Get one Bank_transactions
     * const bank_transactions = await prisma.bank_transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bank_transactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, bank_transactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bank_transactionsClient<$Result.GetResult<Prisma.$bank_transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bank_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_transactionsFindFirstArgs} args - Arguments to find a Bank_transactions
     * @example
     * // Get one Bank_transactions
     * const bank_transactions = await prisma.bank_transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bank_transactionsFindFirstArgs>(args?: SelectSubset<T, bank_transactionsFindFirstArgs<ExtArgs>>): Prisma__bank_transactionsClient<$Result.GetResult<Prisma.$bank_transactionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bank_transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_transactionsFindFirstOrThrowArgs} args - Arguments to find a Bank_transactions
     * @example
     * // Get one Bank_transactions
     * const bank_transactions = await prisma.bank_transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bank_transactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, bank_transactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__bank_transactionsClient<$Result.GetResult<Prisma.$bank_transactionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bank_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_transactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bank_transactions
     * const bank_transactions = await prisma.bank_transactions.findMany()
     * 
     * // Get first 10 Bank_transactions
     * const bank_transactions = await prisma.bank_transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bank_transactionsWithIdOnly = await prisma.bank_transactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bank_transactionsFindManyArgs>(args?: SelectSubset<T, bank_transactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bank_transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bank_transactions.
     * @param {bank_transactionsCreateArgs} args - Arguments to create a Bank_transactions.
     * @example
     * // Create one Bank_transactions
     * const Bank_transactions = await prisma.bank_transactions.create({
     *   data: {
     *     // ... data to create a Bank_transactions
     *   }
     * })
     * 
     */
    create<T extends bank_transactionsCreateArgs>(args: SelectSubset<T, bank_transactionsCreateArgs<ExtArgs>>): Prisma__bank_transactionsClient<$Result.GetResult<Prisma.$bank_transactionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bank_transactions.
     * @param {bank_transactionsCreateManyArgs} args - Arguments to create many Bank_transactions.
     * @example
     * // Create many Bank_transactions
     * const bank_transactions = await prisma.bank_transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bank_transactionsCreateManyArgs>(args?: SelectSubset<T, bank_transactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bank_transactions and returns the data saved in the database.
     * @param {bank_transactionsCreateManyAndReturnArgs} args - Arguments to create many Bank_transactions.
     * @example
     * // Create many Bank_transactions
     * const bank_transactions = await prisma.bank_transactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bank_transactions and only return the `id`
     * const bank_transactionsWithIdOnly = await prisma.bank_transactions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends bank_transactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, bank_transactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bank_transactionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bank_transactions.
     * @param {bank_transactionsDeleteArgs} args - Arguments to delete one Bank_transactions.
     * @example
     * // Delete one Bank_transactions
     * const Bank_transactions = await prisma.bank_transactions.delete({
     *   where: {
     *     // ... filter to delete one Bank_transactions
     *   }
     * })
     * 
     */
    delete<T extends bank_transactionsDeleteArgs>(args: SelectSubset<T, bank_transactionsDeleteArgs<ExtArgs>>): Prisma__bank_transactionsClient<$Result.GetResult<Prisma.$bank_transactionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bank_transactions.
     * @param {bank_transactionsUpdateArgs} args - Arguments to update one Bank_transactions.
     * @example
     * // Update one Bank_transactions
     * const bank_transactions = await prisma.bank_transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bank_transactionsUpdateArgs>(args: SelectSubset<T, bank_transactionsUpdateArgs<ExtArgs>>): Prisma__bank_transactionsClient<$Result.GetResult<Prisma.$bank_transactionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bank_transactions.
     * @param {bank_transactionsDeleteManyArgs} args - Arguments to filter Bank_transactions to delete.
     * @example
     * // Delete a few Bank_transactions
     * const { count } = await prisma.bank_transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bank_transactionsDeleteManyArgs>(args?: SelectSubset<T, bank_transactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bank_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bank_transactions
     * const bank_transactions = await prisma.bank_transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bank_transactionsUpdateManyArgs>(args: SelectSubset<T, bank_transactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bank_transactions and returns the data updated in the database.
     * @param {bank_transactionsUpdateManyAndReturnArgs} args - Arguments to update many Bank_transactions.
     * @example
     * // Update many Bank_transactions
     * const bank_transactions = await prisma.bank_transactions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bank_transactions and only return the `id`
     * const bank_transactionsWithIdOnly = await prisma.bank_transactions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends bank_transactionsUpdateManyAndReturnArgs>(args: SelectSubset<T, bank_transactionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bank_transactionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bank_transactions.
     * @param {bank_transactionsUpsertArgs} args - Arguments to update or create a Bank_transactions.
     * @example
     * // Update or create a Bank_transactions
     * const bank_transactions = await prisma.bank_transactions.upsert({
     *   create: {
     *     // ... data to create a Bank_transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bank_transactions we want to update
     *   }
     * })
     */
    upsert<T extends bank_transactionsUpsertArgs>(args: SelectSubset<T, bank_transactionsUpsertArgs<ExtArgs>>): Prisma__bank_transactionsClient<$Result.GetResult<Prisma.$bank_transactionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bank_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_transactionsCountArgs} args - Arguments to filter Bank_transactions to count.
     * @example
     * // Count the number of Bank_transactions
     * const count = await prisma.bank_transactions.count({
     *   where: {
     *     // ... the filter for the Bank_transactions we want to count
     *   }
     * })
    **/
    count<T extends bank_transactionsCountArgs>(
      args?: Subset<T, bank_transactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bank_transactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bank_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bank_transactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bank_transactionsAggregateArgs>(args: Subset<T, Bank_transactionsAggregateArgs>): Prisma.PrismaPromise<GetBank_transactionsAggregateType<T>>

    /**
     * Group by Bank_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bank_transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bank_transactionsGroupByArgs['orderBy'] }
        : { orderBy?: bank_transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bank_transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBank_transactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bank_transactions model
   */
  readonly fields: bank_transactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bank_transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bank_transactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bank_account<T extends bank_accountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bank_accountsDefaultArgs<ExtArgs>>): Prisma__bank_accountsClient<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bank_transactions model
   */
  interface bank_transactionsFieldRefs {
    readonly id: FieldRef<"bank_transactions", 'String'>
    readonly bank_account_id: FieldRef<"bank_transactions", 'String'>
    readonly basiq_transaction_id: FieldRef<"bank_transactions", 'String'>
    readonly description: FieldRef<"bank_transactions", 'String'>
    readonly amount: FieldRef<"bank_transactions", 'Decimal'>
    readonly transaction_date: FieldRef<"bank_transactions", 'DateTime'>
    readonly post_date: FieldRef<"bank_transactions", 'DateTime'>
    readonly balance: FieldRef<"bank_transactions", 'Decimal'>
    readonly transaction_type: FieldRef<"bank_transactions", 'String'>
    readonly direction: FieldRef<"bank_transactions", 'String'>
    readonly category: FieldRef<"bank_transactions", 'String'>
    readonly subcategory: FieldRef<"bank_transactions", 'String'>
    readonly merchant_name: FieldRef<"bank_transactions", 'String'>
    readonly status: FieldRef<"bank_transactions", 'String'>
    readonly is_business_expense: FieldRef<"bank_transactions", 'Boolean'>
    readonly tax_category: FieldRef<"bank_transactions", 'String'>
    readonly gst_amount: FieldRef<"bank_transactions", 'Decimal'>
    readonly receipt_id: FieldRef<"bank_transactions", 'String'>
    readonly notes: FieldRef<"bank_transactions", 'String'>
    readonly created_at: FieldRef<"bank_transactions", 'DateTime'>
    readonly updated_at: FieldRef<"bank_transactions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * bank_transactions findUnique
   */
  export type bank_transactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_transactions
     */
    select?: bank_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_transactions
     */
    omit?: bank_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which bank_transactions to fetch.
     */
    where: bank_transactionsWhereUniqueInput
  }

  /**
   * bank_transactions findUniqueOrThrow
   */
  export type bank_transactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_transactions
     */
    select?: bank_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_transactions
     */
    omit?: bank_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which bank_transactions to fetch.
     */
    where: bank_transactionsWhereUniqueInput
  }

  /**
   * bank_transactions findFirst
   */
  export type bank_transactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_transactions
     */
    select?: bank_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_transactions
     */
    omit?: bank_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which bank_transactions to fetch.
     */
    where?: bank_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_transactions to fetch.
     */
    orderBy?: bank_transactionsOrderByWithRelationInput | bank_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bank_transactions.
     */
    cursor?: bank_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bank_transactions.
     */
    distinct?: Bank_transactionsScalarFieldEnum | Bank_transactionsScalarFieldEnum[]
  }

  /**
   * bank_transactions findFirstOrThrow
   */
  export type bank_transactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_transactions
     */
    select?: bank_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_transactions
     */
    omit?: bank_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which bank_transactions to fetch.
     */
    where?: bank_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_transactions to fetch.
     */
    orderBy?: bank_transactionsOrderByWithRelationInput | bank_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bank_transactions.
     */
    cursor?: bank_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bank_transactions.
     */
    distinct?: Bank_transactionsScalarFieldEnum | Bank_transactionsScalarFieldEnum[]
  }

  /**
   * bank_transactions findMany
   */
  export type bank_transactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_transactions
     */
    select?: bank_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_transactions
     */
    omit?: bank_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which bank_transactions to fetch.
     */
    where?: bank_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_transactions to fetch.
     */
    orderBy?: bank_transactionsOrderByWithRelationInput | bank_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bank_transactions.
     */
    cursor?: bank_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_transactions.
     */
    skip?: number
    distinct?: Bank_transactionsScalarFieldEnum | Bank_transactionsScalarFieldEnum[]
  }

  /**
   * bank_transactions create
   */
  export type bank_transactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_transactions
     */
    select?: bank_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_transactions
     */
    omit?: bank_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_transactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a bank_transactions.
     */
    data: XOR<bank_transactionsCreateInput, bank_transactionsUncheckedCreateInput>
  }

  /**
   * bank_transactions createMany
   */
  export type bank_transactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bank_transactions.
     */
    data: bank_transactionsCreateManyInput | bank_transactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bank_transactions createManyAndReturn
   */
  export type bank_transactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_transactions
     */
    select?: bank_transactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bank_transactions
     */
    omit?: bank_transactionsOmit<ExtArgs> | null
    /**
     * The data used to create many bank_transactions.
     */
    data: bank_transactionsCreateManyInput | bank_transactionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_transactionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * bank_transactions update
   */
  export type bank_transactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_transactions
     */
    select?: bank_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_transactions
     */
    omit?: bank_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_transactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a bank_transactions.
     */
    data: XOR<bank_transactionsUpdateInput, bank_transactionsUncheckedUpdateInput>
    /**
     * Choose, which bank_transactions to update.
     */
    where: bank_transactionsWhereUniqueInput
  }

  /**
   * bank_transactions updateMany
   */
  export type bank_transactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bank_transactions.
     */
    data: XOR<bank_transactionsUpdateManyMutationInput, bank_transactionsUncheckedUpdateManyInput>
    /**
     * Filter which bank_transactions to update
     */
    where?: bank_transactionsWhereInput
    /**
     * Limit how many bank_transactions to update.
     */
    limit?: number
  }

  /**
   * bank_transactions updateManyAndReturn
   */
  export type bank_transactionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_transactions
     */
    select?: bank_transactionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bank_transactions
     */
    omit?: bank_transactionsOmit<ExtArgs> | null
    /**
     * The data used to update bank_transactions.
     */
    data: XOR<bank_transactionsUpdateManyMutationInput, bank_transactionsUncheckedUpdateManyInput>
    /**
     * Filter which bank_transactions to update
     */
    where?: bank_transactionsWhereInput
    /**
     * Limit how many bank_transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_transactionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * bank_transactions upsert
   */
  export type bank_transactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_transactions
     */
    select?: bank_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_transactions
     */
    omit?: bank_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_transactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the bank_transactions to update in case it exists.
     */
    where: bank_transactionsWhereUniqueInput
    /**
     * In case the bank_transactions found by the `where` argument doesn't exist, create a new bank_transactions with this data.
     */
    create: XOR<bank_transactionsCreateInput, bank_transactionsUncheckedCreateInput>
    /**
     * In case the bank_transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bank_transactionsUpdateInput, bank_transactionsUncheckedUpdateInput>
  }

  /**
   * bank_transactions delete
   */
  export type bank_transactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_transactions
     */
    select?: bank_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_transactions
     */
    omit?: bank_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_transactionsInclude<ExtArgs> | null
    /**
     * Filter which bank_transactions to delete.
     */
    where: bank_transactionsWhereUniqueInput
  }

  /**
   * bank_transactions deleteMany
   */
  export type bank_transactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bank_transactions to delete
     */
    where?: bank_transactionsWhereInput
    /**
     * Limit how many bank_transactions to delete.
     */
    limit?: number
  }

  /**
   * bank_transactions without action
   */
  export type bank_transactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_transactions
     */
    select?: bank_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_transactions
     */
    omit?: bank_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_transactionsInclude<ExtArgs> | null
  }


  /**
   * Model basiq_webhooks
   */

  export type AggregateBasiq_webhooks = {
    _count: Basiq_webhooksCountAggregateOutputType | null
    _avg: Basiq_webhooksAvgAggregateOutputType | null
    _sum: Basiq_webhooksSumAggregateOutputType | null
    _min: Basiq_webhooksMinAggregateOutputType | null
    _max: Basiq_webhooksMaxAggregateOutputType | null
  }

  export type Basiq_webhooksAvgAggregateOutputType = {
    retry_count: number | null
  }

  export type Basiq_webhooksSumAggregateOutputType = {
    retry_count: number | null
  }

  export type Basiq_webhooksMinAggregateOutputType = {
    id: string | null
    webhook_id: string | null
    event_type: string | null
    resource_type: string | null
    resource_id: string | null
    status: string | null
    processed_at: Date | null
    error_message: string | null
    retry_count: number | null
    created_at: Date | null
  }

  export type Basiq_webhooksMaxAggregateOutputType = {
    id: string | null
    webhook_id: string | null
    event_type: string | null
    resource_type: string | null
    resource_id: string | null
    status: string | null
    processed_at: Date | null
    error_message: string | null
    retry_count: number | null
    created_at: Date | null
  }

  export type Basiq_webhooksCountAggregateOutputType = {
    id: number
    webhook_id: number
    event_type: number
    resource_type: number
    resource_id: number
    payload: number
    status: number
    processed_at: number
    error_message: number
    retry_count: number
    created_at: number
    _all: number
  }


  export type Basiq_webhooksAvgAggregateInputType = {
    retry_count?: true
  }

  export type Basiq_webhooksSumAggregateInputType = {
    retry_count?: true
  }

  export type Basiq_webhooksMinAggregateInputType = {
    id?: true
    webhook_id?: true
    event_type?: true
    resource_type?: true
    resource_id?: true
    status?: true
    processed_at?: true
    error_message?: true
    retry_count?: true
    created_at?: true
  }

  export type Basiq_webhooksMaxAggregateInputType = {
    id?: true
    webhook_id?: true
    event_type?: true
    resource_type?: true
    resource_id?: true
    status?: true
    processed_at?: true
    error_message?: true
    retry_count?: true
    created_at?: true
  }

  export type Basiq_webhooksCountAggregateInputType = {
    id?: true
    webhook_id?: true
    event_type?: true
    resource_type?: true
    resource_id?: true
    payload?: true
    status?: true
    processed_at?: true
    error_message?: true
    retry_count?: true
    created_at?: true
    _all?: true
  }

  export type Basiq_webhooksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which basiq_webhooks to aggregate.
     */
    where?: basiq_webhooksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basiq_webhooks to fetch.
     */
    orderBy?: basiq_webhooksOrderByWithRelationInput | basiq_webhooksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: basiq_webhooksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basiq_webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basiq_webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned basiq_webhooks
    **/
    _count?: true | Basiq_webhooksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Basiq_webhooksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Basiq_webhooksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Basiq_webhooksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Basiq_webhooksMaxAggregateInputType
  }

  export type GetBasiq_webhooksAggregateType<T extends Basiq_webhooksAggregateArgs> = {
        [P in keyof T & keyof AggregateBasiq_webhooks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBasiq_webhooks[P]>
      : GetScalarType<T[P], AggregateBasiq_webhooks[P]>
  }




  export type basiq_webhooksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: basiq_webhooksWhereInput
    orderBy?: basiq_webhooksOrderByWithAggregationInput | basiq_webhooksOrderByWithAggregationInput[]
    by: Basiq_webhooksScalarFieldEnum[] | Basiq_webhooksScalarFieldEnum
    having?: basiq_webhooksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Basiq_webhooksCountAggregateInputType | true
    _avg?: Basiq_webhooksAvgAggregateInputType
    _sum?: Basiq_webhooksSumAggregateInputType
    _min?: Basiq_webhooksMinAggregateInputType
    _max?: Basiq_webhooksMaxAggregateInputType
  }

  export type Basiq_webhooksGroupByOutputType = {
    id: string
    webhook_id: string | null
    event_type: string
    resource_type: string | null
    resource_id: string | null
    payload: JsonValue
    status: string | null
    processed_at: Date | null
    error_message: string | null
    retry_count: number
    created_at: Date
    _count: Basiq_webhooksCountAggregateOutputType | null
    _avg: Basiq_webhooksAvgAggregateOutputType | null
    _sum: Basiq_webhooksSumAggregateOutputType | null
    _min: Basiq_webhooksMinAggregateOutputType | null
    _max: Basiq_webhooksMaxAggregateOutputType | null
  }

  type GetBasiq_webhooksGroupByPayload<T extends basiq_webhooksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Basiq_webhooksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Basiq_webhooksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Basiq_webhooksGroupByOutputType[P]>
            : GetScalarType<T[P], Basiq_webhooksGroupByOutputType[P]>
        }
      >
    >


  export type basiq_webhooksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhook_id?: boolean
    event_type?: boolean
    resource_type?: boolean
    resource_id?: boolean
    payload?: boolean
    status?: boolean
    processed_at?: boolean
    error_message?: boolean
    retry_count?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["basiq_webhooks"]>

  export type basiq_webhooksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhook_id?: boolean
    event_type?: boolean
    resource_type?: boolean
    resource_id?: boolean
    payload?: boolean
    status?: boolean
    processed_at?: boolean
    error_message?: boolean
    retry_count?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["basiq_webhooks"]>

  export type basiq_webhooksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhook_id?: boolean
    event_type?: boolean
    resource_type?: boolean
    resource_id?: boolean
    payload?: boolean
    status?: boolean
    processed_at?: boolean
    error_message?: boolean
    retry_count?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["basiq_webhooks"]>

  export type basiq_webhooksSelectScalar = {
    id?: boolean
    webhook_id?: boolean
    event_type?: boolean
    resource_type?: boolean
    resource_id?: boolean
    payload?: boolean
    status?: boolean
    processed_at?: boolean
    error_message?: boolean
    retry_count?: boolean
    created_at?: boolean
  }

  export type basiq_webhooksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "webhook_id" | "event_type" | "resource_type" | "resource_id" | "payload" | "status" | "processed_at" | "error_message" | "retry_count" | "created_at", ExtArgs["result"]["basiq_webhooks"]>

  export type $basiq_webhooksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "basiq_webhooks"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      webhook_id: string | null
      event_type: string
      resource_type: string | null
      resource_id: string | null
      payload: Prisma.JsonValue
      status: string | null
      processed_at: Date | null
      error_message: string | null
      retry_count: number
      created_at: Date
    }, ExtArgs["result"]["basiq_webhooks"]>
    composites: {}
  }

  type basiq_webhooksGetPayload<S extends boolean | null | undefined | basiq_webhooksDefaultArgs> = $Result.GetResult<Prisma.$basiq_webhooksPayload, S>

  type basiq_webhooksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<basiq_webhooksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Basiq_webhooksCountAggregateInputType | true
    }

  export interface basiq_webhooksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['basiq_webhooks'], meta: { name: 'basiq_webhooks' } }
    /**
     * Find zero or one Basiq_webhooks that matches the filter.
     * @param {basiq_webhooksFindUniqueArgs} args - Arguments to find a Basiq_webhooks
     * @example
     * // Get one Basiq_webhooks
     * const basiq_webhooks = await prisma.basiq_webhooks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends basiq_webhooksFindUniqueArgs>(args: SelectSubset<T, basiq_webhooksFindUniqueArgs<ExtArgs>>): Prisma__basiq_webhooksClient<$Result.GetResult<Prisma.$basiq_webhooksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Basiq_webhooks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {basiq_webhooksFindUniqueOrThrowArgs} args - Arguments to find a Basiq_webhooks
     * @example
     * // Get one Basiq_webhooks
     * const basiq_webhooks = await prisma.basiq_webhooks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends basiq_webhooksFindUniqueOrThrowArgs>(args: SelectSubset<T, basiq_webhooksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__basiq_webhooksClient<$Result.GetResult<Prisma.$basiq_webhooksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Basiq_webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basiq_webhooksFindFirstArgs} args - Arguments to find a Basiq_webhooks
     * @example
     * // Get one Basiq_webhooks
     * const basiq_webhooks = await prisma.basiq_webhooks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends basiq_webhooksFindFirstArgs>(args?: SelectSubset<T, basiq_webhooksFindFirstArgs<ExtArgs>>): Prisma__basiq_webhooksClient<$Result.GetResult<Prisma.$basiq_webhooksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Basiq_webhooks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basiq_webhooksFindFirstOrThrowArgs} args - Arguments to find a Basiq_webhooks
     * @example
     * // Get one Basiq_webhooks
     * const basiq_webhooks = await prisma.basiq_webhooks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends basiq_webhooksFindFirstOrThrowArgs>(args?: SelectSubset<T, basiq_webhooksFindFirstOrThrowArgs<ExtArgs>>): Prisma__basiq_webhooksClient<$Result.GetResult<Prisma.$basiq_webhooksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Basiq_webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basiq_webhooksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Basiq_webhooks
     * const basiq_webhooks = await prisma.basiq_webhooks.findMany()
     * 
     * // Get first 10 Basiq_webhooks
     * const basiq_webhooks = await prisma.basiq_webhooks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const basiq_webhooksWithIdOnly = await prisma.basiq_webhooks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends basiq_webhooksFindManyArgs>(args?: SelectSubset<T, basiq_webhooksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$basiq_webhooksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Basiq_webhooks.
     * @param {basiq_webhooksCreateArgs} args - Arguments to create a Basiq_webhooks.
     * @example
     * // Create one Basiq_webhooks
     * const Basiq_webhooks = await prisma.basiq_webhooks.create({
     *   data: {
     *     // ... data to create a Basiq_webhooks
     *   }
     * })
     * 
     */
    create<T extends basiq_webhooksCreateArgs>(args: SelectSubset<T, basiq_webhooksCreateArgs<ExtArgs>>): Prisma__basiq_webhooksClient<$Result.GetResult<Prisma.$basiq_webhooksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Basiq_webhooks.
     * @param {basiq_webhooksCreateManyArgs} args - Arguments to create many Basiq_webhooks.
     * @example
     * // Create many Basiq_webhooks
     * const basiq_webhooks = await prisma.basiq_webhooks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends basiq_webhooksCreateManyArgs>(args?: SelectSubset<T, basiq_webhooksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Basiq_webhooks and returns the data saved in the database.
     * @param {basiq_webhooksCreateManyAndReturnArgs} args - Arguments to create many Basiq_webhooks.
     * @example
     * // Create many Basiq_webhooks
     * const basiq_webhooks = await prisma.basiq_webhooks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Basiq_webhooks and only return the `id`
     * const basiq_webhooksWithIdOnly = await prisma.basiq_webhooks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends basiq_webhooksCreateManyAndReturnArgs>(args?: SelectSubset<T, basiq_webhooksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$basiq_webhooksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Basiq_webhooks.
     * @param {basiq_webhooksDeleteArgs} args - Arguments to delete one Basiq_webhooks.
     * @example
     * // Delete one Basiq_webhooks
     * const Basiq_webhooks = await prisma.basiq_webhooks.delete({
     *   where: {
     *     // ... filter to delete one Basiq_webhooks
     *   }
     * })
     * 
     */
    delete<T extends basiq_webhooksDeleteArgs>(args: SelectSubset<T, basiq_webhooksDeleteArgs<ExtArgs>>): Prisma__basiq_webhooksClient<$Result.GetResult<Prisma.$basiq_webhooksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Basiq_webhooks.
     * @param {basiq_webhooksUpdateArgs} args - Arguments to update one Basiq_webhooks.
     * @example
     * // Update one Basiq_webhooks
     * const basiq_webhooks = await prisma.basiq_webhooks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends basiq_webhooksUpdateArgs>(args: SelectSubset<T, basiq_webhooksUpdateArgs<ExtArgs>>): Prisma__basiq_webhooksClient<$Result.GetResult<Prisma.$basiq_webhooksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Basiq_webhooks.
     * @param {basiq_webhooksDeleteManyArgs} args - Arguments to filter Basiq_webhooks to delete.
     * @example
     * // Delete a few Basiq_webhooks
     * const { count } = await prisma.basiq_webhooks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends basiq_webhooksDeleteManyArgs>(args?: SelectSubset<T, basiq_webhooksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Basiq_webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basiq_webhooksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Basiq_webhooks
     * const basiq_webhooks = await prisma.basiq_webhooks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends basiq_webhooksUpdateManyArgs>(args: SelectSubset<T, basiq_webhooksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Basiq_webhooks and returns the data updated in the database.
     * @param {basiq_webhooksUpdateManyAndReturnArgs} args - Arguments to update many Basiq_webhooks.
     * @example
     * // Update many Basiq_webhooks
     * const basiq_webhooks = await prisma.basiq_webhooks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Basiq_webhooks and only return the `id`
     * const basiq_webhooksWithIdOnly = await prisma.basiq_webhooks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends basiq_webhooksUpdateManyAndReturnArgs>(args: SelectSubset<T, basiq_webhooksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$basiq_webhooksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Basiq_webhooks.
     * @param {basiq_webhooksUpsertArgs} args - Arguments to update or create a Basiq_webhooks.
     * @example
     * // Update or create a Basiq_webhooks
     * const basiq_webhooks = await prisma.basiq_webhooks.upsert({
     *   create: {
     *     // ... data to create a Basiq_webhooks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Basiq_webhooks we want to update
     *   }
     * })
     */
    upsert<T extends basiq_webhooksUpsertArgs>(args: SelectSubset<T, basiq_webhooksUpsertArgs<ExtArgs>>): Prisma__basiq_webhooksClient<$Result.GetResult<Prisma.$basiq_webhooksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Basiq_webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basiq_webhooksCountArgs} args - Arguments to filter Basiq_webhooks to count.
     * @example
     * // Count the number of Basiq_webhooks
     * const count = await prisma.basiq_webhooks.count({
     *   where: {
     *     // ... the filter for the Basiq_webhooks we want to count
     *   }
     * })
    **/
    count<T extends basiq_webhooksCountArgs>(
      args?: Subset<T, basiq_webhooksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Basiq_webhooksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Basiq_webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Basiq_webhooksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Basiq_webhooksAggregateArgs>(args: Subset<T, Basiq_webhooksAggregateArgs>): Prisma.PrismaPromise<GetBasiq_webhooksAggregateType<T>>

    /**
     * Group by Basiq_webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basiq_webhooksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends basiq_webhooksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: basiq_webhooksGroupByArgs['orderBy'] }
        : { orderBy?: basiq_webhooksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, basiq_webhooksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBasiq_webhooksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the basiq_webhooks model
   */
  readonly fields: basiq_webhooksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for basiq_webhooks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__basiq_webhooksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the basiq_webhooks model
   */
  interface basiq_webhooksFieldRefs {
    readonly id: FieldRef<"basiq_webhooks", 'String'>
    readonly webhook_id: FieldRef<"basiq_webhooks", 'String'>
    readonly event_type: FieldRef<"basiq_webhooks", 'String'>
    readonly resource_type: FieldRef<"basiq_webhooks", 'String'>
    readonly resource_id: FieldRef<"basiq_webhooks", 'String'>
    readonly payload: FieldRef<"basiq_webhooks", 'Json'>
    readonly status: FieldRef<"basiq_webhooks", 'String'>
    readonly processed_at: FieldRef<"basiq_webhooks", 'DateTime'>
    readonly error_message: FieldRef<"basiq_webhooks", 'String'>
    readonly retry_count: FieldRef<"basiq_webhooks", 'Int'>
    readonly created_at: FieldRef<"basiq_webhooks", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * basiq_webhooks findUnique
   */
  export type basiq_webhooksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_webhooks
     */
    select?: basiq_webhooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_webhooks
     */
    omit?: basiq_webhooksOmit<ExtArgs> | null
    /**
     * Filter, which basiq_webhooks to fetch.
     */
    where: basiq_webhooksWhereUniqueInput
  }

  /**
   * basiq_webhooks findUniqueOrThrow
   */
  export type basiq_webhooksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_webhooks
     */
    select?: basiq_webhooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_webhooks
     */
    omit?: basiq_webhooksOmit<ExtArgs> | null
    /**
     * Filter, which basiq_webhooks to fetch.
     */
    where: basiq_webhooksWhereUniqueInput
  }

  /**
   * basiq_webhooks findFirst
   */
  export type basiq_webhooksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_webhooks
     */
    select?: basiq_webhooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_webhooks
     */
    omit?: basiq_webhooksOmit<ExtArgs> | null
    /**
     * Filter, which basiq_webhooks to fetch.
     */
    where?: basiq_webhooksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basiq_webhooks to fetch.
     */
    orderBy?: basiq_webhooksOrderByWithRelationInput | basiq_webhooksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for basiq_webhooks.
     */
    cursor?: basiq_webhooksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basiq_webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basiq_webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of basiq_webhooks.
     */
    distinct?: Basiq_webhooksScalarFieldEnum | Basiq_webhooksScalarFieldEnum[]
  }

  /**
   * basiq_webhooks findFirstOrThrow
   */
  export type basiq_webhooksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_webhooks
     */
    select?: basiq_webhooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_webhooks
     */
    omit?: basiq_webhooksOmit<ExtArgs> | null
    /**
     * Filter, which basiq_webhooks to fetch.
     */
    where?: basiq_webhooksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basiq_webhooks to fetch.
     */
    orderBy?: basiq_webhooksOrderByWithRelationInput | basiq_webhooksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for basiq_webhooks.
     */
    cursor?: basiq_webhooksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basiq_webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basiq_webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of basiq_webhooks.
     */
    distinct?: Basiq_webhooksScalarFieldEnum | Basiq_webhooksScalarFieldEnum[]
  }

  /**
   * basiq_webhooks findMany
   */
  export type basiq_webhooksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_webhooks
     */
    select?: basiq_webhooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_webhooks
     */
    omit?: basiq_webhooksOmit<ExtArgs> | null
    /**
     * Filter, which basiq_webhooks to fetch.
     */
    where?: basiq_webhooksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basiq_webhooks to fetch.
     */
    orderBy?: basiq_webhooksOrderByWithRelationInput | basiq_webhooksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing basiq_webhooks.
     */
    cursor?: basiq_webhooksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basiq_webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basiq_webhooks.
     */
    skip?: number
    distinct?: Basiq_webhooksScalarFieldEnum | Basiq_webhooksScalarFieldEnum[]
  }

  /**
   * basiq_webhooks create
   */
  export type basiq_webhooksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_webhooks
     */
    select?: basiq_webhooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_webhooks
     */
    omit?: basiq_webhooksOmit<ExtArgs> | null
    /**
     * The data needed to create a basiq_webhooks.
     */
    data: XOR<basiq_webhooksCreateInput, basiq_webhooksUncheckedCreateInput>
  }

  /**
   * basiq_webhooks createMany
   */
  export type basiq_webhooksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many basiq_webhooks.
     */
    data: basiq_webhooksCreateManyInput | basiq_webhooksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * basiq_webhooks createManyAndReturn
   */
  export type basiq_webhooksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_webhooks
     */
    select?: basiq_webhooksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_webhooks
     */
    omit?: basiq_webhooksOmit<ExtArgs> | null
    /**
     * The data used to create many basiq_webhooks.
     */
    data: basiq_webhooksCreateManyInput | basiq_webhooksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * basiq_webhooks update
   */
  export type basiq_webhooksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_webhooks
     */
    select?: basiq_webhooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_webhooks
     */
    omit?: basiq_webhooksOmit<ExtArgs> | null
    /**
     * The data needed to update a basiq_webhooks.
     */
    data: XOR<basiq_webhooksUpdateInput, basiq_webhooksUncheckedUpdateInput>
    /**
     * Choose, which basiq_webhooks to update.
     */
    where: basiq_webhooksWhereUniqueInput
  }

  /**
   * basiq_webhooks updateMany
   */
  export type basiq_webhooksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update basiq_webhooks.
     */
    data: XOR<basiq_webhooksUpdateManyMutationInput, basiq_webhooksUncheckedUpdateManyInput>
    /**
     * Filter which basiq_webhooks to update
     */
    where?: basiq_webhooksWhereInput
    /**
     * Limit how many basiq_webhooks to update.
     */
    limit?: number
  }

  /**
   * basiq_webhooks updateManyAndReturn
   */
  export type basiq_webhooksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_webhooks
     */
    select?: basiq_webhooksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_webhooks
     */
    omit?: basiq_webhooksOmit<ExtArgs> | null
    /**
     * The data used to update basiq_webhooks.
     */
    data: XOR<basiq_webhooksUpdateManyMutationInput, basiq_webhooksUncheckedUpdateManyInput>
    /**
     * Filter which basiq_webhooks to update
     */
    where?: basiq_webhooksWhereInput
    /**
     * Limit how many basiq_webhooks to update.
     */
    limit?: number
  }

  /**
   * basiq_webhooks upsert
   */
  export type basiq_webhooksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_webhooks
     */
    select?: basiq_webhooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_webhooks
     */
    omit?: basiq_webhooksOmit<ExtArgs> | null
    /**
     * The filter to search for the basiq_webhooks to update in case it exists.
     */
    where: basiq_webhooksWhereUniqueInput
    /**
     * In case the basiq_webhooks found by the `where` argument doesn't exist, create a new basiq_webhooks with this data.
     */
    create: XOR<basiq_webhooksCreateInput, basiq_webhooksUncheckedCreateInput>
    /**
     * In case the basiq_webhooks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<basiq_webhooksUpdateInput, basiq_webhooksUncheckedUpdateInput>
  }

  /**
   * basiq_webhooks delete
   */
  export type basiq_webhooksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_webhooks
     */
    select?: basiq_webhooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_webhooks
     */
    omit?: basiq_webhooksOmit<ExtArgs> | null
    /**
     * Filter which basiq_webhooks to delete.
     */
    where: basiq_webhooksWhereUniqueInput
  }

  /**
   * basiq_webhooks deleteMany
   */
  export type basiq_webhooksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which basiq_webhooks to delete
     */
    where?: basiq_webhooksWhereInput
    /**
     * Limit how many basiq_webhooks to delete.
     */
    limit?: number
  }

  /**
   * basiq_webhooks without action
   */
  export type basiq_webhooksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_webhooks
     */
    select?: basiq_webhooksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_webhooks
     */
    omit?: basiq_webhooksOmit<ExtArgs> | null
  }


  /**
   * Model basiq_api_logs
   */

  export type AggregateBasiq_api_logs = {
    _count: Basiq_api_logsCountAggregateOutputType | null
    _avg: Basiq_api_logsAvgAggregateOutputType | null
    _sum: Basiq_api_logsSumAggregateOutputType | null
    _min: Basiq_api_logsMinAggregateOutputType | null
    _max: Basiq_api_logsMaxAggregateOutputType | null
  }

  export type Basiq_api_logsAvgAggregateOutputType = {
    response_status: number | null
    duration_ms: number | null
  }

  export type Basiq_api_logsSumAggregateOutputType = {
    response_status: number | null
    duration_ms: number | null
  }

  export type Basiq_api_logsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    endpoint: string | null
    method: string | null
    response_status: number | null
    error_message: string | null
    duration_ms: number | null
    created_at: Date | null
  }

  export type Basiq_api_logsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    endpoint: string | null
    method: string | null
    response_status: number | null
    error_message: string | null
    duration_ms: number | null
    created_at: Date | null
  }

  export type Basiq_api_logsCountAggregateOutputType = {
    id: number
    user_id: number
    endpoint: number
    method: number
    request_body: number
    response_status: number
    response_body: number
    error_message: number
    duration_ms: number
    created_at: number
    _all: number
  }


  export type Basiq_api_logsAvgAggregateInputType = {
    response_status?: true
    duration_ms?: true
  }

  export type Basiq_api_logsSumAggregateInputType = {
    response_status?: true
    duration_ms?: true
  }

  export type Basiq_api_logsMinAggregateInputType = {
    id?: true
    user_id?: true
    endpoint?: true
    method?: true
    response_status?: true
    error_message?: true
    duration_ms?: true
    created_at?: true
  }

  export type Basiq_api_logsMaxAggregateInputType = {
    id?: true
    user_id?: true
    endpoint?: true
    method?: true
    response_status?: true
    error_message?: true
    duration_ms?: true
    created_at?: true
  }

  export type Basiq_api_logsCountAggregateInputType = {
    id?: true
    user_id?: true
    endpoint?: true
    method?: true
    request_body?: true
    response_status?: true
    response_body?: true
    error_message?: true
    duration_ms?: true
    created_at?: true
    _all?: true
  }

  export type Basiq_api_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which basiq_api_logs to aggregate.
     */
    where?: basiq_api_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basiq_api_logs to fetch.
     */
    orderBy?: basiq_api_logsOrderByWithRelationInput | basiq_api_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: basiq_api_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basiq_api_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basiq_api_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned basiq_api_logs
    **/
    _count?: true | Basiq_api_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Basiq_api_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Basiq_api_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Basiq_api_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Basiq_api_logsMaxAggregateInputType
  }

  export type GetBasiq_api_logsAggregateType<T extends Basiq_api_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateBasiq_api_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBasiq_api_logs[P]>
      : GetScalarType<T[P], AggregateBasiq_api_logs[P]>
  }




  export type basiq_api_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: basiq_api_logsWhereInput
    orderBy?: basiq_api_logsOrderByWithAggregationInput | basiq_api_logsOrderByWithAggregationInput[]
    by: Basiq_api_logsScalarFieldEnum[] | Basiq_api_logsScalarFieldEnum
    having?: basiq_api_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Basiq_api_logsCountAggregateInputType | true
    _avg?: Basiq_api_logsAvgAggregateInputType
    _sum?: Basiq_api_logsSumAggregateInputType
    _min?: Basiq_api_logsMinAggregateInputType
    _max?: Basiq_api_logsMaxAggregateInputType
  }

  export type Basiq_api_logsGroupByOutputType = {
    id: string
    user_id: string | null
    endpoint: string
    method: string
    request_body: JsonValue | null
    response_status: number | null
    response_body: JsonValue | null
    error_message: string | null
    duration_ms: number | null
    created_at: Date
    _count: Basiq_api_logsCountAggregateOutputType | null
    _avg: Basiq_api_logsAvgAggregateOutputType | null
    _sum: Basiq_api_logsSumAggregateOutputType | null
    _min: Basiq_api_logsMinAggregateOutputType | null
    _max: Basiq_api_logsMaxAggregateOutputType | null
  }

  type GetBasiq_api_logsGroupByPayload<T extends basiq_api_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Basiq_api_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Basiq_api_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Basiq_api_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Basiq_api_logsGroupByOutputType[P]>
        }
      >
    >


  export type basiq_api_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    endpoint?: boolean
    method?: boolean
    request_body?: boolean
    response_status?: boolean
    response_body?: boolean
    error_message?: boolean
    duration_ms?: boolean
    created_at?: boolean
    user?: boolean | basiq_api_logs$userArgs<ExtArgs>
  }, ExtArgs["result"]["basiq_api_logs"]>

  export type basiq_api_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    endpoint?: boolean
    method?: boolean
    request_body?: boolean
    response_status?: boolean
    response_body?: boolean
    error_message?: boolean
    duration_ms?: boolean
    created_at?: boolean
    user?: boolean | basiq_api_logs$userArgs<ExtArgs>
  }, ExtArgs["result"]["basiq_api_logs"]>

  export type basiq_api_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    endpoint?: boolean
    method?: boolean
    request_body?: boolean
    response_status?: boolean
    response_body?: boolean
    error_message?: boolean
    duration_ms?: boolean
    created_at?: boolean
    user?: boolean | basiq_api_logs$userArgs<ExtArgs>
  }, ExtArgs["result"]["basiq_api_logs"]>

  export type basiq_api_logsSelectScalar = {
    id?: boolean
    user_id?: boolean
    endpoint?: boolean
    method?: boolean
    request_body?: boolean
    response_status?: boolean
    response_body?: boolean
    error_message?: boolean
    duration_ms?: boolean
    created_at?: boolean
  }

  export type basiq_api_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "endpoint" | "method" | "request_body" | "response_status" | "response_body" | "error_message" | "duration_ms" | "created_at", ExtArgs["result"]["basiq_api_logs"]>
  export type basiq_api_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | basiq_api_logs$userArgs<ExtArgs>
  }
  export type basiq_api_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | basiq_api_logs$userArgs<ExtArgs>
  }
  export type basiq_api_logsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | basiq_api_logs$userArgs<ExtArgs>
  }

  export type $basiq_api_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "basiq_api_logs"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      endpoint: string
      method: string
      request_body: Prisma.JsonValue | null
      response_status: number | null
      response_body: Prisma.JsonValue | null
      error_message: string | null
      duration_ms: number | null
      created_at: Date
    }, ExtArgs["result"]["basiq_api_logs"]>
    composites: {}
  }

  type basiq_api_logsGetPayload<S extends boolean | null | undefined | basiq_api_logsDefaultArgs> = $Result.GetResult<Prisma.$basiq_api_logsPayload, S>

  type basiq_api_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<basiq_api_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Basiq_api_logsCountAggregateInputType | true
    }

  export interface basiq_api_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['basiq_api_logs'], meta: { name: 'basiq_api_logs' } }
    /**
     * Find zero or one Basiq_api_logs that matches the filter.
     * @param {basiq_api_logsFindUniqueArgs} args - Arguments to find a Basiq_api_logs
     * @example
     * // Get one Basiq_api_logs
     * const basiq_api_logs = await prisma.basiq_api_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends basiq_api_logsFindUniqueArgs>(args: SelectSubset<T, basiq_api_logsFindUniqueArgs<ExtArgs>>): Prisma__basiq_api_logsClient<$Result.GetResult<Prisma.$basiq_api_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Basiq_api_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {basiq_api_logsFindUniqueOrThrowArgs} args - Arguments to find a Basiq_api_logs
     * @example
     * // Get one Basiq_api_logs
     * const basiq_api_logs = await prisma.basiq_api_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends basiq_api_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, basiq_api_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__basiq_api_logsClient<$Result.GetResult<Prisma.$basiq_api_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Basiq_api_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basiq_api_logsFindFirstArgs} args - Arguments to find a Basiq_api_logs
     * @example
     * // Get one Basiq_api_logs
     * const basiq_api_logs = await prisma.basiq_api_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends basiq_api_logsFindFirstArgs>(args?: SelectSubset<T, basiq_api_logsFindFirstArgs<ExtArgs>>): Prisma__basiq_api_logsClient<$Result.GetResult<Prisma.$basiq_api_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Basiq_api_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basiq_api_logsFindFirstOrThrowArgs} args - Arguments to find a Basiq_api_logs
     * @example
     * // Get one Basiq_api_logs
     * const basiq_api_logs = await prisma.basiq_api_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends basiq_api_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, basiq_api_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__basiq_api_logsClient<$Result.GetResult<Prisma.$basiq_api_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Basiq_api_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basiq_api_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Basiq_api_logs
     * const basiq_api_logs = await prisma.basiq_api_logs.findMany()
     * 
     * // Get first 10 Basiq_api_logs
     * const basiq_api_logs = await prisma.basiq_api_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const basiq_api_logsWithIdOnly = await prisma.basiq_api_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends basiq_api_logsFindManyArgs>(args?: SelectSubset<T, basiq_api_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$basiq_api_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Basiq_api_logs.
     * @param {basiq_api_logsCreateArgs} args - Arguments to create a Basiq_api_logs.
     * @example
     * // Create one Basiq_api_logs
     * const Basiq_api_logs = await prisma.basiq_api_logs.create({
     *   data: {
     *     // ... data to create a Basiq_api_logs
     *   }
     * })
     * 
     */
    create<T extends basiq_api_logsCreateArgs>(args: SelectSubset<T, basiq_api_logsCreateArgs<ExtArgs>>): Prisma__basiq_api_logsClient<$Result.GetResult<Prisma.$basiq_api_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Basiq_api_logs.
     * @param {basiq_api_logsCreateManyArgs} args - Arguments to create many Basiq_api_logs.
     * @example
     * // Create many Basiq_api_logs
     * const basiq_api_logs = await prisma.basiq_api_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends basiq_api_logsCreateManyArgs>(args?: SelectSubset<T, basiq_api_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Basiq_api_logs and returns the data saved in the database.
     * @param {basiq_api_logsCreateManyAndReturnArgs} args - Arguments to create many Basiq_api_logs.
     * @example
     * // Create many Basiq_api_logs
     * const basiq_api_logs = await prisma.basiq_api_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Basiq_api_logs and only return the `id`
     * const basiq_api_logsWithIdOnly = await prisma.basiq_api_logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends basiq_api_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, basiq_api_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$basiq_api_logsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Basiq_api_logs.
     * @param {basiq_api_logsDeleteArgs} args - Arguments to delete one Basiq_api_logs.
     * @example
     * // Delete one Basiq_api_logs
     * const Basiq_api_logs = await prisma.basiq_api_logs.delete({
     *   where: {
     *     // ... filter to delete one Basiq_api_logs
     *   }
     * })
     * 
     */
    delete<T extends basiq_api_logsDeleteArgs>(args: SelectSubset<T, basiq_api_logsDeleteArgs<ExtArgs>>): Prisma__basiq_api_logsClient<$Result.GetResult<Prisma.$basiq_api_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Basiq_api_logs.
     * @param {basiq_api_logsUpdateArgs} args - Arguments to update one Basiq_api_logs.
     * @example
     * // Update one Basiq_api_logs
     * const basiq_api_logs = await prisma.basiq_api_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends basiq_api_logsUpdateArgs>(args: SelectSubset<T, basiq_api_logsUpdateArgs<ExtArgs>>): Prisma__basiq_api_logsClient<$Result.GetResult<Prisma.$basiq_api_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Basiq_api_logs.
     * @param {basiq_api_logsDeleteManyArgs} args - Arguments to filter Basiq_api_logs to delete.
     * @example
     * // Delete a few Basiq_api_logs
     * const { count } = await prisma.basiq_api_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends basiq_api_logsDeleteManyArgs>(args?: SelectSubset<T, basiq_api_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Basiq_api_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basiq_api_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Basiq_api_logs
     * const basiq_api_logs = await prisma.basiq_api_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends basiq_api_logsUpdateManyArgs>(args: SelectSubset<T, basiq_api_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Basiq_api_logs and returns the data updated in the database.
     * @param {basiq_api_logsUpdateManyAndReturnArgs} args - Arguments to update many Basiq_api_logs.
     * @example
     * // Update many Basiq_api_logs
     * const basiq_api_logs = await prisma.basiq_api_logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Basiq_api_logs and only return the `id`
     * const basiq_api_logsWithIdOnly = await prisma.basiq_api_logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends basiq_api_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, basiq_api_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$basiq_api_logsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Basiq_api_logs.
     * @param {basiq_api_logsUpsertArgs} args - Arguments to update or create a Basiq_api_logs.
     * @example
     * // Update or create a Basiq_api_logs
     * const basiq_api_logs = await prisma.basiq_api_logs.upsert({
     *   create: {
     *     // ... data to create a Basiq_api_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Basiq_api_logs we want to update
     *   }
     * })
     */
    upsert<T extends basiq_api_logsUpsertArgs>(args: SelectSubset<T, basiq_api_logsUpsertArgs<ExtArgs>>): Prisma__basiq_api_logsClient<$Result.GetResult<Prisma.$basiq_api_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Basiq_api_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basiq_api_logsCountArgs} args - Arguments to filter Basiq_api_logs to count.
     * @example
     * // Count the number of Basiq_api_logs
     * const count = await prisma.basiq_api_logs.count({
     *   where: {
     *     // ... the filter for the Basiq_api_logs we want to count
     *   }
     * })
    **/
    count<T extends basiq_api_logsCountArgs>(
      args?: Subset<T, basiq_api_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Basiq_api_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Basiq_api_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Basiq_api_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Basiq_api_logsAggregateArgs>(args: Subset<T, Basiq_api_logsAggregateArgs>): Prisma.PrismaPromise<GetBasiq_api_logsAggregateType<T>>

    /**
     * Group by Basiq_api_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basiq_api_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends basiq_api_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: basiq_api_logsGroupByArgs['orderBy'] }
        : { orderBy?: basiq_api_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, basiq_api_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBasiq_api_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the basiq_api_logs model
   */
  readonly fields: basiq_api_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for basiq_api_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__basiq_api_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends basiq_api_logs$userArgs<ExtArgs> = {}>(args?: Subset<T, basiq_api_logs$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the basiq_api_logs model
   */
  interface basiq_api_logsFieldRefs {
    readonly id: FieldRef<"basiq_api_logs", 'String'>
    readonly user_id: FieldRef<"basiq_api_logs", 'String'>
    readonly endpoint: FieldRef<"basiq_api_logs", 'String'>
    readonly method: FieldRef<"basiq_api_logs", 'String'>
    readonly request_body: FieldRef<"basiq_api_logs", 'Json'>
    readonly response_status: FieldRef<"basiq_api_logs", 'Int'>
    readonly response_body: FieldRef<"basiq_api_logs", 'Json'>
    readonly error_message: FieldRef<"basiq_api_logs", 'String'>
    readonly duration_ms: FieldRef<"basiq_api_logs", 'Int'>
    readonly created_at: FieldRef<"basiq_api_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * basiq_api_logs findUnique
   */
  export type basiq_api_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_api_logs
     */
    select?: basiq_api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_api_logs
     */
    omit?: basiq_api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_api_logsInclude<ExtArgs> | null
    /**
     * Filter, which basiq_api_logs to fetch.
     */
    where: basiq_api_logsWhereUniqueInput
  }

  /**
   * basiq_api_logs findUniqueOrThrow
   */
  export type basiq_api_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_api_logs
     */
    select?: basiq_api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_api_logs
     */
    omit?: basiq_api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_api_logsInclude<ExtArgs> | null
    /**
     * Filter, which basiq_api_logs to fetch.
     */
    where: basiq_api_logsWhereUniqueInput
  }

  /**
   * basiq_api_logs findFirst
   */
  export type basiq_api_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_api_logs
     */
    select?: basiq_api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_api_logs
     */
    omit?: basiq_api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_api_logsInclude<ExtArgs> | null
    /**
     * Filter, which basiq_api_logs to fetch.
     */
    where?: basiq_api_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basiq_api_logs to fetch.
     */
    orderBy?: basiq_api_logsOrderByWithRelationInput | basiq_api_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for basiq_api_logs.
     */
    cursor?: basiq_api_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basiq_api_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basiq_api_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of basiq_api_logs.
     */
    distinct?: Basiq_api_logsScalarFieldEnum | Basiq_api_logsScalarFieldEnum[]
  }

  /**
   * basiq_api_logs findFirstOrThrow
   */
  export type basiq_api_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_api_logs
     */
    select?: basiq_api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_api_logs
     */
    omit?: basiq_api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_api_logsInclude<ExtArgs> | null
    /**
     * Filter, which basiq_api_logs to fetch.
     */
    where?: basiq_api_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basiq_api_logs to fetch.
     */
    orderBy?: basiq_api_logsOrderByWithRelationInput | basiq_api_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for basiq_api_logs.
     */
    cursor?: basiq_api_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basiq_api_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basiq_api_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of basiq_api_logs.
     */
    distinct?: Basiq_api_logsScalarFieldEnum | Basiq_api_logsScalarFieldEnum[]
  }

  /**
   * basiq_api_logs findMany
   */
  export type basiq_api_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_api_logs
     */
    select?: basiq_api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_api_logs
     */
    omit?: basiq_api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_api_logsInclude<ExtArgs> | null
    /**
     * Filter, which basiq_api_logs to fetch.
     */
    where?: basiq_api_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basiq_api_logs to fetch.
     */
    orderBy?: basiq_api_logsOrderByWithRelationInput | basiq_api_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing basiq_api_logs.
     */
    cursor?: basiq_api_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basiq_api_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basiq_api_logs.
     */
    skip?: number
    distinct?: Basiq_api_logsScalarFieldEnum | Basiq_api_logsScalarFieldEnum[]
  }

  /**
   * basiq_api_logs create
   */
  export type basiq_api_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_api_logs
     */
    select?: basiq_api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_api_logs
     */
    omit?: basiq_api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_api_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a basiq_api_logs.
     */
    data: XOR<basiq_api_logsCreateInput, basiq_api_logsUncheckedCreateInput>
  }

  /**
   * basiq_api_logs createMany
   */
  export type basiq_api_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many basiq_api_logs.
     */
    data: basiq_api_logsCreateManyInput | basiq_api_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * basiq_api_logs createManyAndReturn
   */
  export type basiq_api_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_api_logs
     */
    select?: basiq_api_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_api_logs
     */
    omit?: basiq_api_logsOmit<ExtArgs> | null
    /**
     * The data used to create many basiq_api_logs.
     */
    data: basiq_api_logsCreateManyInput | basiq_api_logsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_api_logsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * basiq_api_logs update
   */
  export type basiq_api_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_api_logs
     */
    select?: basiq_api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_api_logs
     */
    omit?: basiq_api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_api_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a basiq_api_logs.
     */
    data: XOR<basiq_api_logsUpdateInput, basiq_api_logsUncheckedUpdateInput>
    /**
     * Choose, which basiq_api_logs to update.
     */
    where: basiq_api_logsWhereUniqueInput
  }

  /**
   * basiq_api_logs updateMany
   */
  export type basiq_api_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update basiq_api_logs.
     */
    data: XOR<basiq_api_logsUpdateManyMutationInput, basiq_api_logsUncheckedUpdateManyInput>
    /**
     * Filter which basiq_api_logs to update
     */
    where?: basiq_api_logsWhereInput
    /**
     * Limit how many basiq_api_logs to update.
     */
    limit?: number
  }

  /**
   * basiq_api_logs updateManyAndReturn
   */
  export type basiq_api_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_api_logs
     */
    select?: basiq_api_logsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_api_logs
     */
    omit?: basiq_api_logsOmit<ExtArgs> | null
    /**
     * The data used to update basiq_api_logs.
     */
    data: XOR<basiq_api_logsUpdateManyMutationInput, basiq_api_logsUncheckedUpdateManyInput>
    /**
     * Filter which basiq_api_logs to update
     */
    where?: basiq_api_logsWhereInput
    /**
     * Limit how many basiq_api_logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_api_logsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * basiq_api_logs upsert
   */
  export type basiq_api_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_api_logs
     */
    select?: basiq_api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_api_logs
     */
    omit?: basiq_api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_api_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the basiq_api_logs to update in case it exists.
     */
    where: basiq_api_logsWhereUniqueInput
    /**
     * In case the basiq_api_logs found by the `where` argument doesn't exist, create a new basiq_api_logs with this data.
     */
    create: XOR<basiq_api_logsCreateInput, basiq_api_logsUncheckedCreateInput>
    /**
     * In case the basiq_api_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<basiq_api_logsUpdateInput, basiq_api_logsUncheckedUpdateInput>
  }

  /**
   * basiq_api_logs delete
   */
  export type basiq_api_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_api_logs
     */
    select?: basiq_api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_api_logs
     */
    omit?: basiq_api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_api_logsInclude<ExtArgs> | null
    /**
     * Filter which basiq_api_logs to delete.
     */
    where: basiq_api_logsWhereUniqueInput
  }

  /**
   * basiq_api_logs deleteMany
   */
  export type basiq_api_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which basiq_api_logs to delete
     */
    where?: basiq_api_logsWhereInput
    /**
     * Limit how many basiq_api_logs to delete.
     */
    limit?: number
  }

  /**
   * basiq_api_logs.user
   */
  export type basiq_api_logs$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * basiq_api_logs without action
   */
  export type basiq_api_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basiq_api_logs
     */
    select?: basiq_api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the basiq_api_logs
     */
    omit?: basiq_api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basiq_api_logsInclude<ExtArgs> | null
  }


  /**
   * Model Receipt
   */

  export type AggregateReceipt = {
    _count: ReceiptCountAggregateOutputType | null
    _avg: ReceiptAvgAggregateOutputType | null
    _sum: ReceiptSumAggregateOutputType | null
    _min: ReceiptMinAggregateOutputType | null
    _max: ReceiptMaxAggregateOutputType | null
  }

  export type ReceiptAvgAggregateOutputType = {
    totalAmount: Decimal | null
    gstAmount: Decimal | null
    aiConfidence: Decimal | null
    matchConfidence: Decimal | null
  }

  export type ReceiptSumAggregateOutputType = {
    totalAmount: Decimal | null
    gstAmount: Decimal | null
    aiConfidence: Decimal | null
    matchConfidence: Decimal | null
  }

  export type ReceiptMinAggregateOutputType = {
    id: string | null
    userId: string | null
    merchant: string | null
    totalAmount: Decimal | null
    gstAmount: Decimal | null
    date: Date | null
    imageUrl: string | null
    aiProcessed: boolean | null
    aiConfidence: Decimal | null
    aiProvider: string | null
    aiModel: string | null
    processingStatus: $Enums.ReceiptStatus | null
    abn: string | null
    taxInvoiceNumber: string | null
    taxCategory: string | null
    isGstRegistered: boolean | null
    matchedTransactionId: string | null
    matchConfidence: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceiptMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    merchant: string | null
    totalAmount: Decimal | null
    gstAmount: Decimal | null
    date: Date | null
    imageUrl: string | null
    aiProcessed: boolean | null
    aiConfidence: Decimal | null
    aiProvider: string | null
    aiModel: string | null
    processingStatus: $Enums.ReceiptStatus | null
    abn: string | null
    taxInvoiceNumber: string | null
    taxCategory: string | null
    isGstRegistered: boolean | null
    matchedTransactionId: string | null
    matchConfidence: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceiptCountAggregateOutputType = {
    id: number
    userId: number
    merchant: number
    totalAmount: number
    gstAmount: number
    date: number
    items: number
    imageUrl: number
    aiProcessed: number
    aiConfidence: number
    aiProvider: number
    aiModel: number
    processingStatus: number
    abn: number
    taxInvoiceNumber: number
    taxCategory: number
    isGstRegistered: number
    matchedTransactionId: number
    matchConfidence: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReceiptAvgAggregateInputType = {
    totalAmount?: true
    gstAmount?: true
    aiConfidence?: true
    matchConfidence?: true
  }

  export type ReceiptSumAggregateInputType = {
    totalAmount?: true
    gstAmount?: true
    aiConfidence?: true
    matchConfidence?: true
  }

  export type ReceiptMinAggregateInputType = {
    id?: true
    userId?: true
    merchant?: true
    totalAmount?: true
    gstAmount?: true
    date?: true
    imageUrl?: true
    aiProcessed?: true
    aiConfidence?: true
    aiProvider?: true
    aiModel?: true
    processingStatus?: true
    abn?: true
    taxInvoiceNumber?: true
    taxCategory?: true
    isGstRegistered?: true
    matchedTransactionId?: true
    matchConfidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceiptMaxAggregateInputType = {
    id?: true
    userId?: true
    merchant?: true
    totalAmount?: true
    gstAmount?: true
    date?: true
    imageUrl?: true
    aiProcessed?: true
    aiConfidence?: true
    aiProvider?: true
    aiModel?: true
    processingStatus?: true
    abn?: true
    taxInvoiceNumber?: true
    taxCategory?: true
    isGstRegistered?: true
    matchedTransactionId?: true
    matchConfidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceiptCountAggregateInputType = {
    id?: true
    userId?: true
    merchant?: true
    totalAmount?: true
    gstAmount?: true
    date?: true
    items?: true
    imageUrl?: true
    aiProcessed?: true
    aiConfidence?: true
    aiProvider?: true
    aiModel?: true
    processingStatus?: true
    abn?: true
    taxInvoiceNumber?: true
    taxCategory?: true
    isGstRegistered?: true
    matchedTransactionId?: true
    matchConfidence?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReceiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receipt to aggregate.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Receipts
    **/
    _count?: true | ReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceiptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceiptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceiptMaxAggregateInputType
  }

  export type GetReceiptAggregateType<T extends ReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceipt[P]>
      : GetScalarType<T[P], AggregateReceipt[P]>
  }




  export type ReceiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptWhereInput
    orderBy?: ReceiptOrderByWithAggregationInput | ReceiptOrderByWithAggregationInput[]
    by: ReceiptScalarFieldEnum[] | ReceiptScalarFieldEnum
    having?: ReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceiptCountAggregateInputType | true
    _avg?: ReceiptAvgAggregateInputType
    _sum?: ReceiptSumAggregateInputType
    _min?: ReceiptMinAggregateInputType
    _max?: ReceiptMaxAggregateInputType
  }

  export type ReceiptGroupByOutputType = {
    id: string
    userId: string
    merchant: string | null
    totalAmount: Decimal
    gstAmount: Decimal | null
    date: Date
    items: JsonValue | null
    imageUrl: string | null
    aiProcessed: boolean
    aiConfidence: Decimal | null
    aiProvider: string | null
    aiModel: string | null
    processingStatus: $Enums.ReceiptStatus
    abn: string | null
    taxInvoiceNumber: string | null
    taxCategory: string | null
    isGstRegistered: boolean
    matchedTransactionId: string | null
    matchConfidence: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: ReceiptCountAggregateOutputType | null
    _avg: ReceiptAvgAggregateOutputType | null
    _sum: ReceiptSumAggregateOutputType | null
    _min: ReceiptMinAggregateOutputType | null
    _max: ReceiptMaxAggregateOutputType | null
  }

  type GetReceiptGroupByPayload<T extends ReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], ReceiptGroupByOutputType[P]>
        }
      >
    >


  export type ReceiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    merchant?: boolean
    totalAmount?: boolean
    gstAmount?: boolean
    date?: boolean
    items?: boolean
    imageUrl?: boolean
    aiProcessed?: boolean
    aiConfidence?: boolean
    aiProvider?: boolean
    aiModel?: boolean
    processingStatus?: boolean
    abn?: boolean
    taxInvoiceNumber?: boolean
    taxCategory?: boolean
    isGstRegistered?: boolean
    matchedTransactionId?: boolean
    matchConfidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receipt"]>

  export type ReceiptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    merchant?: boolean
    totalAmount?: boolean
    gstAmount?: boolean
    date?: boolean
    items?: boolean
    imageUrl?: boolean
    aiProcessed?: boolean
    aiConfidence?: boolean
    aiProvider?: boolean
    aiModel?: boolean
    processingStatus?: boolean
    abn?: boolean
    taxInvoiceNumber?: boolean
    taxCategory?: boolean
    isGstRegistered?: boolean
    matchedTransactionId?: boolean
    matchConfidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receipt"]>

  export type ReceiptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    merchant?: boolean
    totalAmount?: boolean
    gstAmount?: boolean
    date?: boolean
    items?: boolean
    imageUrl?: boolean
    aiProcessed?: boolean
    aiConfidence?: boolean
    aiProvider?: boolean
    aiModel?: boolean
    processingStatus?: boolean
    abn?: boolean
    taxInvoiceNumber?: boolean
    taxCategory?: boolean
    isGstRegistered?: boolean
    matchedTransactionId?: boolean
    matchConfidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receipt"]>

  export type ReceiptSelectScalar = {
    id?: boolean
    userId?: boolean
    merchant?: boolean
    totalAmount?: boolean
    gstAmount?: boolean
    date?: boolean
    items?: boolean
    imageUrl?: boolean
    aiProcessed?: boolean
    aiConfidence?: boolean
    aiProvider?: boolean
    aiModel?: boolean
    processingStatus?: boolean
    abn?: boolean
    taxInvoiceNumber?: boolean
    taxCategory?: boolean
    isGstRegistered?: boolean
    matchedTransactionId?: boolean
    matchConfidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReceiptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "merchant" | "totalAmount" | "gstAmount" | "date" | "items" | "imageUrl" | "aiProcessed" | "aiConfidence" | "aiProvider" | "aiModel" | "processingStatus" | "abn" | "taxInvoiceNumber" | "taxCategory" | "isGstRegistered" | "matchedTransactionId" | "matchConfidence" | "createdAt" | "updatedAt", ExtArgs["result"]["receipt"]>
  export type ReceiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReceiptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReceiptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReceiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Receipt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      merchant: string | null
      totalAmount: Prisma.Decimal
      gstAmount: Prisma.Decimal | null
      date: Date
      items: Prisma.JsonValue | null
      imageUrl: string | null
      aiProcessed: boolean
      aiConfidence: Prisma.Decimal | null
      aiProvider: string | null
      aiModel: string | null
      processingStatus: $Enums.ReceiptStatus
      abn: string | null
      taxInvoiceNumber: string | null
      taxCategory: string | null
      isGstRegistered: boolean
      matchedTransactionId: string | null
      matchConfidence: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["receipt"]>
    composites: {}
  }

  type ReceiptGetPayload<S extends boolean | null | undefined | ReceiptDefaultArgs> = $Result.GetResult<Prisma.$ReceiptPayload, S>

  type ReceiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReceiptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReceiptCountAggregateInputType | true
    }

  export interface ReceiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Receipt'], meta: { name: 'Receipt' } }
    /**
     * Find zero or one Receipt that matches the filter.
     * @param {ReceiptFindUniqueArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceiptFindUniqueArgs>(args: SelectSubset<T, ReceiptFindUniqueArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Receipt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReceiptFindUniqueOrThrowArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceiptFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceiptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindFirstArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceiptFindFirstArgs>(args?: SelectSubset<T, ReceiptFindFirstArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindFirstOrThrowArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceiptFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceiptFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Receipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Receipts
     * const receipts = await prisma.receipt.findMany()
     * 
     * // Get first 10 Receipts
     * const receipts = await prisma.receipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receiptWithIdOnly = await prisma.receipt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceiptFindManyArgs>(args?: SelectSubset<T, ReceiptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Receipt.
     * @param {ReceiptCreateArgs} args - Arguments to create a Receipt.
     * @example
     * // Create one Receipt
     * const Receipt = await prisma.receipt.create({
     *   data: {
     *     // ... data to create a Receipt
     *   }
     * })
     * 
     */
    create<T extends ReceiptCreateArgs>(args: SelectSubset<T, ReceiptCreateArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Receipts.
     * @param {ReceiptCreateManyArgs} args - Arguments to create many Receipts.
     * @example
     * // Create many Receipts
     * const receipt = await prisma.receipt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceiptCreateManyArgs>(args?: SelectSubset<T, ReceiptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Receipts and returns the data saved in the database.
     * @param {ReceiptCreateManyAndReturnArgs} args - Arguments to create many Receipts.
     * @example
     * // Create many Receipts
     * const receipt = await prisma.receipt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Receipts and only return the `id`
     * const receiptWithIdOnly = await prisma.receipt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReceiptCreateManyAndReturnArgs>(args?: SelectSubset<T, ReceiptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Receipt.
     * @param {ReceiptDeleteArgs} args - Arguments to delete one Receipt.
     * @example
     * // Delete one Receipt
     * const Receipt = await prisma.receipt.delete({
     *   where: {
     *     // ... filter to delete one Receipt
     *   }
     * })
     * 
     */
    delete<T extends ReceiptDeleteArgs>(args: SelectSubset<T, ReceiptDeleteArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Receipt.
     * @param {ReceiptUpdateArgs} args - Arguments to update one Receipt.
     * @example
     * // Update one Receipt
     * const receipt = await prisma.receipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceiptUpdateArgs>(args: SelectSubset<T, ReceiptUpdateArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Receipts.
     * @param {ReceiptDeleteManyArgs} args - Arguments to filter Receipts to delete.
     * @example
     * // Delete a few Receipts
     * const { count } = await prisma.receipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceiptDeleteManyArgs>(args?: SelectSubset<T, ReceiptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Receipts
     * const receipt = await prisma.receipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceiptUpdateManyArgs>(args: SelectSubset<T, ReceiptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receipts and returns the data updated in the database.
     * @param {ReceiptUpdateManyAndReturnArgs} args - Arguments to update many Receipts.
     * @example
     * // Update many Receipts
     * const receipt = await prisma.receipt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Receipts and only return the `id`
     * const receiptWithIdOnly = await prisma.receipt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReceiptUpdateManyAndReturnArgs>(args: SelectSubset<T, ReceiptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Receipt.
     * @param {ReceiptUpsertArgs} args - Arguments to update or create a Receipt.
     * @example
     * // Update or create a Receipt
     * const receipt = await prisma.receipt.upsert({
     *   create: {
     *     // ... data to create a Receipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Receipt we want to update
     *   }
     * })
     */
    upsert<T extends ReceiptUpsertArgs>(args: SelectSubset<T, ReceiptUpsertArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Receipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptCountArgs} args - Arguments to filter Receipts to count.
     * @example
     * // Count the number of Receipts
     * const count = await prisma.receipt.count({
     *   where: {
     *     // ... the filter for the Receipts we want to count
     *   }
     * })
    **/
    count<T extends ReceiptCountArgs>(
      args?: Subset<T, ReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Receipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceiptAggregateArgs>(args: Subset<T, ReceiptAggregateArgs>): Prisma.PrismaPromise<GetReceiptAggregateType<T>>

    /**
     * Group by Receipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceiptGroupByArgs['orderBy'] }
        : { orderBy?: ReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Receipt model
   */
  readonly fields: ReceiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Receipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Receipt model
   */
  interface ReceiptFieldRefs {
    readonly id: FieldRef<"Receipt", 'String'>
    readonly userId: FieldRef<"Receipt", 'String'>
    readonly merchant: FieldRef<"Receipt", 'String'>
    readonly totalAmount: FieldRef<"Receipt", 'Decimal'>
    readonly gstAmount: FieldRef<"Receipt", 'Decimal'>
    readonly date: FieldRef<"Receipt", 'DateTime'>
    readonly items: FieldRef<"Receipt", 'Json'>
    readonly imageUrl: FieldRef<"Receipt", 'String'>
    readonly aiProcessed: FieldRef<"Receipt", 'Boolean'>
    readonly aiConfidence: FieldRef<"Receipt", 'Decimal'>
    readonly aiProvider: FieldRef<"Receipt", 'String'>
    readonly aiModel: FieldRef<"Receipt", 'String'>
    readonly processingStatus: FieldRef<"Receipt", 'ReceiptStatus'>
    readonly abn: FieldRef<"Receipt", 'String'>
    readonly taxInvoiceNumber: FieldRef<"Receipt", 'String'>
    readonly taxCategory: FieldRef<"Receipt", 'String'>
    readonly isGstRegistered: FieldRef<"Receipt", 'Boolean'>
    readonly matchedTransactionId: FieldRef<"Receipt", 'String'>
    readonly matchConfidence: FieldRef<"Receipt", 'Decimal'>
    readonly createdAt: FieldRef<"Receipt", 'DateTime'>
    readonly updatedAt: FieldRef<"Receipt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Receipt findUnique
   */
  export type ReceiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt findUniqueOrThrow
   */
  export type ReceiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt findFirst
   */
  export type ReceiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receipts.
     */
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * Receipt findFirstOrThrow
   */
  export type ReceiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receipts.
     */
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * Receipt findMany
   */
  export type ReceiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipts to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * Receipt create
   */
  export type ReceiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * The data needed to create a Receipt.
     */
    data: XOR<ReceiptCreateInput, ReceiptUncheckedCreateInput>
  }

  /**
   * Receipt createMany
   */
  export type ReceiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Receipts.
     */
    data: ReceiptCreateManyInput | ReceiptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Receipt createManyAndReturn
   */
  export type ReceiptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * The data used to create many Receipts.
     */
    data: ReceiptCreateManyInput | ReceiptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Receipt update
   */
  export type ReceiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * The data needed to update a Receipt.
     */
    data: XOR<ReceiptUpdateInput, ReceiptUncheckedUpdateInput>
    /**
     * Choose, which Receipt to update.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt updateMany
   */
  export type ReceiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Receipts.
     */
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyInput>
    /**
     * Filter which Receipts to update
     */
    where?: ReceiptWhereInput
    /**
     * Limit how many Receipts to update.
     */
    limit?: number
  }

  /**
   * Receipt updateManyAndReturn
   */
  export type ReceiptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * The data used to update Receipts.
     */
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyInput>
    /**
     * Filter which Receipts to update
     */
    where?: ReceiptWhereInput
    /**
     * Limit how many Receipts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Receipt upsert
   */
  export type ReceiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * The filter to search for the Receipt to update in case it exists.
     */
    where: ReceiptWhereUniqueInput
    /**
     * In case the Receipt found by the `where` argument doesn't exist, create a new Receipt with this data.
     */
    create: XOR<ReceiptCreateInput, ReceiptUncheckedCreateInput>
    /**
     * In case the Receipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceiptUpdateInput, ReceiptUncheckedUpdateInput>
  }

  /**
   * Receipt delete
   */
  export type ReceiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter which Receipt to delete.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt deleteMany
   */
  export type ReceiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receipts to delete
     */
    where?: ReceiptWhereInput
    /**
     * Limit how many Receipts to delete.
     */
    limit?: number
  }

  /**
   * Receipt without action
   */
  export type ReceiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
  }


  /**
   * Model Budget
   */

  export type AggregateBudget = {
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  export type BudgetAvgAggregateOutputType = {
    monthlyBudget: Decimal | null
    targetSavings: Decimal | null
    monthlyIncome: Decimal | null
    confidenceScore: Decimal | null
  }

  export type BudgetSumAggregateOutputType = {
    monthlyBudget: Decimal | null
    targetSavings: Decimal | null
    monthlyIncome: Decimal | null
    confidenceScore: Decimal | null
  }

  export type BudgetMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    monthlyBudget: Decimal | null
    targetSavings: Decimal | null
    monthlyIncome: Decimal | null
    confidenceScore: Decimal | null
    aiProvider: string | null
    aiModel: string | null
    analysisPeriod: string | null
    predictionPeriod: string | null
    status: $Enums.BudgetStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    monthlyBudget: Decimal | null
    targetSavings: Decimal | null
    monthlyIncome: Decimal | null
    confidenceScore: Decimal | null
    aiProvider: string | null
    aiModel: string | null
    analysisPeriod: string | null
    predictionPeriod: string | null
    status: $Enums.BudgetStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    monthlyBudget: number
    targetSavings: number
    monthlyIncome: number
    predictions: number
    categoryLimits: number
    confidenceScore: number
    aiProvider: number
    aiModel: number
    analysisPeriod: number
    predictionPeriod: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BudgetAvgAggregateInputType = {
    monthlyBudget?: true
    targetSavings?: true
    monthlyIncome?: true
    confidenceScore?: true
  }

  export type BudgetSumAggregateInputType = {
    monthlyBudget?: true
    targetSavings?: true
    monthlyIncome?: true
    confidenceScore?: true
  }

  export type BudgetMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    monthlyBudget?: true
    targetSavings?: true
    monthlyIncome?: true
    confidenceScore?: true
    aiProvider?: true
    aiModel?: true
    analysisPeriod?: true
    predictionPeriod?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    monthlyBudget?: true
    targetSavings?: true
    monthlyIncome?: true
    confidenceScore?: true
    aiProvider?: true
    aiModel?: true
    analysisPeriod?: true
    predictionPeriod?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    monthlyBudget?: true
    targetSavings?: true
    monthlyIncome?: true
    predictions?: true
    categoryLimits?: true
    confidenceScore?: true
    aiProvider?: true
    aiModel?: true
    analysisPeriod?: true
    predictionPeriod?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BudgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budget to aggregate.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Budgets
    **/
    _count?: true | BudgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetMaxAggregateInputType
  }

  export type GetBudgetAggregateType<T extends BudgetAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget[P]>
      : GetScalarType<T[P], AggregateBudget[P]>
  }




  export type BudgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithAggregationInput | BudgetOrderByWithAggregationInput[]
    by: BudgetScalarFieldEnum[] | BudgetScalarFieldEnum
    having?: BudgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetCountAggregateInputType | true
    _avg?: BudgetAvgAggregateInputType
    _sum?: BudgetSumAggregateInputType
    _min?: BudgetMinAggregateInputType
    _max?: BudgetMaxAggregateInputType
  }

  export type BudgetGroupByOutputType = {
    id: string
    userId: string
    name: string | null
    monthlyBudget: Decimal
    targetSavings: Decimal | null
    monthlyIncome: Decimal | null
    predictions: JsonValue | null
    categoryLimits: JsonValue | null
    confidenceScore: Decimal | null
    aiProvider: string | null
    aiModel: string | null
    analysisPeriod: string | null
    predictionPeriod: string | null
    status: $Enums.BudgetStatus
    createdAt: Date
    updatedAt: Date
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  type GetBudgetGroupByPayload<T extends BudgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetGroupByOutputType[P]>
        }
      >
    >


  export type BudgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    monthlyBudget?: boolean
    targetSavings?: boolean
    monthlyIncome?: boolean
    predictions?: boolean
    categoryLimits?: boolean
    confidenceScore?: boolean
    aiProvider?: boolean
    aiModel?: boolean
    analysisPeriod?: boolean
    predictionPeriod?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    budgetTracking?: boolean | Budget$budgetTrackingArgs<ExtArgs>
    _count?: boolean | BudgetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    monthlyBudget?: boolean
    targetSavings?: boolean
    monthlyIncome?: boolean
    predictions?: boolean
    categoryLimits?: boolean
    confidenceScore?: boolean
    aiProvider?: boolean
    aiModel?: boolean
    analysisPeriod?: boolean
    predictionPeriod?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    monthlyBudget?: boolean
    targetSavings?: boolean
    monthlyIncome?: boolean
    predictions?: boolean
    categoryLimits?: boolean
    confidenceScore?: boolean
    aiProvider?: boolean
    aiModel?: boolean
    analysisPeriod?: boolean
    predictionPeriod?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    monthlyBudget?: boolean
    targetSavings?: boolean
    monthlyIncome?: boolean
    predictions?: boolean
    categoryLimits?: boolean
    confidenceScore?: boolean
    aiProvider?: boolean
    aiModel?: boolean
    analysisPeriod?: boolean
    predictionPeriod?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BudgetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "monthlyBudget" | "targetSavings" | "monthlyIncome" | "predictions" | "categoryLimits" | "confidenceScore" | "aiProvider" | "aiModel" | "analysisPeriod" | "predictionPeriod" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["budget"]>
  export type BudgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    budgetTracking?: boolean | Budget$budgetTrackingArgs<ExtArgs>
    _count?: boolean | BudgetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BudgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Budget"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      budgetTracking: Prisma.$BudgetTrackingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string | null
      monthlyBudget: Prisma.Decimal
      targetSavings: Prisma.Decimal | null
      monthlyIncome: Prisma.Decimal | null
      predictions: Prisma.JsonValue | null
      categoryLimits: Prisma.JsonValue | null
      confidenceScore: Prisma.Decimal | null
      aiProvider: string | null
      aiModel: string | null
      analysisPeriod: string | null
      predictionPeriod: string | null
      status: $Enums.BudgetStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["budget"]>
    composites: {}
  }

  type BudgetGetPayload<S extends boolean | null | undefined | BudgetDefaultArgs> = $Result.GetResult<Prisma.$BudgetPayload, S>

  type BudgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BudgetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BudgetCountAggregateInputType | true
    }

  export interface BudgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Budget'], meta: { name: 'Budget' } }
    /**
     * Find zero or one Budget that matches the filter.
     * @param {BudgetFindUniqueArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetFindUniqueArgs>(args: SelectSubset<T, BudgetFindUniqueArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Budget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BudgetFindUniqueOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetFindFirstArgs>(args?: SelectSubset<T, BudgetFindFirstArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Budgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budgets
     * const budgets = await prisma.budget.findMany()
     * 
     * // Get first 10 Budgets
     * const budgets = await prisma.budget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetWithIdOnly = await prisma.budget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetFindManyArgs>(args?: SelectSubset<T, BudgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Budget.
     * @param {BudgetCreateArgs} args - Arguments to create a Budget.
     * @example
     * // Create one Budget
     * const Budget = await prisma.budget.create({
     *   data: {
     *     // ... data to create a Budget
     *   }
     * })
     * 
     */
    create<T extends BudgetCreateArgs>(args: SelectSubset<T, BudgetCreateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Budgets.
     * @param {BudgetCreateManyArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetCreateManyArgs>(args?: SelectSubset<T, BudgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Budgets and returns the data saved in the database.
     * @param {BudgetCreateManyAndReturnArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Budget.
     * @param {BudgetDeleteArgs} args - Arguments to delete one Budget.
     * @example
     * // Delete one Budget
     * const Budget = await prisma.budget.delete({
     *   where: {
     *     // ... filter to delete one Budget
     *   }
     * })
     * 
     */
    delete<T extends BudgetDeleteArgs>(args: SelectSubset<T, BudgetDeleteArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Budget.
     * @param {BudgetUpdateArgs} args - Arguments to update one Budget.
     * @example
     * // Update one Budget
     * const budget = await prisma.budget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetUpdateArgs>(args: SelectSubset<T, BudgetUpdateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Budgets.
     * @param {BudgetDeleteManyArgs} args - Arguments to filter Budgets to delete.
     * @example
     * // Delete a few Budgets
     * const { count } = await prisma.budget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetDeleteManyArgs>(args?: SelectSubset<T, BudgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetUpdateManyArgs>(args: SelectSubset<T, BudgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets and returns the data updated in the database.
     * @param {BudgetUpdateManyAndReturnArgs} args - Arguments to update many Budgets.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BudgetUpdateManyAndReturnArgs>(args: SelectSubset<T, BudgetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Budget.
     * @param {BudgetUpsertArgs} args - Arguments to update or create a Budget.
     * @example
     * // Update or create a Budget
     * const budget = await prisma.budget.upsert({
     *   create: {
     *     // ... data to create a Budget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget we want to update
     *   }
     * })
     */
    upsert<T extends BudgetUpsertArgs>(args: SelectSubset<T, BudgetUpsertArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCountArgs} args - Arguments to filter Budgets to count.
     * @example
     * // Count the number of Budgets
     * const count = await prisma.budget.count({
     *   where: {
     *     // ... the filter for the Budgets we want to count
     *   }
     * })
    **/
    count<T extends BudgetCountArgs>(
      args?: Subset<T, BudgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetAggregateArgs>(args: Subset<T, BudgetAggregateArgs>): Prisma.PrismaPromise<GetBudgetAggregateType<T>>

    /**
     * Group by Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetGroupByArgs['orderBy'] }
        : { orderBy?: BudgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Budget model
   */
  readonly fields: BudgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Budget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    budgetTracking<T extends Budget$budgetTrackingArgs<ExtArgs> = {}>(args?: Subset<T, Budget$budgetTrackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Budget model
   */
  interface BudgetFieldRefs {
    readonly id: FieldRef<"Budget", 'String'>
    readonly userId: FieldRef<"Budget", 'String'>
    readonly name: FieldRef<"Budget", 'String'>
    readonly monthlyBudget: FieldRef<"Budget", 'Decimal'>
    readonly targetSavings: FieldRef<"Budget", 'Decimal'>
    readonly monthlyIncome: FieldRef<"Budget", 'Decimal'>
    readonly predictions: FieldRef<"Budget", 'Json'>
    readonly categoryLimits: FieldRef<"Budget", 'Json'>
    readonly confidenceScore: FieldRef<"Budget", 'Decimal'>
    readonly aiProvider: FieldRef<"Budget", 'String'>
    readonly aiModel: FieldRef<"Budget", 'String'>
    readonly analysisPeriod: FieldRef<"Budget", 'String'>
    readonly predictionPeriod: FieldRef<"Budget", 'String'>
    readonly status: FieldRef<"Budget", 'BudgetStatus'>
    readonly createdAt: FieldRef<"Budget", 'DateTime'>
    readonly updatedAt: FieldRef<"Budget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Budget findUnique
   */
  export type BudgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findUniqueOrThrow
   */
  export type BudgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findFirst
   */
  export type BudgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findFirstOrThrow
   */
  export type BudgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findMany
   */
  export type BudgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budgets to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget create
   */
  export type BudgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to create a Budget.
     */
    data: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
  }

  /**
   * Budget createMany
   */
  export type BudgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Budget createManyAndReturn
   */
  export type BudgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget update
   */
  export type BudgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to update a Budget.
     */
    data: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
    /**
     * Choose, which Budget to update.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget updateMany
   */
  export type BudgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to update.
     */
    limit?: number
  }

  /**
   * Budget updateManyAndReturn
   */
  export type BudgetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget upsert
   */
  export type BudgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The filter to search for the Budget to update in case it exists.
     */
    where: BudgetWhereUniqueInput
    /**
     * In case the Budget found by the `where` argument doesn't exist, create a new Budget with this data.
     */
    create: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
    /**
     * In case the Budget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
  }

  /**
   * Budget delete
   */
  export type BudgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter which Budget to delete.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget deleteMany
   */
  export type BudgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budgets to delete
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to delete.
     */
    limit?: number
  }

  /**
   * Budget.budgetTracking
   */
  export type Budget$budgetTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetTracking
     */
    select?: BudgetTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetTracking
     */
    omit?: BudgetTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetTrackingInclude<ExtArgs> | null
    where?: BudgetTrackingWhereInput
    orderBy?: BudgetTrackingOrderByWithRelationInput | BudgetTrackingOrderByWithRelationInput[]
    cursor?: BudgetTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetTrackingScalarFieldEnum | BudgetTrackingScalarFieldEnum[]
  }

  /**
   * Budget without action
   */
  export type BudgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
  }


  /**
   * Model BudgetTracking
   */

  export type AggregateBudgetTracking = {
    _count: BudgetTrackingCountAggregateOutputType | null
    _avg: BudgetTrackingAvgAggregateOutputType | null
    _sum: BudgetTrackingSumAggregateOutputType | null
    _min: BudgetTrackingMinAggregateOutputType | null
    _max: BudgetTrackingMaxAggregateOutputType | null
  }

  export type BudgetTrackingAvgAggregateOutputType = {
    month: number | null
    year: number | null
    predictedAmount: Decimal | null
    actualAmount: Decimal | null
    variance: Decimal | null
  }

  export type BudgetTrackingSumAggregateOutputType = {
    month: number | null
    year: number | null
    predictedAmount: Decimal | null
    actualAmount: Decimal | null
    variance: Decimal | null
  }

  export type BudgetTrackingMinAggregateOutputType = {
    id: string | null
    budgetId: string | null
    userId: string | null
    month: number | null
    year: number | null
    predictedAmount: Decimal | null
    actualAmount: Decimal | null
    variance: Decimal | null
    category: string | null
    createdAt: Date | null
  }

  export type BudgetTrackingMaxAggregateOutputType = {
    id: string | null
    budgetId: string | null
    userId: string | null
    month: number | null
    year: number | null
    predictedAmount: Decimal | null
    actualAmount: Decimal | null
    variance: Decimal | null
    category: string | null
    createdAt: Date | null
  }

  export type BudgetTrackingCountAggregateOutputType = {
    id: number
    budgetId: number
    userId: number
    month: number
    year: number
    predictedAmount: number
    actualAmount: number
    variance: number
    category: number
    createdAt: number
    _all: number
  }


  export type BudgetTrackingAvgAggregateInputType = {
    month?: true
    year?: true
    predictedAmount?: true
    actualAmount?: true
    variance?: true
  }

  export type BudgetTrackingSumAggregateInputType = {
    month?: true
    year?: true
    predictedAmount?: true
    actualAmount?: true
    variance?: true
  }

  export type BudgetTrackingMinAggregateInputType = {
    id?: true
    budgetId?: true
    userId?: true
    month?: true
    year?: true
    predictedAmount?: true
    actualAmount?: true
    variance?: true
    category?: true
    createdAt?: true
  }

  export type BudgetTrackingMaxAggregateInputType = {
    id?: true
    budgetId?: true
    userId?: true
    month?: true
    year?: true
    predictedAmount?: true
    actualAmount?: true
    variance?: true
    category?: true
    createdAt?: true
  }

  export type BudgetTrackingCountAggregateInputType = {
    id?: true
    budgetId?: true
    userId?: true
    month?: true
    year?: true
    predictedAmount?: true
    actualAmount?: true
    variance?: true
    category?: true
    createdAt?: true
    _all?: true
  }

  export type BudgetTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetTracking to aggregate.
     */
    where?: BudgetTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetTrackings to fetch.
     */
    orderBy?: BudgetTrackingOrderByWithRelationInput | BudgetTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BudgetTrackings
    **/
    _count?: true | BudgetTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetTrackingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetTrackingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetTrackingMaxAggregateInputType
  }

  export type GetBudgetTrackingAggregateType<T extends BudgetTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateBudgetTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudgetTracking[P]>
      : GetScalarType<T[P], AggregateBudgetTracking[P]>
  }




  export type BudgetTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetTrackingWhereInput
    orderBy?: BudgetTrackingOrderByWithAggregationInput | BudgetTrackingOrderByWithAggregationInput[]
    by: BudgetTrackingScalarFieldEnum[] | BudgetTrackingScalarFieldEnum
    having?: BudgetTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetTrackingCountAggregateInputType | true
    _avg?: BudgetTrackingAvgAggregateInputType
    _sum?: BudgetTrackingSumAggregateInputType
    _min?: BudgetTrackingMinAggregateInputType
    _max?: BudgetTrackingMaxAggregateInputType
  }

  export type BudgetTrackingGroupByOutputType = {
    id: string
    budgetId: string
    userId: string
    month: number
    year: number
    predictedAmount: Decimal
    actualAmount: Decimal | null
    variance: Decimal | null
    category: string | null
    createdAt: Date
    _count: BudgetTrackingCountAggregateOutputType | null
    _avg: BudgetTrackingAvgAggregateOutputType | null
    _sum: BudgetTrackingSumAggregateOutputType | null
    _min: BudgetTrackingMinAggregateOutputType | null
    _max: BudgetTrackingMaxAggregateOutputType | null
  }

  type GetBudgetTrackingGroupByPayload<T extends BudgetTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetTrackingGroupByOutputType[P]>
        }
      >
    >


  export type BudgetTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    userId?: boolean
    month?: boolean
    year?: boolean
    predictedAmount?: boolean
    actualAmount?: boolean
    variance?: boolean
    category?: boolean
    createdAt?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetTracking"]>

  export type BudgetTrackingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    userId?: boolean
    month?: boolean
    year?: boolean
    predictedAmount?: boolean
    actualAmount?: boolean
    variance?: boolean
    category?: boolean
    createdAt?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetTracking"]>

  export type BudgetTrackingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    userId?: boolean
    month?: boolean
    year?: boolean
    predictedAmount?: boolean
    actualAmount?: boolean
    variance?: boolean
    category?: boolean
    createdAt?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetTracking"]>

  export type BudgetTrackingSelectScalar = {
    id?: boolean
    budgetId?: boolean
    userId?: boolean
    month?: boolean
    year?: boolean
    predictedAmount?: boolean
    actualAmount?: boolean
    variance?: boolean
    category?: boolean
    createdAt?: boolean
  }

  export type BudgetTrackingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "budgetId" | "userId" | "month" | "year" | "predictedAmount" | "actualAmount" | "variance" | "category" | "createdAt", ExtArgs["result"]["budgetTracking"]>
  export type BudgetTrackingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BudgetTrackingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BudgetTrackingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BudgetTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BudgetTracking"
    objects: {
      budget: Prisma.$BudgetPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      budgetId: string
      userId: string
      month: number
      year: number
      predictedAmount: Prisma.Decimal
      actualAmount: Prisma.Decimal | null
      variance: Prisma.Decimal | null
      category: string | null
      createdAt: Date
    }, ExtArgs["result"]["budgetTracking"]>
    composites: {}
  }

  type BudgetTrackingGetPayload<S extends boolean | null | undefined | BudgetTrackingDefaultArgs> = $Result.GetResult<Prisma.$BudgetTrackingPayload, S>

  type BudgetTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BudgetTrackingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BudgetTrackingCountAggregateInputType | true
    }

  export interface BudgetTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BudgetTracking'], meta: { name: 'BudgetTracking' } }
    /**
     * Find zero or one BudgetTracking that matches the filter.
     * @param {BudgetTrackingFindUniqueArgs} args - Arguments to find a BudgetTracking
     * @example
     * // Get one BudgetTracking
     * const budgetTracking = await prisma.budgetTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetTrackingFindUniqueArgs>(args: SelectSubset<T, BudgetTrackingFindUniqueArgs<ExtArgs>>): Prisma__BudgetTrackingClient<$Result.GetResult<Prisma.$BudgetTrackingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BudgetTracking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BudgetTrackingFindUniqueOrThrowArgs} args - Arguments to find a BudgetTracking
     * @example
     * // Get one BudgetTracking
     * const budgetTracking = await prisma.budgetTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetTrackingClient<$Result.GetResult<Prisma.$BudgetTrackingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BudgetTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetTrackingFindFirstArgs} args - Arguments to find a BudgetTracking
     * @example
     * // Get one BudgetTracking
     * const budgetTracking = await prisma.budgetTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetTrackingFindFirstArgs>(args?: SelectSubset<T, BudgetTrackingFindFirstArgs<ExtArgs>>): Prisma__BudgetTrackingClient<$Result.GetResult<Prisma.$BudgetTrackingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BudgetTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetTrackingFindFirstOrThrowArgs} args - Arguments to find a BudgetTracking
     * @example
     * // Get one BudgetTracking
     * const budgetTracking = await prisma.budgetTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetTrackingClient<$Result.GetResult<Prisma.$BudgetTrackingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BudgetTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BudgetTrackings
     * const budgetTrackings = await prisma.budgetTracking.findMany()
     * 
     * // Get first 10 BudgetTrackings
     * const budgetTrackings = await prisma.budgetTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetTrackingWithIdOnly = await prisma.budgetTracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetTrackingFindManyArgs>(args?: SelectSubset<T, BudgetTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BudgetTracking.
     * @param {BudgetTrackingCreateArgs} args - Arguments to create a BudgetTracking.
     * @example
     * // Create one BudgetTracking
     * const BudgetTracking = await prisma.budgetTracking.create({
     *   data: {
     *     // ... data to create a BudgetTracking
     *   }
     * })
     * 
     */
    create<T extends BudgetTrackingCreateArgs>(args: SelectSubset<T, BudgetTrackingCreateArgs<ExtArgs>>): Prisma__BudgetTrackingClient<$Result.GetResult<Prisma.$BudgetTrackingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BudgetTrackings.
     * @param {BudgetTrackingCreateManyArgs} args - Arguments to create many BudgetTrackings.
     * @example
     * // Create many BudgetTrackings
     * const budgetTracking = await prisma.budgetTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetTrackingCreateManyArgs>(args?: SelectSubset<T, BudgetTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BudgetTrackings and returns the data saved in the database.
     * @param {BudgetTrackingCreateManyAndReturnArgs} args - Arguments to create many BudgetTrackings.
     * @example
     * // Create many BudgetTrackings
     * const budgetTracking = await prisma.budgetTracking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BudgetTrackings and only return the `id`
     * const budgetTrackingWithIdOnly = await prisma.budgetTracking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetTrackingCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetTrackingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetTrackingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BudgetTracking.
     * @param {BudgetTrackingDeleteArgs} args - Arguments to delete one BudgetTracking.
     * @example
     * // Delete one BudgetTracking
     * const BudgetTracking = await prisma.budgetTracking.delete({
     *   where: {
     *     // ... filter to delete one BudgetTracking
     *   }
     * })
     * 
     */
    delete<T extends BudgetTrackingDeleteArgs>(args: SelectSubset<T, BudgetTrackingDeleteArgs<ExtArgs>>): Prisma__BudgetTrackingClient<$Result.GetResult<Prisma.$BudgetTrackingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BudgetTracking.
     * @param {BudgetTrackingUpdateArgs} args - Arguments to update one BudgetTracking.
     * @example
     * // Update one BudgetTracking
     * const budgetTracking = await prisma.budgetTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetTrackingUpdateArgs>(args: SelectSubset<T, BudgetTrackingUpdateArgs<ExtArgs>>): Prisma__BudgetTrackingClient<$Result.GetResult<Prisma.$BudgetTrackingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BudgetTrackings.
     * @param {BudgetTrackingDeleteManyArgs} args - Arguments to filter BudgetTrackings to delete.
     * @example
     * // Delete a few BudgetTrackings
     * const { count } = await prisma.budgetTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetTrackingDeleteManyArgs>(args?: SelectSubset<T, BudgetTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BudgetTrackings
     * const budgetTracking = await prisma.budgetTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetTrackingUpdateManyArgs>(args: SelectSubset<T, BudgetTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetTrackings and returns the data updated in the database.
     * @param {BudgetTrackingUpdateManyAndReturnArgs} args - Arguments to update many BudgetTrackings.
     * @example
     * // Update many BudgetTrackings
     * const budgetTracking = await prisma.budgetTracking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BudgetTrackings and only return the `id`
     * const budgetTrackingWithIdOnly = await prisma.budgetTracking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BudgetTrackingUpdateManyAndReturnArgs>(args: SelectSubset<T, BudgetTrackingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetTrackingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BudgetTracking.
     * @param {BudgetTrackingUpsertArgs} args - Arguments to update or create a BudgetTracking.
     * @example
     * // Update or create a BudgetTracking
     * const budgetTracking = await prisma.budgetTracking.upsert({
     *   create: {
     *     // ... data to create a BudgetTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BudgetTracking we want to update
     *   }
     * })
     */
    upsert<T extends BudgetTrackingUpsertArgs>(args: SelectSubset<T, BudgetTrackingUpsertArgs<ExtArgs>>): Prisma__BudgetTrackingClient<$Result.GetResult<Prisma.$BudgetTrackingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BudgetTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetTrackingCountArgs} args - Arguments to filter BudgetTrackings to count.
     * @example
     * // Count the number of BudgetTrackings
     * const count = await prisma.budgetTracking.count({
     *   where: {
     *     // ... the filter for the BudgetTrackings we want to count
     *   }
     * })
    **/
    count<T extends BudgetTrackingCountArgs>(
      args?: Subset<T, BudgetTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BudgetTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetTrackingAggregateArgs>(args: Subset<T, BudgetTrackingAggregateArgs>): Prisma.PrismaPromise<GetBudgetTrackingAggregateType<T>>

    /**
     * Group by BudgetTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetTrackingGroupByArgs['orderBy'] }
        : { orderBy?: BudgetTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BudgetTracking model
   */
  readonly fields: BudgetTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BudgetTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budget<T extends BudgetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDefaultArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BudgetTracking model
   */
  interface BudgetTrackingFieldRefs {
    readonly id: FieldRef<"BudgetTracking", 'String'>
    readonly budgetId: FieldRef<"BudgetTracking", 'String'>
    readonly userId: FieldRef<"BudgetTracking", 'String'>
    readonly month: FieldRef<"BudgetTracking", 'Int'>
    readonly year: FieldRef<"BudgetTracking", 'Int'>
    readonly predictedAmount: FieldRef<"BudgetTracking", 'Decimal'>
    readonly actualAmount: FieldRef<"BudgetTracking", 'Decimal'>
    readonly variance: FieldRef<"BudgetTracking", 'Decimal'>
    readonly category: FieldRef<"BudgetTracking", 'String'>
    readonly createdAt: FieldRef<"BudgetTracking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BudgetTracking findUnique
   */
  export type BudgetTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetTracking
     */
    select?: BudgetTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetTracking
     */
    omit?: BudgetTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetTrackingInclude<ExtArgs> | null
    /**
     * Filter, which BudgetTracking to fetch.
     */
    where: BudgetTrackingWhereUniqueInput
  }

  /**
   * BudgetTracking findUniqueOrThrow
   */
  export type BudgetTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetTracking
     */
    select?: BudgetTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetTracking
     */
    omit?: BudgetTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetTrackingInclude<ExtArgs> | null
    /**
     * Filter, which BudgetTracking to fetch.
     */
    where: BudgetTrackingWhereUniqueInput
  }

  /**
   * BudgetTracking findFirst
   */
  export type BudgetTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetTracking
     */
    select?: BudgetTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetTracking
     */
    omit?: BudgetTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetTrackingInclude<ExtArgs> | null
    /**
     * Filter, which BudgetTracking to fetch.
     */
    where?: BudgetTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetTrackings to fetch.
     */
    orderBy?: BudgetTrackingOrderByWithRelationInput | BudgetTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetTrackings.
     */
    cursor?: BudgetTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetTrackings.
     */
    distinct?: BudgetTrackingScalarFieldEnum | BudgetTrackingScalarFieldEnum[]
  }

  /**
   * BudgetTracking findFirstOrThrow
   */
  export type BudgetTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetTracking
     */
    select?: BudgetTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetTracking
     */
    omit?: BudgetTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetTrackingInclude<ExtArgs> | null
    /**
     * Filter, which BudgetTracking to fetch.
     */
    where?: BudgetTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetTrackings to fetch.
     */
    orderBy?: BudgetTrackingOrderByWithRelationInput | BudgetTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetTrackings.
     */
    cursor?: BudgetTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetTrackings.
     */
    distinct?: BudgetTrackingScalarFieldEnum | BudgetTrackingScalarFieldEnum[]
  }

  /**
   * BudgetTracking findMany
   */
  export type BudgetTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetTracking
     */
    select?: BudgetTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetTracking
     */
    omit?: BudgetTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetTrackingInclude<ExtArgs> | null
    /**
     * Filter, which BudgetTrackings to fetch.
     */
    where?: BudgetTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetTrackings to fetch.
     */
    orderBy?: BudgetTrackingOrderByWithRelationInput | BudgetTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BudgetTrackings.
     */
    cursor?: BudgetTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetTrackings.
     */
    skip?: number
    distinct?: BudgetTrackingScalarFieldEnum | BudgetTrackingScalarFieldEnum[]
  }

  /**
   * BudgetTracking create
   */
  export type BudgetTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetTracking
     */
    select?: BudgetTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetTracking
     */
    omit?: BudgetTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetTrackingInclude<ExtArgs> | null
    /**
     * The data needed to create a BudgetTracking.
     */
    data: XOR<BudgetTrackingCreateInput, BudgetTrackingUncheckedCreateInput>
  }

  /**
   * BudgetTracking createMany
   */
  export type BudgetTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BudgetTrackings.
     */
    data: BudgetTrackingCreateManyInput | BudgetTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BudgetTracking createManyAndReturn
   */
  export type BudgetTrackingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetTracking
     */
    select?: BudgetTrackingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetTracking
     */
    omit?: BudgetTrackingOmit<ExtArgs> | null
    /**
     * The data used to create many BudgetTrackings.
     */
    data: BudgetTrackingCreateManyInput | BudgetTrackingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetTrackingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BudgetTracking update
   */
  export type BudgetTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetTracking
     */
    select?: BudgetTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetTracking
     */
    omit?: BudgetTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetTrackingInclude<ExtArgs> | null
    /**
     * The data needed to update a BudgetTracking.
     */
    data: XOR<BudgetTrackingUpdateInput, BudgetTrackingUncheckedUpdateInput>
    /**
     * Choose, which BudgetTracking to update.
     */
    where: BudgetTrackingWhereUniqueInput
  }

  /**
   * BudgetTracking updateMany
   */
  export type BudgetTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BudgetTrackings.
     */
    data: XOR<BudgetTrackingUpdateManyMutationInput, BudgetTrackingUncheckedUpdateManyInput>
    /**
     * Filter which BudgetTrackings to update
     */
    where?: BudgetTrackingWhereInput
    /**
     * Limit how many BudgetTrackings to update.
     */
    limit?: number
  }

  /**
   * BudgetTracking updateManyAndReturn
   */
  export type BudgetTrackingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetTracking
     */
    select?: BudgetTrackingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetTracking
     */
    omit?: BudgetTrackingOmit<ExtArgs> | null
    /**
     * The data used to update BudgetTrackings.
     */
    data: XOR<BudgetTrackingUpdateManyMutationInput, BudgetTrackingUncheckedUpdateManyInput>
    /**
     * Filter which BudgetTrackings to update
     */
    where?: BudgetTrackingWhereInput
    /**
     * Limit how many BudgetTrackings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetTrackingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BudgetTracking upsert
   */
  export type BudgetTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetTracking
     */
    select?: BudgetTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetTracking
     */
    omit?: BudgetTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetTrackingInclude<ExtArgs> | null
    /**
     * The filter to search for the BudgetTracking to update in case it exists.
     */
    where: BudgetTrackingWhereUniqueInput
    /**
     * In case the BudgetTracking found by the `where` argument doesn't exist, create a new BudgetTracking with this data.
     */
    create: XOR<BudgetTrackingCreateInput, BudgetTrackingUncheckedCreateInput>
    /**
     * In case the BudgetTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetTrackingUpdateInput, BudgetTrackingUncheckedUpdateInput>
  }

  /**
   * BudgetTracking delete
   */
  export type BudgetTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetTracking
     */
    select?: BudgetTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetTracking
     */
    omit?: BudgetTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetTrackingInclude<ExtArgs> | null
    /**
     * Filter which BudgetTracking to delete.
     */
    where: BudgetTrackingWhereUniqueInput
  }

  /**
   * BudgetTracking deleteMany
   */
  export type BudgetTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetTrackings to delete
     */
    where?: BudgetTrackingWhereInput
    /**
     * Limit how many BudgetTrackings to delete.
     */
    limit?: number
  }

  /**
   * BudgetTracking without action
   */
  export type BudgetTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetTracking
     */
    select?: BudgetTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetTracking
     */
    omit?: BudgetTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetTrackingInclude<ExtArgs> | null
  }


  /**
   * Model FinancialInsight
   */

  export type AggregateFinancialInsight = {
    _count: FinancialInsightCountAggregateOutputType | null
    _avg: FinancialInsightAvgAggregateOutputType | null
    _sum: FinancialInsightSumAggregateOutputType | null
    _min: FinancialInsightMinAggregateOutputType | null
    _max: FinancialInsightMaxAggregateOutputType | null
  }

  export type FinancialInsightAvgAggregateOutputType = {
    confidenceScore: Decimal | null
  }

  export type FinancialInsightSumAggregateOutputType = {
    confidenceScore: Decimal | null
  }

  export type FinancialInsightMinAggregateOutputType = {
    id: string | null
    userId: string | null
    insightType: string | null
    category: string | null
    confidenceScore: Decimal | null
    provider: string | null
    model: string | null
    title: string | null
    description: string | null
    priority: $Enums.InsightPriority | null
    isActive: boolean | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type FinancialInsightMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    insightType: string | null
    category: string | null
    confidenceScore: Decimal | null
    provider: string | null
    model: string | null
    title: string | null
    description: string | null
    priority: $Enums.InsightPriority | null
    isActive: boolean | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type FinancialInsightCountAggregateOutputType = {
    id: number
    userId: number
    insightType: number
    category: number
    content: number
    confidenceScore: number
    sourceDataIds: number
    provider: number
    model: number
    title: number
    description: number
    recommendations: number
    priority: number
    isActive: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type FinancialInsightAvgAggregateInputType = {
    confidenceScore?: true
  }

  export type FinancialInsightSumAggregateInputType = {
    confidenceScore?: true
  }

  export type FinancialInsightMinAggregateInputType = {
    id?: true
    userId?: true
    insightType?: true
    category?: true
    confidenceScore?: true
    provider?: true
    model?: true
    title?: true
    description?: true
    priority?: true
    isActive?: true
    createdAt?: true
    expiresAt?: true
  }

  export type FinancialInsightMaxAggregateInputType = {
    id?: true
    userId?: true
    insightType?: true
    category?: true
    confidenceScore?: true
    provider?: true
    model?: true
    title?: true
    description?: true
    priority?: true
    isActive?: true
    createdAt?: true
    expiresAt?: true
  }

  export type FinancialInsightCountAggregateInputType = {
    id?: true
    userId?: true
    insightType?: true
    category?: true
    content?: true
    confidenceScore?: true
    sourceDataIds?: true
    provider?: true
    model?: true
    title?: true
    description?: true
    recommendations?: true
    priority?: true
    isActive?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type FinancialInsightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialInsight to aggregate.
     */
    where?: FinancialInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialInsights to fetch.
     */
    orderBy?: FinancialInsightOrderByWithRelationInput | FinancialInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialInsights
    **/
    _count?: true | FinancialInsightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancialInsightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancialInsightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialInsightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialInsightMaxAggregateInputType
  }

  export type GetFinancialInsightAggregateType<T extends FinancialInsightAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialInsight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialInsight[P]>
      : GetScalarType<T[P], AggregateFinancialInsight[P]>
  }




  export type FinancialInsightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialInsightWhereInput
    orderBy?: FinancialInsightOrderByWithAggregationInput | FinancialInsightOrderByWithAggregationInput[]
    by: FinancialInsightScalarFieldEnum[] | FinancialInsightScalarFieldEnum
    having?: FinancialInsightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialInsightCountAggregateInputType | true
    _avg?: FinancialInsightAvgAggregateInputType
    _sum?: FinancialInsightSumAggregateInputType
    _min?: FinancialInsightMinAggregateInputType
    _max?: FinancialInsightMaxAggregateInputType
  }

  export type FinancialInsightGroupByOutputType = {
    id: string
    userId: string
    insightType: string
    category: string | null
    content: JsonValue | null
    confidenceScore: Decimal | null
    sourceDataIds: string[]
    provider: string | null
    model: string | null
    title: string | null
    description: string | null
    recommendations: JsonValue | null
    priority: $Enums.InsightPriority
    isActive: boolean
    createdAt: Date
    expiresAt: Date | null
    _count: FinancialInsightCountAggregateOutputType | null
    _avg: FinancialInsightAvgAggregateOutputType | null
    _sum: FinancialInsightSumAggregateOutputType | null
    _min: FinancialInsightMinAggregateOutputType | null
    _max: FinancialInsightMaxAggregateOutputType | null
  }

  type GetFinancialInsightGroupByPayload<T extends FinancialInsightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialInsightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialInsightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialInsightGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialInsightGroupByOutputType[P]>
        }
      >
    >


  export type FinancialInsightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    insightType?: boolean
    category?: boolean
    content?: boolean
    confidenceScore?: boolean
    sourceDataIds?: boolean
    provider?: boolean
    model?: boolean
    title?: boolean
    description?: boolean
    recommendations?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialInsight"]>

  export type FinancialInsightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    insightType?: boolean
    category?: boolean
    content?: boolean
    confidenceScore?: boolean
    sourceDataIds?: boolean
    provider?: boolean
    model?: boolean
    title?: boolean
    description?: boolean
    recommendations?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialInsight"]>

  export type FinancialInsightSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    insightType?: boolean
    category?: boolean
    content?: boolean
    confidenceScore?: boolean
    sourceDataIds?: boolean
    provider?: boolean
    model?: boolean
    title?: boolean
    description?: boolean
    recommendations?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialInsight"]>

  export type FinancialInsightSelectScalar = {
    id?: boolean
    userId?: boolean
    insightType?: boolean
    category?: boolean
    content?: boolean
    confidenceScore?: boolean
    sourceDataIds?: boolean
    provider?: boolean
    model?: boolean
    title?: boolean
    description?: boolean
    recommendations?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type FinancialInsightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "insightType" | "category" | "content" | "confidenceScore" | "sourceDataIds" | "provider" | "model" | "title" | "description" | "recommendations" | "priority" | "isActive" | "createdAt" | "expiresAt", ExtArgs["result"]["financialInsight"]>
  export type FinancialInsightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FinancialInsightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FinancialInsightIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FinancialInsightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialInsight"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      insightType: string
      category: string | null
      content: Prisma.JsonValue | null
      confidenceScore: Prisma.Decimal | null
      sourceDataIds: string[]
      provider: string | null
      model: string | null
      title: string | null
      description: string | null
      recommendations: Prisma.JsonValue | null
      priority: $Enums.InsightPriority
      isActive: boolean
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["financialInsight"]>
    composites: {}
  }

  type FinancialInsightGetPayload<S extends boolean | null | undefined | FinancialInsightDefaultArgs> = $Result.GetResult<Prisma.$FinancialInsightPayload, S>

  type FinancialInsightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinancialInsightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinancialInsightCountAggregateInputType | true
    }

  export interface FinancialInsightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialInsight'], meta: { name: 'FinancialInsight' } }
    /**
     * Find zero or one FinancialInsight that matches the filter.
     * @param {FinancialInsightFindUniqueArgs} args - Arguments to find a FinancialInsight
     * @example
     * // Get one FinancialInsight
     * const financialInsight = await prisma.financialInsight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancialInsightFindUniqueArgs>(args: SelectSubset<T, FinancialInsightFindUniqueArgs<ExtArgs>>): Prisma__FinancialInsightClient<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FinancialInsight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinancialInsightFindUniqueOrThrowArgs} args - Arguments to find a FinancialInsight
     * @example
     * // Get one FinancialInsight
     * const financialInsight = await prisma.financialInsight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancialInsightFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancialInsightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancialInsightClient<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialInsight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialInsightFindFirstArgs} args - Arguments to find a FinancialInsight
     * @example
     * // Get one FinancialInsight
     * const financialInsight = await prisma.financialInsight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancialInsightFindFirstArgs>(args?: SelectSubset<T, FinancialInsightFindFirstArgs<ExtArgs>>): Prisma__FinancialInsightClient<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialInsight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialInsightFindFirstOrThrowArgs} args - Arguments to find a FinancialInsight
     * @example
     * // Get one FinancialInsight
     * const financialInsight = await prisma.financialInsight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancialInsightFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancialInsightFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancialInsightClient<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinancialInsights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialInsightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialInsights
     * const financialInsights = await prisma.financialInsight.findMany()
     * 
     * // Get first 10 FinancialInsights
     * const financialInsights = await prisma.financialInsight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financialInsightWithIdOnly = await prisma.financialInsight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancialInsightFindManyArgs>(args?: SelectSubset<T, FinancialInsightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FinancialInsight.
     * @param {FinancialInsightCreateArgs} args - Arguments to create a FinancialInsight.
     * @example
     * // Create one FinancialInsight
     * const FinancialInsight = await prisma.financialInsight.create({
     *   data: {
     *     // ... data to create a FinancialInsight
     *   }
     * })
     * 
     */
    create<T extends FinancialInsightCreateArgs>(args: SelectSubset<T, FinancialInsightCreateArgs<ExtArgs>>): Prisma__FinancialInsightClient<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FinancialInsights.
     * @param {FinancialInsightCreateManyArgs} args - Arguments to create many FinancialInsights.
     * @example
     * // Create many FinancialInsights
     * const financialInsight = await prisma.financialInsight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancialInsightCreateManyArgs>(args?: SelectSubset<T, FinancialInsightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinancialInsights and returns the data saved in the database.
     * @param {FinancialInsightCreateManyAndReturnArgs} args - Arguments to create many FinancialInsights.
     * @example
     * // Create many FinancialInsights
     * const financialInsight = await prisma.financialInsight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinancialInsights and only return the `id`
     * const financialInsightWithIdOnly = await prisma.financialInsight.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinancialInsightCreateManyAndReturnArgs>(args?: SelectSubset<T, FinancialInsightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FinancialInsight.
     * @param {FinancialInsightDeleteArgs} args - Arguments to delete one FinancialInsight.
     * @example
     * // Delete one FinancialInsight
     * const FinancialInsight = await prisma.financialInsight.delete({
     *   where: {
     *     // ... filter to delete one FinancialInsight
     *   }
     * })
     * 
     */
    delete<T extends FinancialInsightDeleteArgs>(args: SelectSubset<T, FinancialInsightDeleteArgs<ExtArgs>>): Prisma__FinancialInsightClient<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FinancialInsight.
     * @param {FinancialInsightUpdateArgs} args - Arguments to update one FinancialInsight.
     * @example
     * // Update one FinancialInsight
     * const financialInsight = await prisma.financialInsight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancialInsightUpdateArgs>(args: SelectSubset<T, FinancialInsightUpdateArgs<ExtArgs>>): Prisma__FinancialInsightClient<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FinancialInsights.
     * @param {FinancialInsightDeleteManyArgs} args - Arguments to filter FinancialInsights to delete.
     * @example
     * // Delete a few FinancialInsights
     * const { count } = await prisma.financialInsight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancialInsightDeleteManyArgs>(args?: SelectSubset<T, FinancialInsightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialInsightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialInsights
     * const financialInsight = await prisma.financialInsight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancialInsightUpdateManyArgs>(args: SelectSubset<T, FinancialInsightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialInsights and returns the data updated in the database.
     * @param {FinancialInsightUpdateManyAndReturnArgs} args - Arguments to update many FinancialInsights.
     * @example
     * // Update many FinancialInsights
     * const financialInsight = await prisma.financialInsight.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FinancialInsights and only return the `id`
     * const financialInsightWithIdOnly = await prisma.financialInsight.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinancialInsightUpdateManyAndReturnArgs>(args: SelectSubset<T, FinancialInsightUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FinancialInsight.
     * @param {FinancialInsightUpsertArgs} args - Arguments to update or create a FinancialInsight.
     * @example
     * // Update or create a FinancialInsight
     * const financialInsight = await prisma.financialInsight.upsert({
     *   create: {
     *     // ... data to create a FinancialInsight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialInsight we want to update
     *   }
     * })
     */
    upsert<T extends FinancialInsightUpsertArgs>(args: SelectSubset<T, FinancialInsightUpsertArgs<ExtArgs>>): Prisma__FinancialInsightClient<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FinancialInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialInsightCountArgs} args - Arguments to filter FinancialInsights to count.
     * @example
     * // Count the number of FinancialInsights
     * const count = await prisma.financialInsight.count({
     *   where: {
     *     // ... the filter for the FinancialInsights we want to count
     *   }
     * })
    **/
    count<T extends FinancialInsightCountArgs>(
      args?: Subset<T, FinancialInsightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialInsightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialInsightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialInsightAggregateArgs>(args: Subset<T, FinancialInsightAggregateArgs>): Prisma.PrismaPromise<GetFinancialInsightAggregateType<T>>

    /**
     * Group by FinancialInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialInsightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialInsightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialInsightGroupByArgs['orderBy'] }
        : { orderBy?: FinancialInsightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialInsightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialInsightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialInsight model
   */
  readonly fields: FinancialInsightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialInsight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialInsightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancialInsight model
   */
  interface FinancialInsightFieldRefs {
    readonly id: FieldRef<"FinancialInsight", 'String'>
    readonly userId: FieldRef<"FinancialInsight", 'String'>
    readonly insightType: FieldRef<"FinancialInsight", 'String'>
    readonly category: FieldRef<"FinancialInsight", 'String'>
    readonly content: FieldRef<"FinancialInsight", 'Json'>
    readonly confidenceScore: FieldRef<"FinancialInsight", 'Decimal'>
    readonly sourceDataIds: FieldRef<"FinancialInsight", 'String[]'>
    readonly provider: FieldRef<"FinancialInsight", 'String'>
    readonly model: FieldRef<"FinancialInsight", 'String'>
    readonly title: FieldRef<"FinancialInsight", 'String'>
    readonly description: FieldRef<"FinancialInsight", 'String'>
    readonly recommendations: FieldRef<"FinancialInsight", 'Json'>
    readonly priority: FieldRef<"FinancialInsight", 'InsightPriority'>
    readonly isActive: FieldRef<"FinancialInsight", 'Boolean'>
    readonly createdAt: FieldRef<"FinancialInsight", 'DateTime'>
    readonly expiresAt: FieldRef<"FinancialInsight", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FinancialInsight findUnique
   */
  export type FinancialInsightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    /**
     * Filter, which FinancialInsight to fetch.
     */
    where: FinancialInsightWhereUniqueInput
  }

  /**
   * FinancialInsight findUniqueOrThrow
   */
  export type FinancialInsightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    /**
     * Filter, which FinancialInsight to fetch.
     */
    where: FinancialInsightWhereUniqueInput
  }

  /**
   * FinancialInsight findFirst
   */
  export type FinancialInsightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    /**
     * Filter, which FinancialInsight to fetch.
     */
    where?: FinancialInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialInsights to fetch.
     */
    orderBy?: FinancialInsightOrderByWithRelationInput | FinancialInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialInsights.
     */
    cursor?: FinancialInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialInsights.
     */
    distinct?: FinancialInsightScalarFieldEnum | FinancialInsightScalarFieldEnum[]
  }

  /**
   * FinancialInsight findFirstOrThrow
   */
  export type FinancialInsightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    /**
     * Filter, which FinancialInsight to fetch.
     */
    where?: FinancialInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialInsights to fetch.
     */
    orderBy?: FinancialInsightOrderByWithRelationInput | FinancialInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialInsights.
     */
    cursor?: FinancialInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialInsights.
     */
    distinct?: FinancialInsightScalarFieldEnum | FinancialInsightScalarFieldEnum[]
  }

  /**
   * FinancialInsight findMany
   */
  export type FinancialInsightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    /**
     * Filter, which FinancialInsights to fetch.
     */
    where?: FinancialInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialInsights to fetch.
     */
    orderBy?: FinancialInsightOrderByWithRelationInput | FinancialInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialInsights.
     */
    cursor?: FinancialInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialInsights.
     */
    skip?: number
    distinct?: FinancialInsightScalarFieldEnum | FinancialInsightScalarFieldEnum[]
  }

  /**
   * FinancialInsight create
   */
  export type FinancialInsightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    /**
     * The data needed to create a FinancialInsight.
     */
    data: XOR<FinancialInsightCreateInput, FinancialInsightUncheckedCreateInput>
  }

  /**
   * FinancialInsight createMany
   */
  export type FinancialInsightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialInsights.
     */
    data: FinancialInsightCreateManyInput | FinancialInsightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancialInsight createManyAndReturn
   */
  export type FinancialInsightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * The data used to create many FinancialInsights.
     */
    data: FinancialInsightCreateManyInput | FinancialInsightCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialInsight update
   */
  export type FinancialInsightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    /**
     * The data needed to update a FinancialInsight.
     */
    data: XOR<FinancialInsightUpdateInput, FinancialInsightUncheckedUpdateInput>
    /**
     * Choose, which FinancialInsight to update.
     */
    where: FinancialInsightWhereUniqueInput
  }

  /**
   * FinancialInsight updateMany
   */
  export type FinancialInsightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialInsights.
     */
    data: XOR<FinancialInsightUpdateManyMutationInput, FinancialInsightUncheckedUpdateManyInput>
    /**
     * Filter which FinancialInsights to update
     */
    where?: FinancialInsightWhereInput
    /**
     * Limit how many FinancialInsights to update.
     */
    limit?: number
  }

  /**
   * FinancialInsight updateManyAndReturn
   */
  export type FinancialInsightUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * The data used to update FinancialInsights.
     */
    data: XOR<FinancialInsightUpdateManyMutationInput, FinancialInsightUncheckedUpdateManyInput>
    /**
     * Filter which FinancialInsights to update
     */
    where?: FinancialInsightWhereInput
    /**
     * Limit how many FinancialInsights to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialInsight upsert
   */
  export type FinancialInsightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    /**
     * The filter to search for the FinancialInsight to update in case it exists.
     */
    where: FinancialInsightWhereUniqueInput
    /**
     * In case the FinancialInsight found by the `where` argument doesn't exist, create a new FinancialInsight with this data.
     */
    create: XOR<FinancialInsightCreateInput, FinancialInsightUncheckedCreateInput>
    /**
     * In case the FinancialInsight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialInsightUpdateInput, FinancialInsightUncheckedUpdateInput>
  }

  /**
   * FinancialInsight delete
   */
  export type FinancialInsightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    /**
     * Filter which FinancialInsight to delete.
     */
    where: FinancialInsightWhereUniqueInput
  }

  /**
   * FinancialInsight deleteMany
   */
  export type FinancialInsightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialInsights to delete
     */
    where?: FinancialInsightWhereInput
    /**
     * Limit how many FinancialInsights to delete.
     */
    limit?: number
  }

  /**
   * FinancialInsight without action
   */
  export type FinancialInsightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
  }


  /**
   * Model Goal
   */

  export type AggregateGoal = {
    _count: GoalCountAggregateOutputType | null
    _avg: GoalAvgAggregateOutputType | null
    _sum: GoalSumAggregateOutputType | null
    _min: GoalMinAggregateOutputType | null
    _max: GoalMaxAggregateOutputType | null
  }

  export type GoalAvgAggregateOutputType = {
    targetAmount: Decimal | null
    currentAmount: Decimal | null
  }

  export type GoalSumAggregateOutputType = {
    targetAmount: Decimal | null
    currentAmount: Decimal | null
  }

  export type GoalMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    targetAmount: Decimal | null
    currentAmount: Decimal | null
    targetDate: Date | null
    category: string | null
    status: $Enums.GoalStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoalMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    targetAmount: Decimal | null
    currentAmount: Decimal | null
    targetDate: Date | null
    category: string | null
    status: $Enums.GoalStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoalCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    targetAmount: number
    currentAmount: number
    targetDate: number
    category: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GoalAvgAggregateInputType = {
    targetAmount?: true
    currentAmount?: true
  }

  export type GoalSumAggregateInputType = {
    targetAmount?: true
    currentAmount?: true
  }

  export type GoalMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    targetAmount?: true
    currentAmount?: true
    targetDate?: true
    category?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoalMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    targetAmount?: true
    currentAmount?: true
    targetDate?: true
    category?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoalCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    targetAmount?: true
    currentAmount?: true
    targetDate?: true
    category?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goal to aggregate.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Goals
    **/
    _count?: true | GoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoalMaxAggregateInputType
  }

  export type GetGoalAggregateType<T extends GoalAggregateArgs> = {
        [P in keyof T & keyof AggregateGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoal[P]>
      : GetScalarType<T[P], AggregateGoal[P]>
  }




  export type GoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalWhereInput
    orderBy?: GoalOrderByWithAggregationInput | GoalOrderByWithAggregationInput[]
    by: GoalScalarFieldEnum[] | GoalScalarFieldEnum
    having?: GoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoalCountAggregateInputType | true
    _avg?: GoalAvgAggregateInputType
    _sum?: GoalSumAggregateInputType
    _min?: GoalMinAggregateInputType
    _max?: GoalMaxAggregateInputType
  }

  export type GoalGroupByOutputType = {
    id: string
    userId: string
    title: string
    targetAmount: Decimal
    currentAmount: Decimal
    targetDate: Date
    category: string | null
    status: $Enums.GoalStatus
    createdAt: Date
    updatedAt: Date
    _count: GoalCountAggregateOutputType | null
    _avg: GoalAvgAggregateOutputType | null
    _sum: GoalSumAggregateOutputType | null
    _min: GoalMinAggregateOutputType | null
    _max: GoalMaxAggregateOutputType | null
  }

  type GetGoalGroupByPayload<T extends GoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoalGroupByOutputType[P]>
            : GetScalarType<T[P], GoalGroupByOutputType[P]>
        }
      >
    >


  export type GoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    targetAmount?: boolean
    currentAmount?: boolean
    targetDate?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    targetAmount?: boolean
    currentAmount?: boolean
    targetDate?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    targetAmount?: boolean
    currentAmount?: boolean
    targetDate?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    targetAmount?: boolean
    currentAmount?: boolean
    targetDate?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GoalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "targetAmount" | "currentAmount" | "targetDate" | "category" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["goal"]>
  export type GoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GoalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GoalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Goal"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      targetAmount: Prisma.Decimal
      currentAmount: Prisma.Decimal
      targetDate: Date
      category: string | null
      status: $Enums.GoalStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["goal"]>
    composites: {}
  }

  type GoalGetPayload<S extends boolean | null | undefined | GoalDefaultArgs> = $Result.GetResult<Prisma.$GoalPayload, S>

  type GoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GoalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GoalCountAggregateInputType | true
    }

  export interface GoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Goal'], meta: { name: 'Goal' } }
    /**
     * Find zero or one Goal that matches the filter.
     * @param {GoalFindUniqueArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoalFindUniqueArgs>(args: SelectSubset<T, GoalFindUniqueArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Goal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GoalFindUniqueOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoalFindUniqueOrThrowArgs>(args: SelectSubset<T, GoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Goal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindFirstArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoalFindFirstArgs>(args?: SelectSubset<T, GoalFindFirstArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Goal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindFirstOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoalFindFirstOrThrowArgs>(args?: SelectSubset<T, GoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Goals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Goals
     * const goals = await prisma.goal.findMany()
     * 
     * // Get first 10 Goals
     * const goals = await prisma.goal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goalWithIdOnly = await prisma.goal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoalFindManyArgs>(args?: SelectSubset<T, GoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Goal.
     * @param {GoalCreateArgs} args - Arguments to create a Goal.
     * @example
     * // Create one Goal
     * const Goal = await prisma.goal.create({
     *   data: {
     *     // ... data to create a Goal
     *   }
     * })
     * 
     */
    create<T extends GoalCreateArgs>(args: SelectSubset<T, GoalCreateArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Goals.
     * @param {GoalCreateManyArgs} args - Arguments to create many Goals.
     * @example
     * // Create many Goals
     * const goal = await prisma.goal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoalCreateManyArgs>(args?: SelectSubset<T, GoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Goals and returns the data saved in the database.
     * @param {GoalCreateManyAndReturnArgs} args - Arguments to create many Goals.
     * @example
     * // Create many Goals
     * const goal = await prisma.goal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Goals and only return the `id`
     * const goalWithIdOnly = await prisma.goal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoalCreateManyAndReturnArgs>(args?: SelectSubset<T, GoalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Goal.
     * @param {GoalDeleteArgs} args - Arguments to delete one Goal.
     * @example
     * // Delete one Goal
     * const Goal = await prisma.goal.delete({
     *   where: {
     *     // ... filter to delete one Goal
     *   }
     * })
     * 
     */
    delete<T extends GoalDeleteArgs>(args: SelectSubset<T, GoalDeleteArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Goal.
     * @param {GoalUpdateArgs} args - Arguments to update one Goal.
     * @example
     * // Update one Goal
     * const goal = await prisma.goal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoalUpdateArgs>(args: SelectSubset<T, GoalUpdateArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Goals.
     * @param {GoalDeleteManyArgs} args - Arguments to filter Goals to delete.
     * @example
     * // Delete a few Goals
     * const { count } = await prisma.goal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoalDeleteManyArgs>(args?: SelectSubset<T, GoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Goals
     * const goal = await prisma.goal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoalUpdateManyArgs>(args: SelectSubset<T, GoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Goals and returns the data updated in the database.
     * @param {GoalUpdateManyAndReturnArgs} args - Arguments to update many Goals.
     * @example
     * // Update many Goals
     * const goal = await prisma.goal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Goals and only return the `id`
     * const goalWithIdOnly = await prisma.goal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GoalUpdateManyAndReturnArgs>(args: SelectSubset<T, GoalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Goal.
     * @param {GoalUpsertArgs} args - Arguments to update or create a Goal.
     * @example
     * // Update or create a Goal
     * const goal = await prisma.goal.upsert({
     *   create: {
     *     // ... data to create a Goal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Goal we want to update
     *   }
     * })
     */
    upsert<T extends GoalUpsertArgs>(args: SelectSubset<T, GoalUpsertArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalCountArgs} args - Arguments to filter Goals to count.
     * @example
     * // Count the number of Goals
     * const count = await prisma.goal.count({
     *   where: {
     *     // ... the filter for the Goals we want to count
     *   }
     * })
    **/
    count<T extends GoalCountArgs>(
      args?: Subset<T, GoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoalAggregateArgs>(args: Subset<T, GoalAggregateArgs>): Prisma.PrismaPromise<GetGoalAggregateType<T>>

    /**
     * Group by Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoalGroupByArgs['orderBy'] }
        : { orderBy?: GoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Goal model
   */
  readonly fields: GoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Goal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Goal model
   */
  interface GoalFieldRefs {
    readonly id: FieldRef<"Goal", 'String'>
    readonly userId: FieldRef<"Goal", 'String'>
    readonly title: FieldRef<"Goal", 'String'>
    readonly targetAmount: FieldRef<"Goal", 'Decimal'>
    readonly currentAmount: FieldRef<"Goal", 'Decimal'>
    readonly targetDate: FieldRef<"Goal", 'DateTime'>
    readonly category: FieldRef<"Goal", 'String'>
    readonly status: FieldRef<"Goal", 'GoalStatus'>
    readonly createdAt: FieldRef<"Goal", 'DateTime'>
    readonly updatedAt: FieldRef<"Goal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Goal findUnique
   */
  export type GoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal findUniqueOrThrow
   */
  export type GoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal findFirst
   */
  export type GoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goals.
     */
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal findFirstOrThrow
   */
  export type GoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goals.
     */
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal findMany
   */
  export type GoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goals to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal create
   */
  export type GoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The data needed to create a Goal.
     */
    data: XOR<GoalCreateInput, GoalUncheckedCreateInput>
  }

  /**
   * Goal createMany
   */
  export type GoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Goals.
     */
    data: GoalCreateManyInput | GoalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Goal createManyAndReturn
   */
  export type GoalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * The data used to create many Goals.
     */
    data: GoalCreateManyInput | GoalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Goal update
   */
  export type GoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The data needed to update a Goal.
     */
    data: XOR<GoalUpdateInput, GoalUncheckedUpdateInput>
    /**
     * Choose, which Goal to update.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal updateMany
   */
  export type GoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Goals.
     */
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyInput>
    /**
     * Filter which Goals to update
     */
    where?: GoalWhereInput
    /**
     * Limit how many Goals to update.
     */
    limit?: number
  }

  /**
   * Goal updateManyAndReturn
   */
  export type GoalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * The data used to update Goals.
     */
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyInput>
    /**
     * Filter which Goals to update
     */
    where?: GoalWhereInput
    /**
     * Limit how many Goals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Goal upsert
   */
  export type GoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The filter to search for the Goal to update in case it exists.
     */
    where: GoalWhereUniqueInput
    /**
     * In case the Goal found by the `where` argument doesn't exist, create a new Goal with this data.
     */
    create: XOR<GoalCreateInput, GoalUncheckedCreateInput>
    /**
     * In case the Goal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoalUpdateInput, GoalUncheckedUpdateInput>
  }

  /**
   * Goal delete
   */
  export type GoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter which Goal to delete.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal deleteMany
   */
  export type GoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goals to delete
     */
    where?: GoalWhereInput
    /**
     * Limit how many Goals to delete.
     */
    limit?: number
  }

  /**
   * Goal without action
   */
  export type GoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
  }


  /**
   * Model AMLTransactionMonitoring
   */

  export type AggregateAMLTransactionMonitoring = {
    _count: AMLTransactionMonitoringCountAggregateOutputType | null
    _avg: AMLTransactionMonitoringAvgAggregateOutputType | null
    _sum: AMLTransactionMonitoringSumAggregateOutputType | null
    _min: AMLTransactionMonitoringMinAggregateOutputType | null
    _max: AMLTransactionMonitoringMaxAggregateOutputType | null
  }

  export type AMLTransactionMonitoringAvgAggregateOutputType = {
    riskScore: Decimal | null
    amount: Decimal | null
    velocityScore: Decimal | null
  }

  export type AMLTransactionMonitoringSumAggregateOutputType = {
    riskScore: Decimal | null
    amount: Decimal | null
    velocityScore: Decimal | null
  }

  export type AMLTransactionMonitoringMinAggregateOutputType = {
    id: string | null
    userId: string | null
    transactionId: string | null
    monitoringType: $Enums.AMLMonitoringType | null
    riskScore: Decimal | null
    amount: Decimal | null
    currency: string | null
    patternType: string | null
    velocityScore: Decimal | null
    requiresReview: boolean | null
    reviewedBy: string | null
    reviewedAt: Date | null
    reportedToAUSTRAC: boolean | null
    reportReference: string | null
    reportedAt: Date | null
    falsePositive: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AMLTransactionMonitoringMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    transactionId: string | null
    monitoringType: $Enums.AMLMonitoringType | null
    riskScore: Decimal | null
    amount: Decimal | null
    currency: string | null
    patternType: string | null
    velocityScore: Decimal | null
    requiresReview: boolean | null
    reviewedBy: string | null
    reviewedAt: Date | null
    reportedToAUSTRAC: boolean | null
    reportReference: string | null
    reportedAt: Date | null
    falsePositive: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AMLTransactionMonitoringCountAggregateOutputType = {
    id: number
    userId: number
    transactionId: number
    monitoringType: number
    riskScore: number
    riskFactors: number
    amount: number
    currency: number
    patternType: number
    patternDetails: number
    velocityScore: number
    requiresReview: number
    reviewedBy: number
    reviewedAt: number
    reportedToAUSTRAC: number
    reportReference: number
    reportedAt: number
    falsePositive: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AMLTransactionMonitoringAvgAggregateInputType = {
    riskScore?: true
    amount?: true
    velocityScore?: true
  }

  export type AMLTransactionMonitoringSumAggregateInputType = {
    riskScore?: true
    amount?: true
    velocityScore?: true
  }

  export type AMLTransactionMonitoringMinAggregateInputType = {
    id?: true
    userId?: true
    transactionId?: true
    monitoringType?: true
    riskScore?: true
    amount?: true
    currency?: true
    patternType?: true
    velocityScore?: true
    requiresReview?: true
    reviewedBy?: true
    reviewedAt?: true
    reportedToAUSTRAC?: true
    reportReference?: true
    reportedAt?: true
    falsePositive?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AMLTransactionMonitoringMaxAggregateInputType = {
    id?: true
    userId?: true
    transactionId?: true
    monitoringType?: true
    riskScore?: true
    amount?: true
    currency?: true
    patternType?: true
    velocityScore?: true
    requiresReview?: true
    reviewedBy?: true
    reviewedAt?: true
    reportedToAUSTRAC?: true
    reportReference?: true
    reportedAt?: true
    falsePositive?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AMLTransactionMonitoringCountAggregateInputType = {
    id?: true
    userId?: true
    transactionId?: true
    monitoringType?: true
    riskScore?: true
    riskFactors?: true
    amount?: true
    currency?: true
    patternType?: true
    patternDetails?: true
    velocityScore?: true
    requiresReview?: true
    reviewedBy?: true
    reviewedAt?: true
    reportedToAUSTRAC?: true
    reportReference?: true
    reportedAt?: true
    falsePositive?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AMLTransactionMonitoringAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AMLTransactionMonitoring to aggregate.
     */
    where?: AMLTransactionMonitoringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AMLTransactionMonitorings to fetch.
     */
    orderBy?: AMLTransactionMonitoringOrderByWithRelationInput | AMLTransactionMonitoringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AMLTransactionMonitoringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AMLTransactionMonitorings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AMLTransactionMonitorings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AMLTransactionMonitorings
    **/
    _count?: true | AMLTransactionMonitoringCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AMLTransactionMonitoringAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AMLTransactionMonitoringSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AMLTransactionMonitoringMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AMLTransactionMonitoringMaxAggregateInputType
  }

  export type GetAMLTransactionMonitoringAggregateType<T extends AMLTransactionMonitoringAggregateArgs> = {
        [P in keyof T & keyof AggregateAMLTransactionMonitoring]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAMLTransactionMonitoring[P]>
      : GetScalarType<T[P], AggregateAMLTransactionMonitoring[P]>
  }




  export type AMLTransactionMonitoringGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AMLTransactionMonitoringWhereInput
    orderBy?: AMLTransactionMonitoringOrderByWithAggregationInput | AMLTransactionMonitoringOrderByWithAggregationInput[]
    by: AMLTransactionMonitoringScalarFieldEnum[] | AMLTransactionMonitoringScalarFieldEnum
    having?: AMLTransactionMonitoringScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AMLTransactionMonitoringCountAggregateInputType | true
    _avg?: AMLTransactionMonitoringAvgAggregateInputType
    _sum?: AMLTransactionMonitoringSumAggregateInputType
    _min?: AMLTransactionMonitoringMinAggregateInputType
    _max?: AMLTransactionMonitoringMaxAggregateInputType
  }

  export type AMLTransactionMonitoringGroupByOutputType = {
    id: string
    userId: string
    transactionId: string | null
    monitoringType: $Enums.AMLMonitoringType
    riskScore: Decimal
    riskFactors: string[]
    amount: Decimal
    currency: string
    patternType: string | null
    patternDetails: JsonValue | null
    velocityScore: Decimal | null
    requiresReview: boolean
    reviewedBy: string | null
    reviewedAt: Date | null
    reportedToAUSTRAC: boolean
    reportReference: string | null
    reportedAt: Date | null
    falsePositive: boolean
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: AMLTransactionMonitoringCountAggregateOutputType | null
    _avg: AMLTransactionMonitoringAvgAggregateOutputType | null
    _sum: AMLTransactionMonitoringSumAggregateOutputType | null
    _min: AMLTransactionMonitoringMinAggregateOutputType | null
    _max: AMLTransactionMonitoringMaxAggregateOutputType | null
  }

  type GetAMLTransactionMonitoringGroupByPayload<T extends AMLTransactionMonitoringGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AMLTransactionMonitoringGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AMLTransactionMonitoringGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AMLTransactionMonitoringGroupByOutputType[P]>
            : GetScalarType<T[P], AMLTransactionMonitoringGroupByOutputType[P]>
        }
      >
    >


  export type AMLTransactionMonitoringSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionId?: boolean
    monitoringType?: boolean
    riskScore?: boolean
    riskFactors?: boolean
    amount?: boolean
    currency?: boolean
    patternType?: boolean
    patternDetails?: boolean
    velocityScore?: boolean
    requiresReview?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reportedToAUSTRAC?: boolean
    reportReference?: boolean
    reportedAt?: boolean
    falsePositive?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aMLTransactionMonitoring"]>

  export type AMLTransactionMonitoringSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionId?: boolean
    monitoringType?: boolean
    riskScore?: boolean
    riskFactors?: boolean
    amount?: boolean
    currency?: boolean
    patternType?: boolean
    patternDetails?: boolean
    velocityScore?: boolean
    requiresReview?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reportedToAUSTRAC?: boolean
    reportReference?: boolean
    reportedAt?: boolean
    falsePositive?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aMLTransactionMonitoring"]>

  export type AMLTransactionMonitoringSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionId?: boolean
    monitoringType?: boolean
    riskScore?: boolean
    riskFactors?: boolean
    amount?: boolean
    currency?: boolean
    patternType?: boolean
    patternDetails?: boolean
    velocityScore?: boolean
    requiresReview?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reportedToAUSTRAC?: boolean
    reportReference?: boolean
    reportedAt?: boolean
    falsePositive?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aMLTransactionMonitoring"]>

  export type AMLTransactionMonitoringSelectScalar = {
    id?: boolean
    userId?: boolean
    transactionId?: boolean
    monitoringType?: boolean
    riskScore?: boolean
    riskFactors?: boolean
    amount?: boolean
    currency?: boolean
    patternType?: boolean
    patternDetails?: boolean
    velocityScore?: boolean
    requiresReview?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reportedToAUSTRAC?: boolean
    reportReference?: boolean
    reportedAt?: boolean
    falsePositive?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AMLTransactionMonitoringOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "transactionId" | "monitoringType" | "riskScore" | "riskFactors" | "amount" | "currency" | "patternType" | "patternDetails" | "velocityScore" | "requiresReview" | "reviewedBy" | "reviewedAt" | "reportedToAUSTRAC" | "reportReference" | "reportedAt" | "falsePositive" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["aMLTransactionMonitoring"]>
  export type AMLTransactionMonitoringInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AMLTransactionMonitoringIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AMLTransactionMonitoringIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AMLTransactionMonitoringPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AMLTransactionMonitoring"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      transactionId: string | null
      monitoringType: $Enums.AMLMonitoringType
      riskScore: Prisma.Decimal
      riskFactors: string[]
      amount: Prisma.Decimal
      currency: string
      patternType: string | null
      patternDetails: Prisma.JsonValue | null
      velocityScore: Prisma.Decimal | null
      requiresReview: boolean
      reviewedBy: string | null
      reviewedAt: Date | null
      reportedToAUSTRAC: boolean
      reportReference: string | null
      reportedAt: Date | null
      falsePositive: boolean
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aMLTransactionMonitoring"]>
    composites: {}
  }

  type AMLTransactionMonitoringGetPayload<S extends boolean | null | undefined | AMLTransactionMonitoringDefaultArgs> = $Result.GetResult<Prisma.$AMLTransactionMonitoringPayload, S>

  type AMLTransactionMonitoringCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AMLTransactionMonitoringFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AMLTransactionMonitoringCountAggregateInputType | true
    }

  export interface AMLTransactionMonitoringDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AMLTransactionMonitoring'], meta: { name: 'AMLTransactionMonitoring' } }
    /**
     * Find zero or one AMLTransactionMonitoring that matches the filter.
     * @param {AMLTransactionMonitoringFindUniqueArgs} args - Arguments to find a AMLTransactionMonitoring
     * @example
     * // Get one AMLTransactionMonitoring
     * const aMLTransactionMonitoring = await prisma.aMLTransactionMonitoring.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AMLTransactionMonitoringFindUniqueArgs>(args: SelectSubset<T, AMLTransactionMonitoringFindUniqueArgs<ExtArgs>>): Prisma__AMLTransactionMonitoringClient<$Result.GetResult<Prisma.$AMLTransactionMonitoringPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AMLTransactionMonitoring that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AMLTransactionMonitoringFindUniqueOrThrowArgs} args - Arguments to find a AMLTransactionMonitoring
     * @example
     * // Get one AMLTransactionMonitoring
     * const aMLTransactionMonitoring = await prisma.aMLTransactionMonitoring.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AMLTransactionMonitoringFindUniqueOrThrowArgs>(args: SelectSubset<T, AMLTransactionMonitoringFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AMLTransactionMonitoringClient<$Result.GetResult<Prisma.$AMLTransactionMonitoringPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AMLTransactionMonitoring that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AMLTransactionMonitoringFindFirstArgs} args - Arguments to find a AMLTransactionMonitoring
     * @example
     * // Get one AMLTransactionMonitoring
     * const aMLTransactionMonitoring = await prisma.aMLTransactionMonitoring.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AMLTransactionMonitoringFindFirstArgs>(args?: SelectSubset<T, AMLTransactionMonitoringFindFirstArgs<ExtArgs>>): Prisma__AMLTransactionMonitoringClient<$Result.GetResult<Prisma.$AMLTransactionMonitoringPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AMLTransactionMonitoring that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AMLTransactionMonitoringFindFirstOrThrowArgs} args - Arguments to find a AMLTransactionMonitoring
     * @example
     * // Get one AMLTransactionMonitoring
     * const aMLTransactionMonitoring = await prisma.aMLTransactionMonitoring.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AMLTransactionMonitoringFindFirstOrThrowArgs>(args?: SelectSubset<T, AMLTransactionMonitoringFindFirstOrThrowArgs<ExtArgs>>): Prisma__AMLTransactionMonitoringClient<$Result.GetResult<Prisma.$AMLTransactionMonitoringPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AMLTransactionMonitorings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AMLTransactionMonitoringFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AMLTransactionMonitorings
     * const aMLTransactionMonitorings = await prisma.aMLTransactionMonitoring.findMany()
     * 
     * // Get first 10 AMLTransactionMonitorings
     * const aMLTransactionMonitorings = await prisma.aMLTransactionMonitoring.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aMLTransactionMonitoringWithIdOnly = await prisma.aMLTransactionMonitoring.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AMLTransactionMonitoringFindManyArgs>(args?: SelectSubset<T, AMLTransactionMonitoringFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AMLTransactionMonitoringPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AMLTransactionMonitoring.
     * @param {AMLTransactionMonitoringCreateArgs} args - Arguments to create a AMLTransactionMonitoring.
     * @example
     * // Create one AMLTransactionMonitoring
     * const AMLTransactionMonitoring = await prisma.aMLTransactionMonitoring.create({
     *   data: {
     *     // ... data to create a AMLTransactionMonitoring
     *   }
     * })
     * 
     */
    create<T extends AMLTransactionMonitoringCreateArgs>(args: SelectSubset<T, AMLTransactionMonitoringCreateArgs<ExtArgs>>): Prisma__AMLTransactionMonitoringClient<$Result.GetResult<Prisma.$AMLTransactionMonitoringPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AMLTransactionMonitorings.
     * @param {AMLTransactionMonitoringCreateManyArgs} args - Arguments to create many AMLTransactionMonitorings.
     * @example
     * // Create many AMLTransactionMonitorings
     * const aMLTransactionMonitoring = await prisma.aMLTransactionMonitoring.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AMLTransactionMonitoringCreateManyArgs>(args?: SelectSubset<T, AMLTransactionMonitoringCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AMLTransactionMonitorings and returns the data saved in the database.
     * @param {AMLTransactionMonitoringCreateManyAndReturnArgs} args - Arguments to create many AMLTransactionMonitorings.
     * @example
     * // Create many AMLTransactionMonitorings
     * const aMLTransactionMonitoring = await prisma.aMLTransactionMonitoring.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AMLTransactionMonitorings and only return the `id`
     * const aMLTransactionMonitoringWithIdOnly = await prisma.aMLTransactionMonitoring.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AMLTransactionMonitoringCreateManyAndReturnArgs>(args?: SelectSubset<T, AMLTransactionMonitoringCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AMLTransactionMonitoringPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AMLTransactionMonitoring.
     * @param {AMLTransactionMonitoringDeleteArgs} args - Arguments to delete one AMLTransactionMonitoring.
     * @example
     * // Delete one AMLTransactionMonitoring
     * const AMLTransactionMonitoring = await prisma.aMLTransactionMonitoring.delete({
     *   where: {
     *     // ... filter to delete one AMLTransactionMonitoring
     *   }
     * })
     * 
     */
    delete<T extends AMLTransactionMonitoringDeleteArgs>(args: SelectSubset<T, AMLTransactionMonitoringDeleteArgs<ExtArgs>>): Prisma__AMLTransactionMonitoringClient<$Result.GetResult<Prisma.$AMLTransactionMonitoringPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AMLTransactionMonitoring.
     * @param {AMLTransactionMonitoringUpdateArgs} args - Arguments to update one AMLTransactionMonitoring.
     * @example
     * // Update one AMLTransactionMonitoring
     * const aMLTransactionMonitoring = await prisma.aMLTransactionMonitoring.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AMLTransactionMonitoringUpdateArgs>(args: SelectSubset<T, AMLTransactionMonitoringUpdateArgs<ExtArgs>>): Prisma__AMLTransactionMonitoringClient<$Result.GetResult<Prisma.$AMLTransactionMonitoringPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AMLTransactionMonitorings.
     * @param {AMLTransactionMonitoringDeleteManyArgs} args - Arguments to filter AMLTransactionMonitorings to delete.
     * @example
     * // Delete a few AMLTransactionMonitorings
     * const { count } = await prisma.aMLTransactionMonitoring.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AMLTransactionMonitoringDeleteManyArgs>(args?: SelectSubset<T, AMLTransactionMonitoringDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AMLTransactionMonitorings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AMLTransactionMonitoringUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AMLTransactionMonitorings
     * const aMLTransactionMonitoring = await prisma.aMLTransactionMonitoring.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AMLTransactionMonitoringUpdateManyArgs>(args: SelectSubset<T, AMLTransactionMonitoringUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AMLTransactionMonitorings and returns the data updated in the database.
     * @param {AMLTransactionMonitoringUpdateManyAndReturnArgs} args - Arguments to update many AMLTransactionMonitorings.
     * @example
     * // Update many AMLTransactionMonitorings
     * const aMLTransactionMonitoring = await prisma.aMLTransactionMonitoring.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AMLTransactionMonitorings and only return the `id`
     * const aMLTransactionMonitoringWithIdOnly = await prisma.aMLTransactionMonitoring.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AMLTransactionMonitoringUpdateManyAndReturnArgs>(args: SelectSubset<T, AMLTransactionMonitoringUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AMLTransactionMonitoringPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AMLTransactionMonitoring.
     * @param {AMLTransactionMonitoringUpsertArgs} args - Arguments to update or create a AMLTransactionMonitoring.
     * @example
     * // Update or create a AMLTransactionMonitoring
     * const aMLTransactionMonitoring = await prisma.aMLTransactionMonitoring.upsert({
     *   create: {
     *     // ... data to create a AMLTransactionMonitoring
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AMLTransactionMonitoring we want to update
     *   }
     * })
     */
    upsert<T extends AMLTransactionMonitoringUpsertArgs>(args: SelectSubset<T, AMLTransactionMonitoringUpsertArgs<ExtArgs>>): Prisma__AMLTransactionMonitoringClient<$Result.GetResult<Prisma.$AMLTransactionMonitoringPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AMLTransactionMonitorings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AMLTransactionMonitoringCountArgs} args - Arguments to filter AMLTransactionMonitorings to count.
     * @example
     * // Count the number of AMLTransactionMonitorings
     * const count = await prisma.aMLTransactionMonitoring.count({
     *   where: {
     *     // ... the filter for the AMLTransactionMonitorings we want to count
     *   }
     * })
    **/
    count<T extends AMLTransactionMonitoringCountArgs>(
      args?: Subset<T, AMLTransactionMonitoringCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AMLTransactionMonitoringCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AMLTransactionMonitoring.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AMLTransactionMonitoringAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AMLTransactionMonitoringAggregateArgs>(args: Subset<T, AMLTransactionMonitoringAggregateArgs>): Prisma.PrismaPromise<GetAMLTransactionMonitoringAggregateType<T>>

    /**
     * Group by AMLTransactionMonitoring.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AMLTransactionMonitoringGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AMLTransactionMonitoringGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AMLTransactionMonitoringGroupByArgs['orderBy'] }
        : { orderBy?: AMLTransactionMonitoringGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AMLTransactionMonitoringGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAMLTransactionMonitoringGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AMLTransactionMonitoring model
   */
  readonly fields: AMLTransactionMonitoringFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AMLTransactionMonitoring.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AMLTransactionMonitoringClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AMLTransactionMonitoring model
   */
  interface AMLTransactionMonitoringFieldRefs {
    readonly id: FieldRef<"AMLTransactionMonitoring", 'String'>
    readonly userId: FieldRef<"AMLTransactionMonitoring", 'String'>
    readonly transactionId: FieldRef<"AMLTransactionMonitoring", 'String'>
    readonly monitoringType: FieldRef<"AMLTransactionMonitoring", 'AMLMonitoringType'>
    readonly riskScore: FieldRef<"AMLTransactionMonitoring", 'Decimal'>
    readonly riskFactors: FieldRef<"AMLTransactionMonitoring", 'String[]'>
    readonly amount: FieldRef<"AMLTransactionMonitoring", 'Decimal'>
    readonly currency: FieldRef<"AMLTransactionMonitoring", 'String'>
    readonly patternType: FieldRef<"AMLTransactionMonitoring", 'String'>
    readonly patternDetails: FieldRef<"AMLTransactionMonitoring", 'Json'>
    readonly velocityScore: FieldRef<"AMLTransactionMonitoring", 'Decimal'>
    readonly requiresReview: FieldRef<"AMLTransactionMonitoring", 'Boolean'>
    readonly reviewedBy: FieldRef<"AMLTransactionMonitoring", 'String'>
    readonly reviewedAt: FieldRef<"AMLTransactionMonitoring", 'DateTime'>
    readonly reportedToAUSTRAC: FieldRef<"AMLTransactionMonitoring", 'Boolean'>
    readonly reportReference: FieldRef<"AMLTransactionMonitoring", 'String'>
    readonly reportedAt: FieldRef<"AMLTransactionMonitoring", 'DateTime'>
    readonly falsePositive: FieldRef<"AMLTransactionMonitoring", 'Boolean'>
    readonly notes: FieldRef<"AMLTransactionMonitoring", 'String'>
    readonly createdAt: FieldRef<"AMLTransactionMonitoring", 'DateTime'>
    readonly updatedAt: FieldRef<"AMLTransactionMonitoring", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AMLTransactionMonitoring findUnique
   */
  export type AMLTransactionMonitoringFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AMLTransactionMonitoring
     */
    select?: AMLTransactionMonitoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AMLTransactionMonitoring
     */
    omit?: AMLTransactionMonitoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AMLTransactionMonitoringInclude<ExtArgs> | null
    /**
     * Filter, which AMLTransactionMonitoring to fetch.
     */
    where: AMLTransactionMonitoringWhereUniqueInput
  }

  /**
   * AMLTransactionMonitoring findUniqueOrThrow
   */
  export type AMLTransactionMonitoringFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AMLTransactionMonitoring
     */
    select?: AMLTransactionMonitoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AMLTransactionMonitoring
     */
    omit?: AMLTransactionMonitoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AMLTransactionMonitoringInclude<ExtArgs> | null
    /**
     * Filter, which AMLTransactionMonitoring to fetch.
     */
    where: AMLTransactionMonitoringWhereUniqueInput
  }

  /**
   * AMLTransactionMonitoring findFirst
   */
  export type AMLTransactionMonitoringFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AMLTransactionMonitoring
     */
    select?: AMLTransactionMonitoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AMLTransactionMonitoring
     */
    omit?: AMLTransactionMonitoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AMLTransactionMonitoringInclude<ExtArgs> | null
    /**
     * Filter, which AMLTransactionMonitoring to fetch.
     */
    where?: AMLTransactionMonitoringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AMLTransactionMonitorings to fetch.
     */
    orderBy?: AMLTransactionMonitoringOrderByWithRelationInput | AMLTransactionMonitoringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AMLTransactionMonitorings.
     */
    cursor?: AMLTransactionMonitoringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AMLTransactionMonitorings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AMLTransactionMonitorings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AMLTransactionMonitorings.
     */
    distinct?: AMLTransactionMonitoringScalarFieldEnum | AMLTransactionMonitoringScalarFieldEnum[]
  }

  /**
   * AMLTransactionMonitoring findFirstOrThrow
   */
  export type AMLTransactionMonitoringFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AMLTransactionMonitoring
     */
    select?: AMLTransactionMonitoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AMLTransactionMonitoring
     */
    omit?: AMLTransactionMonitoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AMLTransactionMonitoringInclude<ExtArgs> | null
    /**
     * Filter, which AMLTransactionMonitoring to fetch.
     */
    where?: AMLTransactionMonitoringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AMLTransactionMonitorings to fetch.
     */
    orderBy?: AMLTransactionMonitoringOrderByWithRelationInput | AMLTransactionMonitoringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AMLTransactionMonitorings.
     */
    cursor?: AMLTransactionMonitoringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AMLTransactionMonitorings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AMLTransactionMonitorings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AMLTransactionMonitorings.
     */
    distinct?: AMLTransactionMonitoringScalarFieldEnum | AMLTransactionMonitoringScalarFieldEnum[]
  }

  /**
   * AMLTransactionMonitoring findMany
   */
  export type AMLTransactionMonitoringFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AMLTransactionMonitoring
     */
    select?: AMLTransactionMonitoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AMLTransactionMonitoring
     */
    omit?: AMLTransactionMonitoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AMLTransactionMonitoringInclude<ExtArgs> | null
    /**
     * Filter, which AMLTransactionMonitorings to fetch.
     */
    where?: AMLTransactionMonitoringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AMLTransactionMonitorings to fetch.
     */
    orderBy?: AMLTransactionMonitoringOrderByWithRelationInput | AMLTransactionMonitoringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AMLTransactionMonitorings.
     */
    cursor?: AMLTransactionMonitoringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AMLTransactionMonitorings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AMLTransactionMonitorings.
     */
    skip?: number
    distinct?: AMLTransactionMonitoringScalarFieldEnum | AMLTransactionMonitoringScalarFieldEnum[]
  }

  /**
   * AMLTransactionMonitoring create
   */
  export type AMLTransactionMonitoringCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AMLTransactionMonitoring
     */
    select?: AMLTransactionMonitoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AMLTransactionMonitoring
     */
    omit?: AMLTransactionMonitoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AMLTransactionMonitoringInclude<ExtArgs> | null
    /**
     * The data needed to create a AMLTransactionMonitoring.
     */
    data: XOR<AMLTransactionMonitoringCreateInput, AMLTransactionMonitoringUncheckedCreateInput>
  }

  /**
   * AMLTransactionMonitoring createMany
   */
  export type AMLTransactionMonitoringCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AMLTransactionMonitorings.
     */
    data: AMLTransactionMonitoringCreateManyInput | AMLTransactionMonitoringCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AMLTransactionMonitoring createManyAndReturn
   */
  export type AMLTransactionMonitoringCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AMLTransactionMonitoring
     */
    select?: AMLTransactionMonitoringSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AMLTransactionMonitoring
     */
    omit?: AMLTransactionMonitoringOmit<ExtArgs> | null
    /**
     * The data used to create many AMLTransactionMonitorings.
     */
    data: AMLTransactionMonitoringCreateManyInput | AMLTransactionMonitoringCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AMLTransactionMonitoringIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AMLTransactionMonitoring update
   */
  export type AMLTransactionMonitoringUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AMLTransactionMonitoring
     */
    select?: AMLTransactionMonitoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AMLTransactionMonitoring
     */
    omit?: AMLTransactionMonitoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AMLTransactionMonitoringInclude<ExtArgs> | null
    /**
     * The data needed to update a AMLTransactionMonitoring.
     */
    data: XOR<AMLTransactionMonitoringUpdateInput, AMLTransactionMonitoringUncheckedUpdateInput>
    /**
     * Choose, which AMLTransactionMonitoring to update.
     */
    where: AMLTransactionMonitoringWhereUniqueInput
  }

  /**
   * AMLTransactionMonitoring updateMany
   */
  export type AMLTransactionMonitoringUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AMLTransactionMonitorings.
     */
    data: XOR<AMLTransactionMonitoringUpdateManyMutationInput, AMLTransactionMonitoringUncheckedUpdateManyInput>
    /**
     * Filter which AMLTransactionMonitorings to update
     */
    where?: AMLTransactionMonitoringWhereInput
    /**
     * Limit how many AMLTransactionMonitorings to update.
     */
    limit?: number
  }

  /**
   * AMLTransactionMonitoring updateManyAndReturn
   */
  export type AMLTransactionMonitoringUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AMLTransactionMonitoring
     */
    select?: AMLTransactionMonitoringSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AMLTransactionMonitoring
     */
    omit?: AMLTransactionMonitoringOmit<ExtArgs> | null
    /**
     * The data used to update AMLTransactionMonitorings.
     */
    data: XOR<AMLTransactionMonitoringUpdateManyMutationInput, AMLTransactionMonitoringUncheckedUpdateManyInput>
    /**
     * Filter which AMLTransactionMonitorings to update
     */
    where?: AMLTransactionMonitoringWhereInput
    /**
     * Limit how many AMLTransactionMonitorings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AMLTransactionMonitoringIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AMLTransactionMonitoring upsert
   */
  export type AMLTransactionMonitoringUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AMLTransactionMonitoring
     */
    select?: AMLTransactionMonitoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AMLTransactionMonitoring
     */
    omit?: AMLTransactionMonitoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AMLTransactionMonitoringInclude<ExtArgs> | null
    /**
     * The filter to search for the AMLTransactionMonitoring to update in case it exists.
     */
    where: AMLTransactionMonitoringWhereUniqueInput
    /**
     * In case the AMLTransactionMonitoring found by the `where` argument doesn't exist, create a new AMLTransactionMonitoring with this data.
     */
    create: XOR<AMLTransactionMonitoringCreateInput, AMLTransactionMonitoringUncheckedCreateInput>
    /**
     * In case the AMLTransactionMonitoring was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AMLTransactionMonitoringUpdateInput, AMLTransactionMonitoringUncheckedUpdateInput>
  }

  /**
   * AMLTransactionMonitoring delete
   */
  export type AMLTransactionMonitoringDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AMLTransactionMonitoring
     */
    select?: AMLTransactionMonitoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AMLTransactionMonitoring
     */
    omit?: AMLTransactionMonitoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AMLTransactionMonitoringInclude<ExtArgs> | null
    /**
     * Filter which AMLTransactionMonitoring to delete.
     */
    where: AMLTransactionMonitoringWhereUniqueInput
  }

  /**
   * AMLTransactionMonitoring deleteMany
   */
  export type AMLTransactionMonitoringDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AMLTransactionMonitorings to delete
     */
    where?: AMLTransactionMonitoringWhereInput
    /**
     * Limit how many AMLTransactionMonitorings to delete.
     */
    limit?: number
  }

  /**
   * AMLTransactionMonitoring without action
   */
  export type AMLTransactionMonitoringDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AMLTransactionMonitoring
     */
    select?: AMLTransactionMonitoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AMLTransactionMonitoring
     */
    omit?: AMLTransactionMonitoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AMLTransactionMonitoringInclude<ExtArgs> | null
  }


  /**
   * Model PrivacyConsent
   */

  export type AggregatePrivacyConsent = {
    _count: PrivacyConsentCountAggregateOutputType | null
    _min: PrivacyConsentMinAggregateOutputType | null
    _max: PrivacyConsentMaxAggregateOutputType | null
  }

  export type PrivacyConsentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    consentType: $Enums.ConsentType | null
    consentVersion: string | null
    consentStatus: $Enums.ConsentStatus | null
    consentDate: Date | null
    expiryDate: Date | null
    withdrawnAt: Date | null
    withdrawalReason: string | null
    legalBasis: string | null
    jurisdiction: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivacyConsentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    consentType: $Enums.ConsentType | null
    consentVersion: string | null
    consentStatus: $Enums.ConsentStatus | null
    consentDate: Date | null
    expiryDate: Date | null
    withdrawnAt: Date | null
    withdrawalReason: string | null
    legalBasis: string | null
    jurisdiction: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivacyConsentCountAggregateOutputType = {
    id: number
    userId: number
    consentType: number
    consentVersion: number
    consentStatus: number
    consentDate: number
    expiryDate: number
    purposes: number
    dataCategories: number
    thirdParties: number
    withdrawnAt: number
    withdrawalReason: number
    legalBasis: number
    jurisdiction: number
    ipAddress: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PrivacyConsentMinAggregateInputType = {
    id?: true
    userId?: true
    consentType?: true
    consentVersion?: true
    consentStatus?: true
    consentDate?: true
    expiryDate?: true
    withdrawnAt?: true
    withdrawalReason?: true
    legalBasis?: true
    jurisdiction?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivacyConsentMaxAggregateInputType = {
    id?: true
    userId?: true
    consentType?: true
    consentVersion?: true
    consentStatus?: true
    consentDate?: true
    expiryDate?: true
    withdrawnAt?: true
    withdrawalReason?: true
    legalBasis?: true
    jurisdiction?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivacyConsentCountAggregateInputType = {
    id?: true
    userId?: true
    consentType?: true
    consentVersion?: true
    consentStatus?: true
    consentDate?: true
    expiryDate?: true
    purposes?: true
    dataCategories?: true
    thirdParties?: true
    withdrawnAt?: true
    withdrawalReason?: true
    legalBasis?: true
    jurisdiction?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PrivacyConsentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivacyConsent to aggregate.
     */
    where?: PrivacyConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyConsents to fetch.
     */
    orderBy?: PrivacyConsentOrderByWithRelationInput | PrivacyConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrivacyConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrivacyConsents
    **/
    _count?: true | PrivacyConsentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrivacyConsentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrivacyConsentMaxAggregateInputType
  }

  export type GetPrivacyConsentAggregateType<T extends PrivacyConsentAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivacyConsent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivacyConsent[P]>
      : GetScalarType<T[P], AggregatePrivacyConsent[P]>
  }




  export type PrivacyConsentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivacyConsentWhereInput
    orderBy?: PrivacyConsentOrderByWithAggregationInput | PrivacyConsentOrderByWithAggregationInput[]
    by: PrivacyConsentScalarFieldEnum[] | PrivacyConsentScalarFieldEnum
    having?: PrivacyConsentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrivacyConsentCountAggregateInputType | true
    _min?: PrivacyConsentMinAggregateInputType
    _max?: PrivacyConsentMaxAggregateInputType
  }

  export type PrivacyConsentGroupByOutputType = {
    id: string
    userId: string
    consentType: $Enums.ConsentType
    consentVersion: string
    consentStatus: $Enums.ConsentStatus
    consentDate: Date | null
    expiryDate: Date | null
    purposes: string[]
    dataCategories: string[]
    thirdParties: string[]
    withdrawnAt: Date | null
    withdrawalReason: string | null
    legalBasis: string
    jurisdiction: string
    ipAddress: string
    userAgent: string | null
    createdAt: Date
    updatedAt: Date
    _count: PrivacyConsentCountAggregateOutputType | null
    _min: PrivacyConsentMinAggregateOutputType | null
    _max: PrivacyConsentMaxAggregateOutputType | null
  }

  type GetPrivacyConsentGroupByPayload<T extends PrivacyConsentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrivacyConsentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrivacyConsentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrivacyConsentGroupByOutputType[P]>
            : GetScalarType<T[P], PrivacyConsentGroupByOutputType[P]>
        }
      >
    >


  export type PrivacyConsentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    consentType?: boolean
    consentVersion?: boolean
    consentStatus?: boolean
    consentDate?: boolean
    expiryDate?: boolean
    purposes?: boolean
    dataCategories?: boolean
    thirdParties?: boolean
    withdrawnAt?: boolean
    withdrawalReason?: boolean
    legalBasis?: boolean
    jurisdiction?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privacyConsent"]>

  export type PrivacyConsentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    consentType?: boolean
    consentVersion?: boolean
    consentStatus?: boolean
    consentDate?: boolean
    expiryDate?: boolean
    purposes?: boolean
    dataCategories?: boolean
    thirdParties?: boolean
    withdrawnAt?: boolean
    withdrawalReason?: boolean
    legalBasis?: boolean
    jurisdiction?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privacyConsent"]>

  export type PrivacyConsentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    consentType?: boolean
    consentVersion?: boolean
    consentStatus?: boolean
    consentDate?: boolean
    expiryDate?: boolean
    purposes?: boolean
    dataCategories?: boolean
    thirdParties?: boolean
    withdrawnAt?: boolean
    withdrawalReason?: boolean
    legalBasis?: boolean
    jurisdiction?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privacyConsent"]>

  export type PrivacyConsentSelectScalar = {
    id?: boolean
    userId?: boolean
    consentType?: boolean
    consentVersion?: boolean
    consentStatus?: boolean
    consentDate?: boolean
    expiryDate?: boolean
    purposes?: boolean
    dataCategories?: boolean
    thirdParties?: boolean
    withdrawnAt?: boolean
    withdrawalReason?: boolean
    legalBasis?: boolean
    jurisdiction?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PrivacyConsentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "consentType" | "consentVersion" | "consentStatus" | "consentDate" | "expiryDate" | "purposes" | "dataCategories" | "thirdParties" | "withdrawnAt" | "withdrawalReason" | "legalBasis" | "jurisdiction" | "ipAddress" | "userAgent" | "createdAt" | "updatedAt", ExtArgs["result"]["privacyConsent"]>
  export type PrivacyConsentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PrivacyConsentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PrivacyConsentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PrivacyConsentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrivacyConsent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      consentType: $Enums.ConsentType
      consentVersion: string
      consentStatus: $Enums.ConsentStatus
      consentDate: Date | null
      expiryDate: Date | null
      purposes: string[]
      dataCategories: string[]
      thirdParties: string[]
      withdrawnAt: Date | null
      withdrawalReason: string | null
      legalBasis: string
      jurisdiction: string
      ipAddress: string
      userAgent: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["privacyConsent"]>
    composites: {}
  }

  type PrivacyConsentGetPayload<S extends boolean | null | undefined | PrivacyConsentDefaultArgs> = $Result.GetResult<Prisma.$PrivacyConsentPayload, S>

  type PrivacyConsentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrivacyConsentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrivacyConsentCountAggregateInputType | true
    }

  export interface PrivacyConsentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrivacyConsent'], meta: { name: 'PrivacyConsent' } }
    /**
     * Find zero or one PrivacyConsent that matches the filter.
     * @param {PrivacyConsentFindUniqueArgs} args - Arguments to find a PrivacyConsent
     * @example
     * // Get one PrivacyConsent
     * const privacyConsent = await prisma.privacyConsent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrivacyConsentFindUniqueArgs>(args: SelectSubset<T, PrivacyConsentFindUniqueArgs<ExtArgs>>): Prisma__PrivacyConsentClient<$Result.GetResult<Prisma.$PrivacyConsentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrivacyConsent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrivacyConsentFindUniqueOrThrowArgs} args - Arguments to find a PrivacyConsent
     * @example
     * // Get one PrivacyConsent
     * const privacyConsent = await prisma.privacyConsent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrivacyConsentFindUniqueOrThrowArgs>(args: SelectSubset<T, PrivacyConsentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrivacyConsentClient<$Result.GetResult<Prisma.$PrivacyConsentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivacyConsent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyConsentFindFirstArgs} args - Arguments to find a PrivacyConsent
     * @example
     * // Get one PrivacyConsent
     * const privacyConsent = await prisma.privacyConsent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrivacyConsentFindFirstArgs>(args?: SelectSubset<T, PrivacyConsentFindFirstArgs<ExtArgs>>): Prisma__PrivacyConsentClient<$Result.GetResult<Prisma.$PrivacyConsentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivacyConsent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyConsentFindFirstOrThrowArgs} args - Arguments to find a PrivacyConsent
     * @example
     * // Get one PrivacyConsent
     * const privacyConsent = await prisma.privacyConsent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrivacyConsentFindFirstOrThrowArgs>(args?: SelectSubset<T, PrivacyConsentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrivacyConsentClient<$Result.GetResult<Prisma.$PrivacyConsentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrivacyConsents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyConsentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrivacyConsents
     * const privacyConsents = await prisma.privacyConsent.findMany()
     * 
     * // Get first 10 PrivacyConsents
     * const privacyConsents = await prisma.privacyConsent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privacyConsentWithIdOnly = await prisma.privacyConsent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrivacyConsentFindManyArgs>(args?: SelectSubset<T, PrivacyConsentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivacyConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrivacyConsent.
     * @param {PrivacyConsentCreateArgs} args - Arguments to create a PrivacyConsent.
     * @example
     * // Create one PrivacyConsent
     * const PrivacyConsent = await prisma.privacyConsent.create({
     *   data: {
     *     // ... data to create a PrivacyConsent
     *   }
     * })
     * 
     */
    create<T extends PrivacyConsentCreateArgs>(args: SelectSubset<T, PrivacyConsentCreateArgs<ExtArgs>>): Prisma__PrivacyConsentClient<$Result.GetResult<Prisma.$PrivacyConsentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrivacyConsents.
     * @param {PrivacyConsentCreateManyArgs} args - Arguments to create many PrivacyConsents.
     * @example
     * // Create many PrivacyConsents
     * const privacyConsent = await prisma.privacyConsent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrivacyConsentCreateManyArgs>(args?: SelectSubset<T, PrivacyConsentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrivacyConsents and returns the data saved in the database.
     * @param {PrivacyConsentCreateManyAndReturnArgs} args - Arguments to create many PrivacyConsents.
     * @example
     * // Create many PrivacyConsents
     * const privacyConsent = await prisma.privacyConsent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrivacyConsents and only return the `id`
     * const privacyConsentWithIdOnly = await prisma.privacyConsent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrivacyConsentCreateManyAndReturnArgs>(args?: SelectSubset<T, PrivacyConsentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivacyConsentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PrivacyConsent.
     * @param {PrivacyConsentDeleteArgs} args - Arguments to delete one PrivacyConsent.
     * @example
     * // Delete one PrivacyConsent
     * const PrivacyConsent = await prisma.privacyConsent.delete({
     *   where: {
     *     // ... filter to delete one PrivacyConsent
     *   }
     * })
     * 
     */
    delete<T extends PrivacyConsentDeleteArgs>(args: SelectSubset<T, PrivacyConsentDeleteArgs<ExtArgs>>): Prisma__PrivacyConsentClient<$Result.GetResult<Prisma.$PrivacyConsentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrivacyConsent.
     * @param {PrivacyConsentUpdateArgs} args - Arguments to update one PrivacyConsent.
     * @example
     * // Update one PrivacyConsent
     * const privacyConsent = await prisma.privacyConsent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrivacyConsentUpdateArgs>(args: SelectSubset<T, PrivacyConsentUpdateArgs<ExtArgs>>): Prisma__PrivacyConsentClient<$Result.GetResult<Prisma.$PrivacyConsentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrivacyConsents.
     * @param {PrivacyConsentDeleteManyArgs} args - Arguments to filter PrivacyConsents to delete.
     * @example
     * // Delete a few PrivacyConsents
     * const { count } = await prisma.privacyConsent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrivacyConsentDeleteManyArgs>(args?: SelectSubset<T, PrivacyConsentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivacyConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyConsentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrivacyConsents
     * const privacyConsent = await prisma.privacyConsent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrivacyConsentUpdateManyArgs>(args: SelectSubset<T, PrivacyConsentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivacyConsents and returns the data updated in the database.
     * @param {PrivacyConsentUpdateManyAndReturnArgs} args - Arguments to update many PrivacyConsents.
     * @example
     * // Update many PrivacyConsents
     * const privacyConsent = await prisma.privacyConsent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PrivacyConsents and only return the `id`
     * const privacyConsentWithIdOnly = await prisma.privacyConsent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrivacyConsentUpdateManyAndReturnArgs>(args: SelectSubset<T, PrivacyConsentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivacyConsentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PrivacyConsent.
     * @param {PrivacyConsentUpsertArgs} args - Arguments to update or create a PrivacyConsent.
     * @example
     * // Update or create a PrivacyConsent
     * const privacyConsent = await prisma.privacyConsent.upsert({
     *   create: {
     *     // ... data to create a PrivacyConsent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrivacyConsent we want to update
     *   }
     * })
     */
    upsert<T extends PrivacyConsentUpsertArgs>(args: SelectSubset<T, PrivacyConsentUpsertArgs<ExtArgs>>): Prisma__PrivacyConsentClient<$Result.GetResult<Prisma.$PrivacyConsentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrivacyConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyConsentCountArgs} args - Arguments to filter PrivacyConsents to count.
     * @example
     * // Count the number of PrivacyConsents
     * const count = await prisma.privacyConsent.count({
     *   where: {
     *     // ... the filter for the PrivacyConsents we want to count
     *   }
     * })
    **/
    count<T extends PrivacyConsentCountArgs>(
      args?: Subset<T, PrivacyConsentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrivacyConsentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrivacyConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyConsentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrivacyConsentAggregateArgs>(args: Subset<T, PrivacyConsentAggregateArgs>): Prisma.PrismaPromise<GetPrivacyConsentAggregateType<T>>

    /**
     * Group by PrivacyConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyConsentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrivacyConsentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrivacyConsentGroupByArgs['orderBy'] }
        : { orderBy?: PrivacyConsentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrivacyConsentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivacyConsentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrivacyConsent model
   */
  readonly fields: PrivacyConsentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrivacyConsent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrivacyConsentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrivacyConsent model
   */
  interface PrivacyConsentFieldRefs {
    readonly id: FieldRef<"PrivacyConsent", 'String'>
    readonly userId: FieldRef<"PrivacyConsent", 'String'>
    readonly consentType: FieldRef<"PrivacyConsent", 'ConsentType'>
    readonly consentVersion: FieldRef<"PrivacyConsent", 'String'>
    readonly consentStatus: FieldRef<"PrivacyConsent", 'ConsentStatus'>
    readonly consentDate: FieldRef<"PrivacyConsent", 'DateTime'>
    readonly expiryDate: FieldRef<"PrivacyConsent", 'DateTime'>
    readonly purposes: FieldRef<"PrivacyConsent", 'String[]'>
    readonly dataCategories: FieldRef<"PrivacyConsent", 'String[]'>
    readonly thirdParties: FieldRef<"PrivacyConsent", 'String[]'>
    readonly withdrawnAt: FieldRef<"PrivacyConsent", 'DateTime'>
    readonly withdrawalReason: FieldRef<"PrivacyConsent", 'String'>
    readonly legalBasis: FieldRef<"PrivacyConsent", 'String'>
    readonly jurisdiction: FieldRef<"PrivacyConsent", 'String'>
    readonly ipAddress: FieldRef<"PrivacyConsent", 'String'>
    readonly userAgent: FieldRef<"PrivacyConsent", 'String'>
    readonly createdAt: FieldRef<"PrivacyConsent", 'DateTime'>
    readonly updatedAt: FieldRef<"PrivacyConsent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PrivacyConsent findUnique
   */
  export type PrivacyConsentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyConsent
     */
    select?: PrivacyConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyConsent
     */
    omit?: PrivacyConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivacyConsentInclude<ExtArgs> | null
    /**
     * Filter, which PrivacyConsent to fetch.
     */
    where: PrivacyConsentWhereUniqueInput
  }

  /**
   * PrivacyConsent findUniqueOrThrow
   */
  export type PrivacyConsentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyConsent
     */
    select?: PrivacyConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyConsent
     */
    omit?: PrivacyConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivacyConsentInclude<ExtArgs> | null
    /**
     * Filter, which PrivacyConsent to fetch.
     */
    where: PrivacyConsentWhereUniqueInput
  }

  /**
   * PrivacyConsent findFirst
   */
  export type PrivacyConsentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyConsent
     */
    select?: PrivacyConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyConsent
     */
    omit?: PrivacyConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivacyConsentInclude<ExtArgs> | null
    /**
     * Filter, which PrivacyConsent to fetch.
     */
    where?: PrivacyConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyConsents to fetch.
     */
    orderBy?: PrivacyConsentOrderByWithRelationInput | PrivacyConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivacyConsents.
     */
    cursor?: PrivacyConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivacyConsents.
     */
    distinct?: PrivacyConsentScalarFieldEnum | PrivacyConsentScalarFieldEnum[]
  }

  /**
   * PrivacyConsent findFirstOrThrow
   */
  export type PrivacyConsentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyConsent
     */
    select?: PrivacyConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyConsent
     */
    omit?: PrivacyConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivacyConsentInclude<ExtArgs> | null
    /**
     * Filter, which PrivacyConsent to fetch.
     */
    where?: PrivacyConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyConsents to fetch.
     */
    orderBy?: PrivacyConsentOrderByWithRelationInput | PrivacyConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivacyConsents.
     */
    cursor?: PrivacyConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivacyConsents.
     */
    distinct?: PrivacyConsentScalarFieldEnum | PrivacyConsentScalarFieldEnum[]
  }

  /**
   * PrivacyConsent findMany
   */
  export type PrivacyConsentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyConsent
     */
    select?: PrivacyConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyConsent
     */
    omit?: PrivacyConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivacyConsentInclude<ExtArgs> | null
    /**
     * Filter, which PrivacyConsents to fetch.
     */
    where?: PrivacyConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyConsents to fetch.
     */
    orderBy?: PrivacyConsentOrderByWithRelationInput | PrivacyConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrivacyConsents.
     */
    cursor?: PrivacyConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyConsents.
     */
    skip?: number
    distinct?: PrivacyConsentScalarFieldEnum | PrivacyConsentScalarFieldEnum[]
  }

  /**
   * PrivacyConsent create
   */
  export type PrivacyConsentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyConsent
     */
    select?: PrivacyConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyConsent
     */
    omit?: PrivacyConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivacyConsentInclude<ExtArgs> | null
    /**
     * The data needed to create a PrivacyConsent.
     */
    data: XOR<PrivacyConsentCreateInput, PrivacyConsentUncheckedCreateInput>
  }

  /**
   * PrivacyConsent createMany
   */
  export type PrivacyConsentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrivacyConsents.
     */
    data: PrivacyConsentCreateManyInput | PrivacyConsentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrivacyConsent createManyAndReturn
   */
  export type PrivacyConsentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyConsent
     */
    select?: PrivacyConsentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyConsent
     */
    omit?: PrivacyConsentOmit<ExtArgs> | null
    /**
     * The data used to create many PrivacyConsents.
     */
    data: PrivacyConsentCreateManyInput | PrivacyConsentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivacyConsentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrivacyConsent update
   */
  export type PrivacyConsentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyConsent
     */
    select?: PrivacyConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyConsent
     */
    omit?: PrivacyConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivacyConsentInclude<ExtArgs> | null
    /**
     * The data needed to update a PrivacyConsent.
     */
    data: XOR<PrivacyConsentUpdateInput, PrivacyConsentUncheckedUpdateInput>
    /**
     * Choose, which PrivacyConsent to update.
     */
    where: PrivacyConsentWhereUniqueInput
  }

  /**
   * PrivacyConsent updateMany
   */
  export type PrivacyConsentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrivacyConsents.
     */
    data: XOR<PrivacyConsentUpdateManyMutationInput, PrivacyConsentUncheckedUpdateManyInput>
    /**
     * Filter which PrivacyConsents to update
     */
    where?: PrivacyConsentWhereInput
    /**
     * Limit how many PrivacyConsents to update.
     */
    limit?: number
  }

  /**
   * PrivacyConsent updateManyAndReturn
   */
  export type PrivacyConsentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyConsent
     */
    select?: PrivacyConsentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyConsent
     */
    omit?: PrivacyConsentOmit<ExtArgs> | null
    /**
     * The data used to update PrivacyConsents.
     */
    data: XOR<PrivacyConsentUpdateManyMutationInput, PrivacyConsentUncheckedUpdateManyInput>
    /**
     * Filter which PrivacyConsents to update
     */
    where?: PrivacyConsentWhereInput
    /**
     * Limit how many PrivacyConsents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivacyConsentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrivacyConsent upsert
   */
  export type PrivacyConsentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyConsent
     */
    select?: PrivacyConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyConsent
     */
    omit?: PrivacyConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivacyConsentInclude<ExtArgs> | null
    /**
     * The filter to search for the PrivacyConsent to update in case it exists.
     */
    where: PrivacyConsentWhereUniqueInput
    /**
     * In case the PrivacyConsent found by the `where` argument doesn't exist, create a new PrivacyConsent with this data.
     */
    create: XOR<PrivacyConsentCreateInput, PrivacyConsentUncheckedCreateInput>
    /**
     * In case the PrivacyConsent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrivacyConsentUpdateInput, PrivacyConsentUncheckedUpdateInput>
  }

  /**
   * PrivacyConsent delete
   */
  export type PrivacyConsentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyConsent
     */
    select?: PrivacyConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyConsent
     */
    omit?: PrivacyConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivacyConsentInclude<ExtArgs> | null
    /**
     * Filter which PrivacyConsent to delete.
     */
    where: PrivacyConsentWhereUniqueInput
  }

  /**
   * PrivacyConsent deleteMany
   */
  export type PrivacyConsentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivacyConsents to delete
     */
    where?: PrivacyConsentWhereInput
    /**
     * Limit how many PrivacyConsents to delete.
     */
    limit?: number
  }

  /**
   * PrivacyConsent without action
   */
  export type PrivacyConsentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyConsent
     */
    select?: PrivacyConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyConsent
     */
    omit?: PrivacyConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivacyConsentInclude<ExtArgs> | null
  }


  /**
   * Model DataAccessRequest
   */

  export type AggregateDataAccessRequest = {
    _count: DataAccessRequestCountAggregateOutputType | null
    _min: DataAccessRequestMinAggregateOutputType | null
    _max: DataAccessRequestMaxAggregateOutputType | null
  }

  export type DataAccessRequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    requestType: $Enums.DataRequestType | null
    requestStatus: $Enums.DataRequestStatus | null
    requestDate: Date | null
    verificationMethod: string | null
    verifiedAt: Date | null
    processedBy: string | null
    processedAt: Date | null
    completedAt: Date | null
    responseMethod: string | null
    responseUrl: string | null
    responseExpiryDate: Date | null
    dueDate: Date | null
    extensionReason: string | null
    extendedDueDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataAccessRequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    requestType: $Enums.DataRequestType | null
    requestStatus: $Enums.DataRequestStatus | null
    requestDate: Date | null
    verificationMethod: string | null
    verifiedAt: Date | null
    processedBy: string | null
    processedAt: Date | null
    completedAt: Date | null
    responseMethod: string | null
    responseUrl: string | null
    responseExpiryDate: Date | null
    dueDate: Date | null
    extensionReason: string | null
    extendedDueDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataAccessRequestCountAggregateOutputType = {
    id: number
    userId: number
    requestType: number
    requestStatus: number
    requestDate: number
    requestDetails: number
    verificationMethod: number
    verifiedAt: number
    processedBy: number
    processedAt: number
    completedAt: number
    responseMethod: number
    responseUrl: number
    responseExpiryDate: number
    dueDate: number
    extensionReason: number
    extendedDueDate: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DataAccessRequestMinAggregateInputType = {
    id?: true
    userId?: true
    requestType?: true
    requestStatus?: true
    requestDate?: true
    verificationMethod?: true
    verifiedAt?: true
    processedBy?: true
    processedAt?: true
    completedAt?: true
    responseMethod?: true
    responseUrl?: true
    responseExpiryDate?: true
    dueDate?: true
    extensionReason?: true
    extendedDueDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataAccessRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    requestType?: true
    requestStatus?: true
    requestDate?: true
    verificationMethod?: true
    verifiedAt?: true
    processedBy?: true
    processedAt?: true
    completedAt?: true
    responseMethod?: true
    responseUrl?: true
    responseExpiryDate?: true
    dueDate?: true
    extensionReason?: true
    extendedDueDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataAccessRequestCountAggregateInputType = {
    id?: true
    userId?: true
    requestType?: true
    requestStatus?: true
    requestDate?: true
    requestDetails?: true
    verificationMethod?: true
    verifiedAt?: true
    processedBy?: true
    processedAt?: true
    completedAt?: true
    responseMethod?: true
    responseUrl?: true
    responseExpiryDate?: true
    dueDate?: true
    extensionReason?: true
    extendedDueDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DataAccessRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataAccessRequest to aggregate.
     */
    where?: DataAccessRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataAccessRequests to fetch.
     */
    orderBy?: DataAccessRequestOrderByWithRelationInput | DataAccessRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataAccessRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataAccessRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataAccessRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataAccessRequests
    **/
    _count?: true | DataAccessRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataAccessRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataAccessRequestMaxAggregateInputType
  }

  export type GetDataAccessRequestAggregateType<T extends DataAccessRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateDataAccessRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataAccessRequest[P]>
      : GetScalarType<T[P], AggregateDataAccessRequest[P]>
  }




  export type DataAccessRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataAccessRequestWhereInput
    orderBy?: DataAccessRequestOrderByWithAggregationInput | DataAccessRequestOrderByWithAggregationInput[]
    by: DataAccessRequestScalarFieldEnum[] | DataAccessRequestScalarFieldEnum
    having?: DataAccessRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataAccessRequestCountAggregateInputType | true
    _min?: DataAccessRequestMinAggregateInputType
    _max?: DataAccessRequestMaxAggregateInputType
  }

  export type DataAccessRequestGroupByOutputType = {
    id: string
    userId: string
    requestType: $Enums.DataRequestType
    requestStatus: $Enums.DataRequestStatus
    requestDate: Date
    requestDetails: JsonValue | null
    verificationMethod: string | null
    verifiedAt: Date | null
    processedBy: string | null
    processedAt: Date | null
    completedAt: Date | null
    responseMethod: string | null
    responseUrl: string | null
    responseExpiryDate: Date | null
    dueDate: Date
    extensionReason: string | null
    extendedDueDate: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: DataAccessRequestCountAggregateOutputType | null
    _min: DataAccessRequestMinAggregateOutputType | null
    _max: DataAccessRequestMaxAggregateOutputType | null
  }

  type GetDataAccessRequestGroupByPayload<T extends DataAccessRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataAccessRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataAccessRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataAccessRequestGroupByOutputType[P]>
            : GetScalarType<T[P], DataAccessRequestGroupByOutputType[P]>
        }
      >
    >


  export type DataAccessRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    requestType?: boolean
    requestStatus?: boolean
    requestDate?: boolean
    requestDetails?: boolean
    verificationMethod?: boolean
    verifiedAt?: boolean
    processedBy?: boolean
    processedAt?: boolean
    completedAt?: boolean
    responseMethod?: boolean
    responseUrl?: boolean
    responseExpiryDate?: boolean
    dueDate?: boolean
    extensionReason?: boolean
    extendedDueDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataAccessRequest"]>

  export type DataAccessRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    requestType?: boolean
    requestStatus?: boolean
    requestDate?: boolean
    requestDetails?: boolean
    verificationMethod?: boolean
    verifiedAt?: boolean
    processedBy?: boolean
    processedAt?: boolean
    completedAt?: boolean
    responseMethod?: boolean
    responseUrl?: boolean
    responseExpiryDate?: boolean
    dueDate?: boolean
    extensionReason?: boolean
    extendedDueDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataAccessRequest"]>

  export type DataAccessRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    requestType?: boolean
    requestStatus?: boolean
    requestDate?: boolean
    requestDetails?: boolean
    verificationMethod?: boolean
    verifiedAt?: boolean
    processedBy?: boolean
    processedAt?: boolean
    completedAt?: boolean
    responseMethod?: boolean
    responseUrl?: boolean
    responseExpiryDate?: boolean
    dueDate?: boolean
    extensionReason?: boolean
    extendedDueDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataAccessRequest"]>

  export type DataAccessRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    requestType?: boolean
    requestStatus?: boolean
    requestDate?: boolean
    requestDetails?: boolean
    verificationMethod?: boolean
    verifiedAt?: boolean
    processedBy?: boolean
    processedAt?: boolean
    completedAt?: boolean
    responseMethod?: boolean
    responseUrl?: boolean
    responseExpiryDate?: boolean
    dueDate?: boolean
    extensionReason?: boolean
    extendedDueDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DataAccessRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "requestType" | "requestStatus" | "requestDate" | "requestDetails" | "verificationMethod" | "verifiedAt" | "processedBy" | "processedAt" | "completedAt" | "responseMethod" | "responseUrl" | "responseExpiryDate" | "dueDate" | "extensionReason" | "extendedDueDate" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["dataAccessRequest"]>
  export type DataAccessRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DataAccessRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DataAccessRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DataAccessRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataAccessRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      requestType: $Enums.DataRequestType
      requestStatus: $Enums.DataRequestStatus
      requestDate: Date
      requestDetails: Prisma.JsonValue | null
      verificationMethod: string | null
      verifiedAt: Date | null
      processedBy: string | null
      processedAt: Date | null
      completedAt: Date | null
      responseMethod: string | null
      responseUrl: string | null
      responseExpiryDate: Date | null
      dueDate: Date
      extensionReason: string | null
      extendedDueDate: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dataAccessRequest"]>
    composites: {}
  }

  type DataAccessRequestGetPayload<S extends boolean | null | undefined | DataAccessRequestDefaultArgs> = $Result.GetResult<Prisma.$DataAccessRequestPayload, S>

  type DataAccessRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataAccessRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataAccessRequestCountAggregateInputType | true
    }

  export interface DataAccessRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataAccessRequest'], meta: { name: 'DataAccessRequest' } }
    /**
     * Find zero or one DataAccessRequest that matches the filter.
     * @param {DataAccessRequestFindUniqueArgs} args - Arguments to find a DataAccessRequest
     * @example
     * // Get one DataAccessRequest
     * const dataAccessRequest = await prisma.dataAccessRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataAccessRequestFindUniqueArgs>(args: SelectSubset<T, DataAccessRequestFindUniqueArgs<ExtArgs>>): Prisma__DataAccessRequestClient<$Result.GetResult<Prisma.$DataAccessRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DataAccessRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataAccessRequestFindUniqueOrThrowArgs} args - Arguments to find a DataAccessRequest
     * @example
     * // Get one DataAccessRequest
     * const dataAccessRequest = await prisma.dataAccessRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataAccessRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, DataAccessRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataAccessRequestClient<$Result.GetResult<Prisma.$DataAccessRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataAccessRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataAccessRequestFindFirstArgs} args - Arguments to find a DataAccessRequest
     * @example
     * // Get one DataAccessRequest
     * const dataAccessRequest = await prisma.dataAccessRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataAccessRequestFindFirstArgs>(args?: SelectSubset<T, DataAccessRequestFindFirstArgs<ExtArgs>>): Prisma__DataAccessRequestClient<$Result.GetResult<Prisma.$DataAccessRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataAccessRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataAccessRequestFindFirstOrThrowArgs} args - Arguments to find a DataAccessRequest
     * @example
     * // Get one DataAccessRequest
     * const dataAccessRequest = await prisma.dataAccessRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataAccessRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, DataAccessRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataAccessRequestClient<$Result.GetResult<Prisma.$DataAccessRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataAccessRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataAccessRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataAccessRequests
     * const dataAccessRequests = await prisma.dataAccessRequest.findMany()
     * 
     * // Get first 10 DataAccessRequests
     * const dataAccessRequests = await prisma.dataAccessRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataAccessRequestWithIdOnly = await prisma.dataAccessRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataAccessRequestFindManyArgs>(args?: SelectSubset<T, DataAccessRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataAccessRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DataAccessRequest.
     * @param {DataAccessRequestCreateArgs} args - Arguments to create a DataAccessRequest.
     * @example
     * // Create one DataAccessRequest
     * const DataAccessRequest = await prisma.dataAccessRequest.create({
     *   data: {
     *     // ... data to create a DataAccessRequest
     *   }
     * })
     * 
     */
    create<T extends DataAccessRequestCreateArgs>(args: SelectSubset<T, DataAccessRequestCreateArgs<ExtArgs>>): Prisma__DataAccessRequestClient<$Result.GetResult<Prisma.$DataAccessRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DataAccessRequests.
     * @param {DataAccessRequestCreateManyArgs} args - Arguments to create many DataAccessRequests.
     * @example
     * // Create many DataAccessRequests
     * const dataAccessRequest = await prisma.dataAccessRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataAccessRequestCreateManyArgs>(args?: SelectSubset<T, DataAccessRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataAccessRequests and returns the data saved in the database.
     * @param {DataAccessRequestCreateManyAndReturnArgs} args - Arguments to create many DataAccessRequests.
     * @example
     * // Create many DataAccessRequests
     * const dataAccessRequest = await prisma.dataAccessRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataAccessRequests and only return the `id`
     * const dataAccessRequestWithIdOnly = await prisma.dataAccessRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataAccessRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, DataAccessRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataAccessRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DataAccessRequest.
     * @param {DataAccessRequestDeleteArgs} args - Arguments to delete one DataAccessRequest.
     * @example
     * // Delete one DataAccessRequest
     * const DataAccessRequest = await prisma.dataAccessRequest.delete({
     *   where: {
     *     // ... filter to delete one DataAccessRequest
     *   }
     * })
     * 
     */
    delete<T extends DataAccessRequestDeleteArgs>(args: SelectSubset<T, DataAccessRequestDeleteArgs<ExtArgs>>): Prisma__DataAccessRequestClient<$Result.GetResult<Prisma.$DataAccessRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DataAccessRequest.
     * @param {DataAccessRequestUpdateArgs} args - Arguments to update one DataAccessRequest.
     * @example
     * // Update one DataAccessRequest
     * const dataAccessRequest = await prisma.dataAccessRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataAccessRequestUpdateArgs>(args: SelectSubset<T, DataAccessRequestUpdateArgs<ExtArgs>>): Prisma__DataAccessRequestClient<$Result.GetResult<Prisma.$DataAccessRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DataAccessRequests.
     * @param {DataAccessRequestDeleteManyArgs} args - Arguments to filter DataAccessRequests to delete.
     * @example
     * // Delete a few DataAccessRequests
     * const { count } = await prisma.dataAccessRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataAccessRequestDeleteManyArgs>(args?: SelectSubset<T, DataAccessRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataAccessRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataAccessRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataAccessRequests
     * const dataAccessRequest = await prisma.dataAccessRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataAccessRequestUpdateManyArgs>(args: SelectSubset<T, DataAccessRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataAccessRequests and returns the data updated in the database.
     * @param {DataAccessRequestUpdateManyAndReturnArgs} args - Arguments to update many DataAccessRequests.
     * @example
     * // Update many DataAccessRequests
     * const dataAccessRequest = await prisma.dataAccessRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DataAccessRequests and only return the `id`
     * const dataAccessRequestWithIdOnly = await prisma.dataAccessRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DataAccessRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, DataAccessRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataAccessRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DataAccessRequest.
     * @param {DataAccessRequestUpsertArgs} args - Arguments to update or create a DataAccessRequest.
     * @example
     * // Update or create a DataAccessRequest
     * const dataAccessRequest = await prisma.dataAccessRequest.upsert({
     *   create: {
     *     // ... data to create a DataAccessRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataAccessRequest we want to update
     *   }
     * })
     */
    upsert<T extends DataAccessRequestUpsertArgs>(args: SelectSubset<T, DataAccessRequestUpsertArgs<ExtArgs>>): Prisma__DataAccessRequestClient<$Result.GetResult<Prisma.$DataAccessRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DataAccessRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataAccessRequestCountArgs} args - Arguments to filter DataAccessRequests to count.
     * @example
     * // Count the number of DataAccessRequests
     * const count = await prisma.dataAccessRequest.count({
     *   where: {
     *     // ... the filter for the DataAccessRequests we want to count
     *   }
     * })
    **/
    count<T extends DataAccessRequestCountArgs>(
      args?: Subset<T, DataAccessRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataAccessRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataAccessRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataAccessRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataAccessRequestAggregateArgs>(args: Subset<T, DataAccessRequestAggregateArgs>): Prisma.PrismaPromise<GetDataAccessRequestAggregateType<T>>

    /**
     * Group by DataAccessRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataAccessRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataAccessRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataAccessRequestGroupByArgs['orderBy'] }
        : { orderBy?: DataAccessRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataAccessRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataAccessRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataAccessRequest model
   */
  readonly fields: DataAccessRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataAccessRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataAccessRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataAccessRequest model
   */
  interface DataAccessRequestFieldRefs {
    readonly id: FieldRef<"DataAccessRequest", 'String'>
    readonly userId: FieldRef<"DataAccessRequest", 'String'>
    readonly requestType: FieldRef<"DataAccessRequest", 'DataRequestType'>
    readonly requestStatus: FieldRef<"DataAccessRequest", 'DataRequestStatus'>
    readonly requestDate: FieldRef<"DataAccessRequest", 'DateTime'>
    readonly requestDetails: FieldRef<"DataAccessRequest", 'Json'>
    readonly verificationMethod: FieldRef<"DataAccessRequest", 'String'>
    readonly verifiedAt: FieldRef<"DataAccessRequest", 'DateTime'>
    readonly processedBy: FieldRef<"DataAccessRequest", 'String'>
    readonly processedAt: FieldRef<"DataAccessRequest", 'DateTime'>
    readonly completedAt: FieldRef<"DataAccessRequest", 'DateTime'>
    readonly responseMethod: FieldRef<"DataAccessRequest", 'String'>
    readonly responseUrl: FieldRef<"DataAccessRequest", 'String'>
    readonly responseExpiryDate: FieldRef<"DataAccessRequest", 'DateTime'>
    readonly dueDate: FieldRef<"DataAccessRequest", 'DateTime'>
    readonly extensionReason: FieldRef<"DataAccessRequest", 'String'>
    readonly extendedDueDate: FieldRef<"DataAccessRequest", 'DateTime'>
    readonly notes: FieldRef<"DataAccessRequest", 'String'>
    readonly createdAt: FieldRef<"DataAccessRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"DataAccessRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataAccessRequest findUnique
   */
  export type DataAccessRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataAccessRequest
     */
    select?: DataAccessRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataAccessRequest
     */
    omit?: DataAccessRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataAccessRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataAccessRequest to fetch.
     */
    where: DataAccessRequestWhereUniqueInput
  }

  /**
   * DataAccessRequest findUniqueOrThrow
   */
  export type DataAccessRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataAccessRequest
     */
    select?: DataAccessRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataAccessRequest
     */
    omit?: DataAccessRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataAccessRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataAccessRequest to fetch.
     */
    where: DataAccessRequestWhereUniqueInput
  }

  /**
   * DataAccessRequest findFirst
   */
  export type DataAccessRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataAccessRequest
     */
    select?: DataAccessRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataAccessRequest
     */
    omit?: DataAccessRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataAccessRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataAccessRequest to fetch.
     */
    where?: DataAccessRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataAccessRequests to fetch.
     */
    orderBy?: DataAccessRequestOrderByWithRelationInput | DataAccessRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataAccessRequests.
     */
    cursor?: DataAccessRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataAccessRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataAccessRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataAccessRequests.
     */
    distinct?: DataAccessRequestScalarFieldEnum | DataAccessRequestScalarFieldEnum[]
  }

  /**
   * DataAccessRequest findFirstOrThrow
   */
  export type DataAccessRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataAccessRequest
     */
    select?: DataAccessRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataAccessRequest
     */
    omit?: DataAccessRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataAccessRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataAccessRequest to fetch.
     */
    where?: DataAccessRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataAccessRequests to fetch.
     */
    orderBy?: DataAccessRequestOrderByWithRelationInput | DataAccessRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataAccessRequests.
     */
    cursor?: DataAccessRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataAccessRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataAccessRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataAccessRequests.
     */
    distinct?: DataAccessRequestScalarFieldEnum | DataAccessRequestScalarFieldEnum[]
  }

  /**
   * DataAccessRequest findMany
   */
  export type DataAccessRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataAccessRequest
     */
    select?: DataAccessRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataAccessRequest
     */
    omit?: DataAccessRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataAccessRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataAccessRequests to fetch.
     */
    where?: DataAccessRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataAccessRequests to fetch.
     */
    orderBy?: DataAccessRequestOrderByWithRelationInput | DataAccessRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataAccessRequests.
     */
    cursor?: DataAccessRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataAccessRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataAccessRequests.
     */
    skip?: number
    distinct?: DataAccessRequestScalarFieldEnum | DataAccessRequestScalarFieldEnum[]
  }

  /**
   * DataAccessRequest create
   */
  export type DataAccessRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataAccessRequest
     */
    select?: DataAccessRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataAccessRequest
     */
    omit?: DataAccessRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataAccessRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a DataAccessRequest.
     */
    data: XOR<DataAccessRequestCreateInput, DataAccessRequestUncheckedCreateInput>
  }

  /**
   * DataAccessRequest createMany
   */
  export type DataAccessRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataAccessRequests.
     */
    data: DataAccessRequestCreateManyInput | DataAccessRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataAccessRequest createManyAndReturn
   */
  export type DataAccessRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataAccessRequest
     */
    select?: DataAccessRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataAccessRequest
     */
    omit?: DataAccessRequestOmit<ExtArgs> | null
    /**
     * The data used to create many DataAccessRequests.
     */
    data: DataAccessRequestCreateManyInput | DataAccessRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataAccessRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataAccessRequest update
   */
  export type DataAccessRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataAccessRequest
     */
    select?: DataAccessRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataAccessRequest
     */
    omit?: DataAccessRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataAccessRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a DataAccessRequest.
     */
    data: XOR<DataAccessRequestUpdateInput, DataAccessRequestUncheckedUpdateInput>
    /**
     * Choose, which DataAccessRequest to update.
     */
    where: DataAccessRequestWhereUniqueInput
  }

  /**
   * DataAccessRequest updateMany
   */
  export type DataAccessRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataAccessRequests.
     */
    data: XOR<DataAccessRequestUpdateManyMutationInput, DataAccessRequestUncheckedUpdateManyInput>
    /**
     * Filter which DataAccessRequests to update
     */
    where?: DataAccessRequestWhereInput
    /**
     * Limit how many DataAccessRequests to update.
     */
    limit?: number
  }

  /**
   * DataAccessRequest updateManyAndReturn
   */
  export type DataAccessRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataAccessRequest
     */
    select?: DataAccessRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataAccessRequest
     */
    omit?: DataAccessRequestOmit<ExtArgs> | null
    /**
     * The data used to update DataAccessRequests.
     */
    data: XOR<DataAccessRequestUpdateManyMutationInput, DataAccessRequestUncheckedUpdateManyInput>
    /**
     * Filter which DataAccessRequests to update
     */
    where?: DataAccessRequestWhereInput
    /**
     * Limit how many DataAccessRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataAccessRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataAccessRequest upsert
   */
  export type DataAccessRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataAccessRequest
     */
    select?: DataAccessRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataAccessRequest
     */
    omit?: DataAccessRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataAccessRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the DataAccessRequest to update in case it exists.
     */
    where: DataAccessRequestWhereUniqueInput
    /**
     * In case the DataAccessRequest found by the `where` argument doesn't exist, create a new DataAccessRequest with this data.
     */
    create: XOR<DataAccessRequestCreateInput, DataAccessRequestUncheckedCreateInput>
    /**
     * In case the DataAccessRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataAccessRequestUpdateInput, DataAccessRequestUncheckedUpdateInput>
  }

  /**
   * DataAccessRequest delete
   */
  export type DataAccessRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataAccessRequest
     */
    select?: DataAccessRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataAccessRequest
     */
    omit?: DataAccessRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataAccessRequestInclude<ExtArgs> | null
    /**
     * Filter which DataAccessRequest to delete.
     */
    where: DataAccessRequestWhereUniqueInput
  }

  /**
   * DataAccessRequest deleteMany
   */
  export type DataAccessRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataAccessRequests to delete
     */
    where?: DataAccessRequestWhereInput
    /**
     * Limit how many DataAccessRequests to delete.
     */
    limit?: number
  }

  /**
   * DataAccessRequest without action
   */
  export type DataAccessRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataAccessRequest
     */
    select?: DataAccessRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataAccessRequest
     */
    omit?: DataAccessRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataAccessRequestInclude<ExtArgs> | null
  }


  /**
   * Model APRAIncidentReport
   */

  export type AggregateAPRAIncidentReport = {
    _count: APRAIncidentReportCountAggregateOutputType | null
    _avg: APRAIncidentReportAvgAggregateOutputType | null
    _sum: APRAIncidentReportSumAggregateOutputType | null
    _min: APRAIncidentReportMinAggregateOutputType | null
    _max: APRAIncidentReportMaxAggregateOutputType | null
  }

  export type APRAIncidentReportAvgAggregateOutputType = {
    affectedUsers: number | null
    financialImpact: Decimal | null
    serviceDowntime: number | null
    dataRecoveryTime: number | null
  }

  export type APRAIncidentReportSumAggregateOutputType = {
    affectedUsers: number | null
    financialImpact: Decimal | null
    serviceDowntime: number | null
    dataRecoveryTime: number | null
  }

  export type APRAIncidentReportMinAggregateOutputType = {
    id: string | null
    incidentType: $Enums.IncidentType | null
    severity: $Enums.IncidentSeverity | null
    status: $Enums.IncidentStatus | null
    title: string | null
    description: string | null
    detectedAt: Date | null
    reportedAt: Date | null
    resolvedAt: Date | null
    affectedUsers: number | null
    dataCompromised: boolean | null
    financialImpact: Decimal | null
    rootCause: string | null
    reportedToAPRA: boolean | null
    apraReference: string | null
    reportedToOAIC: boolean | null
    oaicReference: string | null
    bcpActivated: boolean | null
    serviceDowntime: number | null
    dataRecoveryTime: number | null
    reportedBy: string | null
    responsibleTeam: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type APRAIncidentReportMaxAggregateOutputType = {
    id: string | null
    incidentType: $Enums.IncidentType | null
    severity: $Enums.IncidentSeverity | null
    status: $Enums.IncidentStatus | null
    title: string | null
    description: string | null
    detectedAt: Date | null
    reportedAt: Date | null
    resolvedAt: Date | null
    affectedUsers: number | null
    dataCompromised: boolean | null
    financialImpact: Decimal | null
    rootCause: string | null
    reportedToAPRA: boolean | null
    apraReference: string | null
    reportedToOAIC: boolean | null
    oaicReference: string | null
    bcpActivated: boolean | null
    serviceDowntime: number | null
    dataRecoveryTime: number | null
    reportedBy: string | null
    responsibleTeam: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type APRAIncidentReportCountAggregateOutputType = {
    id: number
    incidentType: number
    severity: number
    status: number
    title: number
    description: number
    detectedAt: number
    reportedAt: number
    resolvedAt: number
    affectedUsers: number
    affectedSystems: number
    dataCompromised: number
    financialImpact: number
    immediateActions: number
    rootCause: number
    remediation: number
    preventiveMeasures: number
    reportedToAPRA: number
    apraReference: number
    reportedToOAIC: number
    oaicReference: number
    bcpActivated: number
    serviceDowntime: number
    dataRecoveryTime: number
    reportedBy: number
    responsibleTeam: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type APRAIncidentReportAvgAggregateInputType = {
    affectedUsers?: true
    financialImpact?: true
    serviceDowntime?: true
    dataRecoveryTime?: true
  }

  export type APRAIncidentReportSumAggregateInputType = {
    affectedUsers?: true
    financialImpact?: true
    serviceDowntime?: true
    dataRecoveryTime?: true
  }

  export type APRAIncidentReportMinAggregateInputType = {
    id?: true
    incidentType?: true
    severity?: true
    status?: true
    title?: true
    description?: true
    detectedAt?: true
    reportedAt?: true
    resolvedAt?: true
    affectedUsers?: true
    dataCompromised?: true
    financialImpact?: true
    rootCause?: true
    reportedToAPRA?: true
    apraReference?: true
    reportedToOAIC?: true
    oaicReference?: true
    bcpActivated?: true
    serviceDowntime?: true
    dataRecoveryTime?: true
    reportedBy?: true
    responsibleTeam?: true
    createdAt?: true
    updatedAt?: true
  }

  export type APRAIncidentReportMaxAggregateInputType = {
    id?: true
    incidentType?: true
    severity?: true
    status?: true
    title?: true
    description?: true
    detectedAt?: true
    reportedAt?: true
    resolvedAt?: true
    affectedUsers?: true
    dataCompromised?: true
    financialImpact?: true
    rootCause?: true
    reportedToAPRA?: true
    apraReference?: true
    reportedToOAIC?: true
    oaicReference?: true
    bcpActivated?: true
    serviceDowntime?: true
    dataRecoveryTime?: true
    reportedBy?: true
    responsibleTeam?: true
    createdAt?: true
    updatedAt?: true
  }

  export type APRAIncidentReportCountAggregateInputType = {
    id?: true
    incidentType?: true
    severity?: true
    status?: true
    title?: true
    description?: true
    detectedAt?: true
    reportedAt?: true
    resolvedAt?: true
    affectedUsers?: true
    affectedSystems?: true
    dataCompromised?: true
    financialImpact?: true
    immediateActions?: true
    rootCause?: true
    remediation?: true
    preventiveMeasures?: true
    reportedToAPRA?: true
    apraReference?: true
    reportedToOAIC?: true
    oaicReference?: true
    bcpActivated?: true
    serviceDowntime?: true
    dataRecoveryTime?: true
    reportedBy?: true
    responsibleTeam?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type APRAIncidentReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which APRAIncidentReport to aggregate.
     */
    where?: APRAIncidentReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of APRAIncidentReports to fetch.
     */
    orderBy?: APRAIncidentReportOrderByWithRelationInput | APRAIncidentReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: APRAIncidentReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` APRAIncidentReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` APRAIncidentReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned APRAIncidentReports
    **/
    _count?: true | APRAIncidentReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: APRAIncidentReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: APRAIncidentReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: APRAIncidentReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: APRAIncidentReportMaxAggregateInputType
  }

  export type GetAPRAIncidentReportAggregateType<T extends APRAIncidentReportAggregateArgs> = {
        [P in keyof T & keyof AggregateAPRAIncidentReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAPRAIncidentReport[P]>
      : GetScalarType<T[P], AggregateAPRAIncidentReport[P]>
  }




  export type APRAIncidentReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: APRAIncidentReportWhereInput
    orderBy?: APRAIncidentReportOrderByWithAggregationInput | APRAIncidentReportOrderByWithAggregationInput[]
    by: APRAIncidentReportScalarFieldEnum[] | APRAIncidentReportScalarFieldEnum
    having?: APRAIncidentReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: APRAIncidentReportCountAggregateInputType | true
    _avg?: APRAIncidentReportAvgAggregateInputType
    _sum?: APRAIncidentReportSumAggregateInputType
    _min?: APRAIncidentReportMinAggregateInputType
    _max?: APRAIncidentReportMaxAggregateInputType
  }

  export type APRAIncidentReportGroupByOutputType = {
    id: string
    incidentType: $Enums.IncidentType
    severity: $Enums.IncidentSeverity
    status: $Enums.IncidentStatus
    title: string
    description: string
    detectedAt: Date
    reportedAt: Date | null
    resolvedAt: Date | null
    affectedUsers: number
    affectedSystems: string[]
    dataCompromised: boolean
    financialImpact: Decimal | null
    immediateActions: JsonValue | null
    rootCause: string | null
    remediation: JsonValue | null
    preventiveMeasures: JsonValue | null
    reportedToAPRA: boolean
    apraReference: string | null
    reportedToOAIC: boolean
    oaicReference: string | null
    bcpActivated: boolean
    serviceDowntime: number | null
    dataRecoveryTime: number | null
    reportedBy: string | null
    responsibleTeam: string | null
    createdAt: Date
    updatedAt: Date
    _count: APRAIncidentReportCountAggregateOutputType | null
    _avg: APRAIncidentReportAvgAggregateOutputType | null
    _sum: APRAIncidentReportSumAggregateOutputType | null
    _min: APRAIncidentReportMinAggregateOutputType | null
    _max: APRAIncidentReportMaxAggregateOutputType | null
  }

  type GetAPRAIncidentReportGroupByPayload<T extends APRAIncidentReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<APRAIncidentReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof APRAIncidentReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], APRAIncidentReportGroupByOutputType[P]>
            : GetScalarType<T[P], APRAIncidentReportGroupByOutputType[P]>
        }
      >
    >


  export type APRAIncidentReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incidentType?: boolean
    severity?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    detectedAt?: boolean
    reportedAt?: boolean
    resolvedAt?: boolean
    affectedUsers?: boolean
    affectedSystems?: boolean
    dataCompromised?: boolean
    financialImpact?: boolean
    immediateActions?: boolean
    rootCause?: boolean
    remediation?: boolean
    preventiveMeasures?: boolean
    reportedToAPRA?: boolean
    apraReference?: boolean
    reportedToOAIC?: boolean
    oaicReference?: boolean
    bcpActivated?: boolean
    serviceDowntime?: boolean
    dataRecoveryTime?: boolean
    reportedBy?: boolean
    responsibleTeam?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aPRAIncidentReport"]>

  export type APRAIncidentReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incidentType?: boolean
    severity?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    detectedAt?: boolean
    reportedAt?: boolean
    resolvedAt?: boolean
    affectedUsers?: boolean
    affectedSystems?: boolean
    dataCompromised?: boolean
    financialImpact?: boolean
    immediateActions?: boolean
    rootCause?: boolean
    remediation?: boolean
    preventiveMeasures?: boolean
    reportedToAPRA?: boolean
    apraReference?: boolean
    reportedToOAIC?: boolean
    oaicReference?: boolean
    bcpActivated?: boolean
    serviceDowntime?: boolean
    dataRecoveryTime?: boolean
    reportedBy?: boolean
    responsibleTeam?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aPRAIncidentReport"]>

  export type APRAIncidentReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incidentType?: boolean
    severity?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    detectedAt?: boolean
    reportedAt?: boolean
    resolvedAt?: boolean
    affectedUsers?: boolean
    affectedSystems?: boolean
    dataCompromised?: boolean
    financialImpact?: boolean
    immediateActions?: boolean
    rootCause?: boolean
    remediation?: boolean
    preventiveMeasures?: boolean
    reportedToAPRA?: boolean
    apraReference?: boolean
    reportedToOAIC?: boolean
    oaicReference?: boolean
    bcpActivated?: boolean
    serviceDowntime?: boolean
    dataRecoveryTime?: boolean
    reportedBy?: boolean
    responsibleTeam?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aPRAIncidentReport"]>

  export type APRAIncidentReportSelectScalar = {
    id?: boolean
    incidentType?: boolean
    severity?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    detectedAt?: boolean
    reportedAt?: boolean
    resolvedAt?: boolean
    affectedUsers?: boolean
    affectedSystems?: boolean
    dataCompromised?: boolean
    financialImpact?: boolean
    immediateActions?: boolean
    rootCause?: boolean
    remediation?: boolean
    preventiveMeasures?: boolean
    reportedToAPRA?: boolean
    apraReference?: boolean
    reportedToOAIC?: boolean
    oaicReference?: boolean
    bcpActivated?: boolean
    serviceDowntime?: boolean
    dataRecoveryTime?: boolean
    reportedBy?: boolean
    responsibleTeam?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type APRAIncidentReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "incidentType" | "severity" | "status" | "title" | "description" | "detectedAt" | "reportedAt" | "resolvedAt" | "affectedUsers" | "affectedSystems" | "dataCompromised" | "financialImpact" | "immediateActions" | "rootCause" | "remediation" | "preventiveMeasures" | "reportedToAPRA" | "apraReference" | "reportedToOAIC" | "oaicReference" | "bcpActivated" | "serviceDowntime" | "dataRecoveryTime" | "reportedBy" | "responsibleTeam" | "createdAt" | "updatedAt", ExtArgs["result"]["aPRAIncidentReport"]>

  export type $APRAIncidentReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "APRAIncidentReport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      incidentType: $Enums.IncidentType
      severity: $Enums.IncidentSeverity
      status: $Enums.IncidentStatus
      title: string
      description: string
      detectedAt: Date
      reportedAt: Date | null
      resolvedAt: Date | null
      affectedUsers: number
      affectedSystems: string[]
      dataCompromised: boolean
      financialImpact: Prisma.Decimal | null
      immediateActions: Prisma.JsonValue | null
      rootCause: string | null
      remediation: Prisma.JsonValue | null
      preventiveMeasures: Prisma.JsonValue | null
      reportedToAPRA: boolean
      apraReference: string | null
      reportedToOAIC: boolean
      oaicReference: string | null
      bcpActivated: boolean
      serviceDowntime: number | null
      dataRecoveryTime: number | null
      reportedBy: string | null
      responsibleTeam: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aPRAIncidentReport"]>
    composites: {}
  }

  type APRAIncidentReportGetPayload<S extends boolean | null | undefined | APRAIncidentReportDefaultArgs> = $Result.GetResult<Prisma.$APRAIncidentReportPayload, S>

  type APRAIncidentReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<APRAIncidentReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: APRAIncidentReportCountAggregateInputType | true
    }

  export interface APRAIncidentReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['APRAIncidentReport'], meta: { name: 'APRAIncidentReport' } }
    /**
     * Find zero or one APRAIncidentReport that matches the filter.
     * @param {APRAIncidentReportFindUniqueArgs} args - Arguments to find a APRAIncidentReport
     * @example
     * // Get one APRAIncidentReport
     * const aPRAIncidentReport = await prisma.aPRAIncidentReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends APRAIncidentReportFindUniqueArgs>(args: SelectSubset<T, APRAIncidentReportFindUniqueArgs<ExtArgs>>): Prisma__APRAIncidentReportClient<$Result.GetResult<Prisma.$APRAIncidentReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one APRAIncidentReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {APRAIncidentReportFindUniqueOrThrowArgs} args - Arguments to find a APRAIncidentReport
     * @example
     * // Get one APRAIncidentReport
     * const aPRAIncidentReport = await prisma.aPRAIncidentReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends APRAIncidentReportFindUniqueOrThrowArgs>(args: SelectSubset<T, APRAIncidentReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__APRAIncidentReportClient<$Result.GetResult<Prisma.$APRAIncidentReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first APRAIncidentReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APRAIncidentReportFindFirstArgs} args - Arguments to find a APRAIncidentReport
     * @example
     * // Get one APRAIncidentReport
     * const aPRAIncidentReport = await prisma.aPRAIncidentReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends APRAIncidentReportFindFirstArgs>(args?: SelectSubset<T, APRAIncidentReportFindFirstArgs<ExtArgs>>): Prisma__APRAIncidentReportClient<$Result.GetResult<Prisma.$APRAIncidentReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first APRAIncidentReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APRAIncidentReportFindFirstOrThrowArgs} args - Arguments to find a APRAIncidentReport
     * @example
     * // Get one APRAIncidentReport
     * const aPRAIncidentReport = await prisma.aPRAIncidentReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends APRAIncidentReportFindFirstOrThrowArgs>(args?: SelectSubset<T, APRAIncidentReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__APRAIncidentReportClient<$Result.GetResult<Prisma.$APRAIncidentReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more APRAIncidentReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APRAIncidentReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all APRAIncidentReports
     * const aPRAIncidentReports = await prisma.aPRAIncidentReport.findMany()
     * 
     * // Get first 10 APRAIncidentReports
     * const aPRAIncidentReports = await prisma.aPRAIncidentReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aPRAIncidentReportWithIdOnly = await prisma.aPRAIncidentReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends APRAIncidentReportFindManyArgs>(args?: SelectSubset<T, APRAIncidentReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$APRAIncidentReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a APRAIncidentReport.
     * @param {APRAIncidentReportCreateArgs} args - Arguments to create a APRAIncidentReport.
     * @example
     * // Create one APRAIncidentReport
     * const APRAIncidentReport = await prisma.aPRAIncidentReport.create({
     *   data: {
     *     // ... data to create a APRAIncidentReport
     *   }
     * })
     * 
     */
    create<T extends APRAIncidentReportCreateArgs>(args: SelectSubset<T, APRAIncidentReportCreateArgs<ExtArgs>>): Prisma__APRAIncidentReportClient<$Result.GetResult<Prisma.$APRAIncidentReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many APRAIncidentReports.
     * @param {APRAIncidentReportCreateManyArgs} args - Arguments to create many APRAIncidentReports.
     * @example
     * // Create many APRAIncidentReports
     * const aPRAIncidentReport = await prisma.aPRAIncidentReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends APRAIncidentReportCreateManyArgs>(args?: SelectSubset<T, APRAIncidentReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many APRAIncidentReports and returns the data saved in the database.
     * @param {APRAIncidentReportCreateManyAndReturnArgs} args - Arguments to create many APRAIncidentReports.
     * @example
     * // Create many APRAIncidentReports
     * const aPRAIncidentReport = await prisma.aPRAIncidentReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many APRAIncidentReports and only return the `id`
     * const aPRAIncidentReportWithIdOnly = await prisma.aPRAIncidentReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends APRAIncidentReportCreateManyAndReturnArgs>(args?: SelectSubset<T, APRAIncidentReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$APRAIncidentReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a APRAIncidentReport.
     * @param {APRAIncidentReportDeleteArgs} args - Arguments to delete one APRAIncidentReport.
     * @example
     * // Delete one APRAIncidentReport
     * const APRAIncidentReport = await prisma.aPRAIncidentReport.delete({
     *   where: {
     *     // ... filter to delete one APRAIncidentReport
     *   }
     * })
     * 
     */
    delete<T extends APRAIncidentReportDeleteArgs>(args: SelectSubset<T, APRAIncidentReportDeleteArgs<ExtArgs>>): Prisma__APRAIncidentReportClient<$Result.GetResult<Prisma.$APRAIncidentReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one APRAIncidentReport.
     * @param {APRAIncidentReportUpdateArgs} args - Arguments to update one APRAIncidentReport.
     * @example
     * // Update one APRAIncidentReport
     * const aPRAIncidentReport = await prisma.aPRAIncidentReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends APRAIncidentReportUpdateArgs>(args: SelectSubset<T, APRAIncidentReportUpdateArgs<ExtArgs>>): Prisma__APRAIncidentReportClient<$Result.GetResult<Prisma.$APRAIncidentReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more APRAIncidentReports.
     * @param {APRAIncidentReportDeleteManyArgs} args - Arguments to filter APRAIncidentReports to delete.
     * @example
     * // Delete a few APRAIncidentReports
     * const { count } = await prisma.aPRAIncidentReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends APRAIncidentReportDeleteManyArgs>(args?: SelectSubset<T, APRAIncidentReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more APRAIncidentReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APRAIncidentReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many APRAIncidentReports
     * const aPRAIncidentReport = await prisma.aPRAIncidentReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends APRAIncidentReportUpdateManyArgs>(args: SelectSubset<T, APRAIncidentReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more APRAIncidentReports and returns the data updated in the database.
     * @param {APRAIncidentReportUpdateManyAndReturnArgs} args - Arguments to update many APRAIncidentReports.
     * @example
     * // Update many APRAIncidentReports
     * const aPRAIncidentReport = await prisma.aPRAIncidentReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more APRAIncidentReports and only return the `id`
     * const aPRAIncidentReportWithIdOnly = await prisma.aPRAIncidentReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends APRAIncidentReportUpdateManyAndReturnArgs>(args: SelectSubset<T, APRAIncidentReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$APRAIncidentReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one APRAIncidentReport.
     * @param {APRAIncidentReportUpsertArgs} args - Arguments to update or create a APRAIncidentReport.
     * @example
     * // Update or create a APRAIncidentReport
     * const aPRAIncidentReport = await prisma.aPRAIncidentReport.upsert({
     *   create: {
     *     // ... data to create a APRAIncidentReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the APRAIncidentReport we want to update
     *   }
     * })
     */
    upsert<T extends APRAIncidentReportUpsertArgs>(args: SelectSubset<T, APRAIncidentReportUpsertArgs<ExtArgs>>): Prisma__APRAIncidentReportClient<$Result.GetResult<Prisma.$APRAIncidentReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of APRAIncidentReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APRAIncidentReportCountArgs} args - Arguments to filter APRAIncidentReports to count.
     * @example
     * // Count the number of APRAIncidentReports
     * const count = await prisma.aPRAIncidentReport.count({
     *   where: {
     *     // ... the filter for the APRAIncidentReports we want to count
     *   }
     * })
    **/
    count<T extends APRAIncidentReportCountArgs>(
      args?: Subset<T, APRAIncidentReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], APRAIncidentReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a APRAIncidentReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APRAIncidentReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends APRAIncidentReportAggregateArgs>(args: Subset<T, APRAIncidentReportAggregateArgs>): Prisma.PrismaPromise<GetAPRAIncidentReportAggregateType<T>>

    /**
     * Group by APRAIncidentReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APRAIncidentReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends APRAIncidentReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: APRAIncidentReportGroupByArgs['orderBy'] }
        : { orderBy?: APRAIncidentReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, APRAIncidentReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAPRAIncidentReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the APRAIncidentReport model
   */
  readonly fields: APRAIncidentReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for APRAIncidentReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__APRAIncidentReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the APRAIncidentReport model
   */
  interface APRAIncidentReportFieldRefs {
    readonly id: FieldRef<"APRAIncidentReport", 'String'>
    readonly incidentType: FieldRef<"APRAIncidentReport", 'IncidentType'>
    readonly severity: FieldRef<"APRAIncidentReport", 'IncidentSeverity'>
    readonly status: FieldRef<"APRAIncidentReport", 'IncidentStatus'>
    readonly title: FieldRef<"APRAIncidentReport", 'String'>
    readonly description: FieldRef<"APRAIncidentReport", 'String'>
    readonly detectedAt: FieldRef<"APRAIncidentReport", 'DateTime'>
    readonly reportedAt: FieldRef<"APRAIncidentReport", 'DateTime'>
    readonly resolvedAt: FieldRef<"APRAIncidentReport", 'DateTime'>
    readonly affectedUsers: FieldRef<"APRAIncidentReport", 'Int'>
    readonly affectedSystems: FieldRef<"APRAIncidentReport", 'String[]'>
    readonly dataCompromised: FieldRef<"APRAIncidentReport", 'Boolean'>
    readonly financialImpact: FieldRef<"APRAIncidentReport", 'Decimal'>
    readonly immediateActions: FieldRef<"APRAIncidentReport", 'Json'>
    readonly rootCause: FieldRef<"APRAIncidentReport", 'String'>
    readonly remediation: FieldRef<"APRAIncidentReport", 'Json'>
    readonly preventiveMeasures: FieldRef<"APRAIncidentReport", 'Json'>
    readonly reportedToAPRA: FieldRef<"APRAIncidentReport", 'Boolean'>
    readonly apraReference: FieldRef<"APRAIncidentReport", 'String'>
    readonly reportedToOAIC: FieldRef<"APRAIncidentReport", 'Boolean'>
    readonly oaicReference: FieldRef<"APRAIncidentReport", 'String'>
    readonly bcpActivated: FieldRef<"APRAIncidentReport", 'Boolean'>
    readonly serviceDowntime: FieldRef<"APRAIncidentReport", 'Int'>
    readonly dataRecoveryTime: FieldRef<"APRAIncidentReport", 'Int'>
    readonly reportedBy: FieldRef<"APRAIncidentReport", 'String'>
    readonly responsibleTeam: FieldRef<"APRAIncidentReport", 'String'>
    readonly createdAt: FieldRef<"APRAIncidentReport", 'DateTime'>
    readonly updatedAt: FieldRef<"APRAIncidentReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * APRAIncidentReport findUnique
   */
  export type APRAIncidentReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APRAIncidentReport
     */
    select?: APRAIncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APRAIncidentReport
     */
    omit?: APRAIncidentReportOmit<ExtArgs> | null
    /**
     * Filter, which APRAIncidentReport to fetch.
     */
    where: APRAIncidentReportWhereUniqueInput
  }

  /**
   * APRAIncidentReport findUniqueOrThrow
   */
  export type APRAIncidentReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APRAIncidentReport
     */
    select?: APRAIncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APRAIncidentReport
     */
    omit?: APRAIncidentReportOmit<ExtArgs> | null
    /**
     * Filter, which APRAIncidentReport to fetch.
     */
    where: APRAIncidentReportWhereUniqueInput
  }

  /**
   * APRAIncidentReport findFirst
   */
  export type APRAIncidentReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APRAIncidentReport
     */
    select?: APRAIncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APRAIncidentReport
     */
    omit?: APRAIncidentReportOmit<ExtArgs> | null
    /**
     * Filter, which APRAIncidentReport to fetch.
     */
    where?: APRAIncidentReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of APRAIncidentReports to fetch.
     */
    orderBy?: APRAIncidentReportOrderByWithRelationInput | APRAIncidentReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for APRAIncidentReports.
     */
    cursor?: APRAIncidentReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` APRAIncidentReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` APRAIncidentReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of APRAIncidentReports.
     */
    distinct?: APRAIncidentReportScalarFieldEnum | APRAIncidentReportScalarFieldEnum[]
  }

  /**
   * APRAIncidentReport findFirstOrThrow
   */
  export type APRAIncidentReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APRAIncidentReport
     */
    select?: APRAIncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APRAIncidentReport
     */
    omit?: APRAIncidentReportOmit<ExtArgs> | null
    /**
     * Filter, which APRAIncidentReport to fetch.
     */
    where?: APRAIncidentReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of APRAIncidentReports to fetch.
     */
    orderBy?: APRAIncidentReportOrderByWithRelationInput | APRAIncidentReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for APRAIncidentReports.
     */
    cursor?: APRAIncidentReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` APRAIncidentReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` APRAIncidentReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of APRAIncidentReports.
     */
    distinct?: APRAIncidentReportScalarFieldEnum | APRAIncidentReportScalarFieldEnum[]
  }

  /**
   * APRAIncidentReport findMany
   */
  export type APRAIncidentReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APRAIncidentReport
     */
    select?: APRAIncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APRAIncidentReport
     */
    omit?: APRAIncidentReportOmit<ExtArgs> | null
    /**
     * Filter, which APRAIncidentReports to fetch.
     */
    where?: APRAIncidentReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of APRAIncidentReports to fetch.
     */
    orderBy?: APRAIncidentReportOrderByWithRelationInput | APRAIncidentReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing APRAIncidentReports.
     */
    cursor?: APRAIncidentReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` APRAIncidentReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` APRAIncidentReports.
     */
    skip?: number
    distinct?: APRAIncidentReportScalarFieldEnum | APRAIncidentReportScalarFieldEnum[]
  }

  /**
   * APRAIncidentReport create
   */
  export type APRAIncidentReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APRAIncidentReport
     */
    select?: APRAIncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APRAIncidentReport
     */
    omit?: APRAIncidentReportOmit<ExtArgs> | null
    /**
     * The data needed to create a APRAIncidentReport.
     */
    data: XOR<APRAIncidentReportCreateInput, APRAIncidentReportUncheckedCreateInput>
  }

  /**
   * APRAIncidentReport createMany
   */
  export type APRAIncidentReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many APRAIncidentReports.
     */
    data: APRAIncidentReportCreateManyInput | APRAIncidentReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * APRAIncidentReport createManyAndReturn
   */
  export type APRAIncidentReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APRAIncidentReport
     */
    select?: APRAIncidentReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the APRAIncidentReport
     */
    omit?: APRAIncidentReportOmit<ExtArgs> | null
    /**
     * The data used to create many APRAIncidentReports.
     */
    data: APRAIncidentReportCreateManyInput | APRAIncidentReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * APRAIncidentReport update
   */
  export type APRAIncidentReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APRAIncidentReport
     */
    select?: APRAIncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APRAIncidentReport
     */
    omit?: APRAIncidentReportOmit<ExtArgs> | null
    /**
     * The data needed to update a APRAIncidentReport.
     */
    data: XOR<APRAIncidentReportUpdateInput, APRAIncidentReportUncheckedUpdateInput>
    /**
     * Choose, which APRAIncidentReport to update.
     */
    where: APRAIncidentReportWhereUniqueInput
  }

  /**
   * APRAIncidentReport updateMany
   */
  export type APRAIncidentReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update APRAIncidentReports.
     */
    data: XOR<APRAIncidentReportUpdateManyMutationInput, APRAIncidentReportUncheckedUpdateManyInput>
    /**
     * Filter which APRAIncidentReports to update
     */
    where?: APRAIncidentReportWhereInput
    /**
     * Limit how many APRAIncidentReports to update.
     */
    limit?: number
  }

  /**
   * APRAIncidentReport updateManyAndReturn
   */
  export type APRAIncidentReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APRAIncidentReport
     */
    select?: APRAIncidentReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the APRAIncidentReport
     */
    omit?: APRAIncidentReportOmit<ExtArgs> | null
    /**
     * The data used to update APRAIncidentReports.
     */
    data: XOR<APRAIncidentReportUpdateManyMutationInput, APRAIncidentReportUncheckedUpdateManyInput>
    /**
     * Filter which APRAIncidentReports to update
     */
    where?: APRAIncidentReportWhereInput
    /**
     * Limit how many APRAIncidentReports to update.
     */
    limit?: number
  }

  /**
   * APRAIncidentReport upsert
   */
  export type APRAIncidentReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APRAIncidentReport
     */
    select?: APRAIncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APRAIncidentReport
     */
    omit?: APRAIncidentReportOmit<ExtArgs> | null
    /**
     * The filter to search for the APRAIncidentReport to update in case it exists.
     */
    where: APRAIncidentReportWhereUniqueInput
    /**
     * In case the APRAIncidentReport found by the `where` argument doesn't exist, create a new APRAIncidentReport with this data.
     */
    create: XOR<APRAIncidentReportCreateInput, APRAIncidentReportUncheckedCreateInput>
    /**
     * In case the APRAIncidentReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<APRAIncidentReportUpdateInput, APRAIncidentReportUncheckedUpdateInput>
  }

  /**
   * APRAIncidentReport delete
   */
  export type APRAIncidentReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APRAIncidentReport
     */
    select?: APRAIncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APRAIncidentReport
     */
    omit?: APRAIncidentReportOmit<ExtArgs> | null
    /**
     * Filter which APRAIncidentReport to delete.
     */
    where: APRAIncidentReportWhereUniqueInput
  }

  /**
   * APRAIncidentReport deleteMany
   */
  export type APRAIncidentReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which APRAIncidentReports to delete
     */
    where?: APRAIncidentReportWhereInput
    /**
     * Limit how many APRAIncidentReports to delete.
     */
    limit?: number
  }

  /**
   * APRAIncidentReport without action
   */
  export type APRAIncidentReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APRAIncidentReport
     */
    select?: APRAIncidentReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APRAIncidentReport
     */
    omit?: APRAIncidentReportOmit<ExtArgs> | null
  }


  /**
   * Model GSTTransactionDetail
   */

  export type AggregateGSTTransactionDetail = {
    _count: GSTTransactionDetailCountAggregateOutputType | null
    _avg: GSTTransactionDetailAvgAggregateOutputType | null
    _sum: GSTTransactionDetailSumAggregateOutputType | null
    _min: GSTTransactionDetailMinAggregateOutputType | null
    _max: GSTTransactionDetailMaxAggregateOutputType | null
  }

  export type GSTTransactionDetailAvgAggregateOutputType = {
    baseAmount: Decimal | null
    gstRate: Decimal | null
    gstAmount: Decimal | null
    totalAmount: Decimal | null
  }

  export type GSTTransactionDetailSumAggregateOutputType = {
    baseAmount: Decimal | null
    gstRate: Decimal | null
    gstAmount: Decimal | null
    totalAmount: Decimal | null
  }

  export type GSTTransactionDetailMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    invoiceId: string | null
    baseAmount: Decimal | null
    gstRate: Decimal | null
    gstAmount: Decimal | null
    totalAmount: Decimal | null
    taxCategory: string | null
    gstTreatment: $Enums.GSTTreatment | null
    inputTaxCredit: boolean | null
    supplierABN: string | null
    supplierName: string | null
    isGSTRegistered: boolean | null
    basReportingCode: string | null
    taxPeriod: string | null
    reportedInBAS: boolean | null
    basReference: string | null
    validated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GSTTransactionDetailMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    invoiceId: string | null
    baseAmount: Decimal | null
    gstRate: Decimal | null
    gstAmount: Decimal | null
    totalAmount: Decimal | null
    taxCategory: string | null
    gstTreatment: $Enums.GSTTreatment | null
    inputTaxCredit: boolean | null
    supplierABN: string | null
    supplierName: string | null
    isGSTRegistered: boolean | null
    basReportingCode: string | null
    taxPeriod: string | null
    reportedInBAS: boolean | null
    basReference: string | null
    validated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GSTTransactionDetailCountAggregateOutputType = {
    id: number
    transactionId: number
    invoiceId: number
    baseAmount: number
    gstRate: number
    gstAmount: number
    totalAmount: number
    taxCategory: number
    gstTreatment: number
    inputTaxCredit: number
    supplierABN: number
    supplierName: number
    isGSTRegistered: number
    basReportingCode: number
    taxPeriod: number
    reportedInBAS: number
    basReference: number
    validated: number
    validationErrors: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GSTTransactionDetailAvgAggregateInputType = {
    baseAmount?: true
    gstRate?: true
    gstAmount?: true
    totalAmount?: true
  }

  export type GSTTransactionDetailSumAggregateInputType = {
    baseAmount?: true
    gstRate?: true
    gstAmount?: true
    totalAmount?: true
  }

  export type GSTTransactionDetailMinAggregateInputType = {
    id?: true
    transactionId?: true
    invoiceId?: true
    baseAmount?: true
    gstRate?: true
    gstAmount?: true
    totalAmount?: true
    taxCategory?: true
    gstTreatment?: true
    inputTaxCredit?: true
    supplierABN?: true
    supplierName?: true
    isGSTRegistered?: true
    basReportingCode?: true
    taxPeriod?: true
    reportedInBAS?: true
    basReference?: true
    validated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GSTTransactionDetailMaxAggregateInputType = {
    id?: true
    transactionId?: true
    invoiceId?: true
    baseAmount?: true
    gstRate?: true
    gstAmount?: true
    totalAmount?: true
    taxCategory?: true
    gstTreatment?: true
    inputTaxCredit?: true
    supplierABN?: true
    supplierName?: true
    isGSTRegistered?: true
    basReportingCode?: true
    taxPeriod?: true
    reportedInBAS?: true
    basReference?: true
    validated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GSTTransactionDetailCountAggregateInputType = {
    id?: true
    transactionId?: true
    invoiceId?: true
    baseAmount?: true
    gstRate?: true
    gstAmount?: true
    totalAmount?: true
    taxCategory?: true
    gstTreatment?: true
    inputTaxCredit?: true
    supplierABN?: true
    supplierName?: true
    isGSTRegistered?: true
    basReportingCode?: true
    taxPeriod?: true
    reportedInBAS?: true
    basReference?: true
    validated?: true
    validationErrors?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GSTTransactionDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GSTTransactionDetail to aggregate.
     */
    where?: GSTTransactionDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GSTTransactionDetails to fetch.
     */
    orderBy?: GSTTransactionDetailOrderByWithRelationInput | GSTTransactionDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GSTTransactionDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GSTTransactionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GSTTransactionDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GSTTransactionDetails
    **/
    _count?: true | GSTTransactionDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GSTTransactionDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GSTTransactionDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GSTTransactionDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GSTTransactionDetailMaxAggregateInputType
  }

  export type GetGSTTransactionDetailAggregateType<T extends GSTTransactionDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateGSTTransactionDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGSTTransactionDetail[P]>
      : GetScalarType<T[P], AggregateGSTTransactionDetail[P]>
  }




  export type GSTTransactionDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GSTTransactionDetailWhereInput
    orderBy?: GSTTransactionDetailOrderByWithAggregationInput | GSTTransactionDetailOrderByWithAggregationInput[]
    by: GSTTransactionDetailScalarFieldEnum[] | GSTTransactionDetailScalarFieldEnum
    having?: GSTTransactionDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GSTTransactionDetailCountAggregateInputType | true
    _avg?: GSTTransactionDetailAvgAggregateInputType
    _sum?: GSTTransactionDetailSumAggregateInputType
    _min?: GSTTransactionDetailMinAggregateInputType
    _max?: GSTTransactionDetailMaxAggregateInputType
  }

  export type GSTTransactionDetailGroupByOutputType = {
    id: string
    transactionId: string
    invoiceId: string | null
    baseAmount: Decimal
    gstRate: Decimal
    gstAmount: Decimal
    totalAmount: Decimal
    taxCategory: string
    gstTreatment: $Enums.GSTTreatment
    inputTaxCredit: boolean
    supplierABN: string | null
    supplierName: string | null
    isGSTRegistered: boolean
    basReportingCode: string | null
    taxPeriod: string
    reportedInBAS: boolean
    basReference: string | null
    validated: boolean
    validationErrors: string[]
    createdAt: Date
    updatedAt: Date
    _count: GSTTransactionDetailCountAggregateOutputType | null
    _avg: GSTTransactionDetailAvgAggregateOutputType | null
    _sum: GSTTransactionDetailSumAggregateOutputType | null
    _min: GSTTransactionDetailMinAggregateOutputType | null
    _max: GSTTransactionDetailMaxAggregateOutputType | null
  }

  type GetGSTTransactionDetailGroupByPayload<T extends GSTTransactionDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GSTTransactionDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GSTTransactionDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GSTTransactionDetailGroupByOutputType[P]>
            : GetScalarType<T[P], GSTTransactionDetailGroupByOutputType[P]>
        }
      >
    >


  export type GSTTransactionDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    invoiceId?: boolean
    baseAmount?: boolean
    gstRate?: boolean
    gstAmount?: boolean
    totalAmount?: boolean
    taxCategory?: boolean
    gstTreatment?: boolean
    inputTaxCredit?: boolean
    supplierABN?: boolean
    supplierName?: boolean
    isGSTRegistered?: boolean
    basReportingCode?: boolean
    taxPeriod?: boolean
    reportedInBAS?: boolean
    basReference?: boolean
    validated?: boolean
    validationErrors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gSTTransactionDetail"]>

  export type GSTTransactionDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    invoiceId?: boolean
    baseAmount?: boolean
    gstRate?: boolean
    gstAmount?: boolean
    totalAmount?: boolean
    taxCategory?: boolean
    gstTreatment?: boolean
    inputTaxCredit?: boolean
    supplierABN?: boolean
    supplierName?: boolean
    isGSTRegistered?: boolean
    basReportingCode?: boolean
    taxPeriod?: boolean
    reportedInBAS?: boolean
    basReference?: boolean
    validated?: boolean
    validationErrors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gSTTransactionDetail"]>

  export type GSTTransactionDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    invoiceId?: boolean
    baseAmount?: boolean
    gstRate?: boolean
    gstAmount?: boolean
    totalAmount?: boolean
    taxCategory?: boolean
    gstTreatment?: boolean
    inputTaxCredit?: boolean
    supplierABN?: boolean
    supplierName?: boolean
    isGSTRegistered?: boolean
    basReportingCode?: boolean
    taxPeriod?: boolean
    reportedInBAS?: boolean
    basReference?: boolean
    validated?: boolean
    validationErrors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gSTTransactionDetail"]>

  export type GSTTransactionDetailSelectScalar = {
    id?: boolean
    transactionId?: boolean
    invoiceId?: boolean
    baseAmount?: boolean
    gstRate?: boolean
    gstAmount?: boolean
    totalAmount?: boolean
    taxCategory?: boolean
    gstTreatment?: boolean
    inputTaxCredit?: boolean
    supplierABN?: boolean
    supplierName?: boolean
    isGSTRegistered?: boolean
    basReportingCode?: boolean
    taxPeriod?: boolean
    reportedInBAS?: boolean
    basReference?: boolean
    validated?: boolean
    validationErrors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GSTTransactionDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "invoiceId" | "baseAmount" | "gstRate" | "gstAmount" | "totalAmount" | "taxCategory" | "gstTreatment" | "inputTaxCredit" | "supplierABN" | "supplierName" | "isGSTRegistered" | "basReportingCode" | "taxPeriod" | "reportedInBAS" | "basReference" | "validated" | "validationErrors" | "createdAt" | "updatedAt", ExtArgs["result"]["gSTTransactionDetail"]>

  export type $GSTTransactionDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GSTTransactionDetail"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      invoiceId: string | null
      baseAmount: Prisma.Decimal
      gstRate: Prisma.Decimal
      gstAmount: Prisma.Decimal
      totalAmount: Prisma.Decimal
      taxCategory: string
      gstTreatment: $Enums.GSTTreatment
      inputTaxCredit: boolean
      supplierABN: string | null
      supplierName: string | null
      isGSTRegistered: boolean
      basReportingCode: string | null
      taxPeriod: string
      reportedInBAS: boolean
      basReference: string | null
      validated: boolean
      validationErrors: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gSTTransactionDetail"]>
    composites: {}
  }

  type GSTTransactionDetailGetPayload<S extends boolean | null | undefined | GSTTransactionDetailDefaultArgs> = $Result.GetResult<Prisma.$GSTTransactionDetailPayload, S>

  type GSTTransactionDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GSTTransactionDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GSTTransactionDetailCountAggregateInputType | true
    }

  export interface GSTTransactionDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GSTTransactionDetail'], meta: { name: 'GSTTransactionDetail' } }
    /**
     * Find zero or one GSTTransactionDetail that matches the filter.
     * @param {GSTTransactionDetailFindUniqueArgs} args - Arguments to find a GSTTransactionDetail
     * @example
     * // Get one GSTTransactionDetail
     * const gSTTransactionDetail = await prisma.gSTTransactionDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GSTTransactionDetailFindUniqueArgs>(args: SelectSubset<T, GSTTransactionDetailFindUniqueArgs<ExtArgs>>): Prisma__GSTTransactionDetailClient<$Result.GetResult<Prisma.$GSTTransactionDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GSTTransactionDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GSTTransactionDetailFindUniqueOrThrowArgs} args - Arguments to find a GSTTransactionDetail
     * @example
     * // Get one GSTTransactionDetail
     * const gSTTransactionDetail = await prisma.gSTTransactionDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GSTTransactionDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, GSTTransactionDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GSTTransactionDetailClient<$Result.GetResult<Prisma.$GSTTransactionDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GSTTransactionDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GSTTransactionDetailFindFirstArgs} args - Arguments to find a GSTTransactionDetail
     * @example
     * // Get one GSTTransactionDetail
     * const gSTTransactionDetail = await prisma.gSTTransactionDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GSTTransactionDetailFindFirstArgs>(args?: SelectSubset<T, GSTTransactionDetailFindFirstArgs<ExtArgs>>): Prisma__GSTTransactionDetailClient<$Result.GetResult<Prisma.$GSTTransactionDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GSTTransactionDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GSTTransactionDetailFindFirstOrThrowArgs} args - Arguments to find a GSTTransactionDetail
     * @example
     * // Get one GSTTransactionDetail
     * const gSTTransactionDetail = await prisma.gSTTransactionDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GSTTransactionDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, GSTTransactionDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__GSTTransactionDetailClient<$Result.GetResult<Prisma.$GSTTransactionDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GSTTransactionDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GSTTransactionDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GSTTransactionDetails
     * const gSTTransactionDetails = await prisma.gSTTransactionDetail.findMany()
     * 
     * // Get first 10 GSTTransactionDetails
     * const gSTTransactionDetails = await prisma.gSTTransactionDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gSTTransactionDetailWithIdOnly = await prisma.gSTTransactionDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GSTTransactionDetailFindManyArgs>(args?: SelectSubset<T, GSTTransactionDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GSTTransactionDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GSTTransactionDetail.
     * @param {GSTTransactionDetailCreateArgs} args - Arguments to create a GSTTransactionDetail.
     * @example
     * // Create one GSTTransactionDetail
     * const GSTTransactionDetail = await prisma.gSTTransactionDetail.create({
     *   data: {
     *     // ... data to create a GSTTransactionDetail
     *   }
     * })
     * 
     */
    create<T extends GSTTransactionDetailCreateArgs>(args: SelectSubset<T, GSTTransactionDetailCreateArgs<ExtArgs>>): Prisma__GSTTransactionDetailClient<$Result.GetResult<Prisma.$GSTTransactionDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GSTTransactionDetails.
     * @param {GSTTransactionDetailCreateManyArgs} args - Arguments to create many GSTTransactionDetails.
     * @example
     * // Create many GSTTransactionDetails
     * const gSTTransactionDetail = await prisma.gSTTransactionDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GSTTransactionDetailCreateManyArgs>(args?: SelectSubset<T, GSTTransactionDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GSTTransactionDetails and returns the data saved in the database.
     * @param {GSTTransactionDetailCreateManyAndReturnArgs} args - Arguments to create many GSTTransactionDetails.
     * @example
     * // Create many GSTTransactionDetails
     * const gSTTransactionDetail = await prisma.gSTTransactionDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GSTTransactionDetails and only return the `id`
     * const gSTTransactionDetailWithIdOnly = await prisma.gSTTransactionDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GSTTransactionDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, GSTTransactionDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GSTTransactionDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GSTTransactionDetail.
     * @param {GSTTransactionDetailDeleteArgs} args - Arguments to delete one GSTTransactionDetail.
     * @example
     * // Delete one GSTTransactionDetail
     * const GSTTransactionDetail = await prisma.gSTTransactionDetail.delete({
     *   where: {
     *     // ... filter to delete one GSTTransactionDetail
     *   }
     * })
     * 
     */
    delete<T extends GSTTransactionDetailDeleteArgs>(args: SelectSubset<T, GSTTransactionDetailDeleteArgs<ExtArgs>>): Prisma__GSTTransactionDetailClient<$Result.GetResult<Prisma.$GSTTransactionDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GSTTransactionDetail.
     * @param {GSTTransactionDetailUpdateArgs} args - Arguments to update one GSTTransactionDetail.
     * @example
     * // Update one GSTTransactionDetail
     * const gSTTransactionDetail = await prisma.gSTTransactionDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GSTTransactionDetailUpdateArgs>(args: SelectSubset<T, GSTTransactionDetailUpdateArgs<ExtArgs>>): Prisma__GSTTransactionDetailClient<$Result.GetResult<Prisma.$GSTTransactionDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GSTTransactionDetails.
     * @param {GSTTransactionDetailDeleteManyArgs} args - Arguments to filter GSTTransactionDetails to delete.
     * @example
     * // Delete a few GSTTransactionDetails
     * const { count } = await prisma.gSTTransactionDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GSTTransactionDetailDeleteManyArgs>(args?: SelectSubset<T, GSTTransactionDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GSTTransactionDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GSTTransactionDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GSTTransactionDetails
     * const gSTTransactionDetail = await prisma.gSTTransactionDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GSTTransactionDetailUpdateManyArgs>(args: SelectSubset<T, GSTTransactionDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GSTTransactionDetails and returns the data updated in the database.
     * @param {GSTTransactionDetailUpdateManyAndReturnArgs} args - Arguments to update many GSTTransactionDetails.
     * @example
     * // Update many GSTTransactionDetails
     * const gSTTransactionDetail = await prisma.gSTTransactionDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GSTTransactionDetails and only return the `id`
     * const gSTTransactionDetailWithIdOnly = await prisma.gSTTransactionDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GSTTransactionDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, GSTTransactionDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GSTTransactionDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GSTTransactionDetail.
     * @param {GSTTransactionDetailUpsertArgs} args - Arguments to update or create a GSTTransactionDetail.
     * @example
     * // Update or create a GSTTransactionDetail
     * const gSTTransactionDetail = await prisma.gSTTransactionDetail.upsert({
     *   create: {
     *     // ... data to create a GSTTransactionDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GSTTransactionDetail we want to update
     *   }
     * })
     */
    upsert<T extends GSTTransactionDetailUpsertArgs>(args: SelectSubset<T, GSTTransactionDetailUpsertArgs<ExtArgs>>): Prisma__GSTTransactionDetailClient<$Result.GetResult<Prisma.$GSTTransactionDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GSTTransactionDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GSTTransactionDetailCountArgs} args - Arguments to filter GSTTransactionDetails to count.
     * @example
     * // Count the number of GSTTransactionDetails
     * const count = await prisma.gSTTransactionDetail.count({
     *   where: {
     *     // ... the filter for the GSTTransactionDetails we want to count
     *   }
     * })
    **/
    count<T extends GSTTransactionDetailCountArgs>(
      args?: Subset<T, GSTTransactionDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GSTTransactionDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GSTTransactionDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GSTTransactionDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GSTTransactionDetailAggregateArgs>(args: Subset<T, GSTTransactionDetailAggregateArgs>): Prisma.PrismaPromise<GetGSTTransactionDetailAggregateType<T>>

    /**
     * Group by GSTTransactionDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GSTTransactionDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GSTTransactionDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GSTTransactionDetailGroupByArgs['orderBy'] }
        : { orderBy?: GSTTransactionDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GSTTransactionDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGSTTransactionDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GSTTransactionDetail model
   */
  readonly fields: GSTTransactionDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GSTTransactionDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GSTTransactionDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GSTTransactionDetail model
   */
  interface GSTTransactionDetailFieldRefs {
    readonly id: FieldRef<"GSTTransactionDetail", 'String'>
    readonly transactionId: FieldRef<"GSTTransactionDetail", 'String'>
    readonly invoiceId: FieldRef<"GSTTransactionDetail", 'String'>
    readonly baseAmount: FieldRef<"GSTTransactionDetail", 'Decimal'>
    readonly gstRate: FieldRef<"GSTTransactionDetail", 'Decimal'>
    readonly gstAmount: FieldRef<"GSTTransactionDetail", 'Decimal'>
    readonly totalAmount: FieldRef<"GSTTransactionDetail", 'Decimal'>
    readonly taxCategory: FieldRef<"GSTTransactionDetail", 'String'>
    readonly gstTreatment: FieldRef<"GSTTransactionDetail", 'GSTTreatment'>
    readonly inputTaxCredit: FieldRef<"GSTTransactionDetail", 'Boolean'>
    readonly supplierABN: FieldRef<"GSTTransactionDetail", 'String'>
    readonly supplierName: FieldRef<"GSTTransactionDetail", 'String'>
    readonly isGSTRegistered: FieldRef<"GSTTransactionDetail", 'Boolean'>
    readonly basReportingCode: FieldRef<"GSTTransactionDetail", 'String'>
    readonly taxPeriod: FieldRef<"GSTTransactionDetail", 'String'>
    readonly reportedInBAS: FieldRef<"GSTTransactionDetail", 'Boolean'>
    readonly basReference: FieldRef<"GSTTransactionDetail", 'String'>
    readonly validated: FieldRef<"GSTTransactionDetail", 'Boolean'>
    readonly validationErrors: FieldRef<"GSTTransactionDetail", 'String[]'>
    readonly createdAt: FieldRef<"GSTTransactionDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"GSTTransactionDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GSTTransactionDetail findUnique
   */
  export type GSTTransactionDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GSTTransactionDetail
     */
    select?: GSTTransactionDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GSTTransactionDetail
     */
    omit?: GSTTransactionDetailOmit<ExtArgs> | null
    /**
     * Filter, which GSTTransactionDetail to fetch.
     */
    where: GSTTransactionDetailWhereUniqueInput
  }

  /**
   * GSTTransactionDetail findUniqueOrThrow
   */
  export type GSTTransactionDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GSTTransactionDetail
     */
    select?: GSTTransactionDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GSTTransactionDetail
     */
    omit?: GSTTransactionDetailOmit<ExtArgs> | null
    /**
     * Filter, which GSTTransactionDetail to fetch.
     */
    where: GSTTransactionDetailWhereUniqueInput
  }

  /**
   * GSTTransactionDetail findFirst
   */
  export type GSTTransactionDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GSTTransactionDetail
     */
    select?: GSTTransactionDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GSTTransactionDetail
     */
    omit?: GSTTransactionDetailOmit<ExtArgs> | null
    /**
     * Filter, which GSTTransactionDetail to fetch.
     */
    where?: GSTTransactionDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GSTTransactionDetails to fetch.
     */
    orderBy?: GSTTransactionDetailOrderByWithRelationInput | GSTTransactionDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GSTTransactionDetails.
     */
    cursor?: GSTTransactionDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GSTTransactionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GSTTransactionDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GSTTransactionDetails.
     */
    distinct?: GSTTransactionDetailScalarFieldEnum | GSTTransactionDetailScalarFieldEnum[]
  }

  /**
   * GSTTransactionDetail findFirstOrThrow
   */
  export type GSTTransactionDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GSTTransactionDetail
     */
    select?: GSTTransactionDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GSTTransactionDetail
     */
    omit?: GSTTransactionDetailOmit<ExtArgs> | null
    /**
     * Filter, which GSTTransactionDetail to fetch.
     */
    where?: GSTTransactionDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GSTTransactionDetails to fetch.
     */
    orderBy?: GSTTransactionDetailOrderByWithRelationInput | GSTTransactionDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GSTTransactionDetails.
     */
    cursor?: GSTTransactionDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GSTTransactionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GSTTransactionDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GSTTransactionDetails.
     */
    distinct?: GSTTransactionDetailScalarFieldEnum | GSTTransactionDetailScalarFieldEnum[]
  }

  /**
   * GSTTransactionDetail findMany
   */
  export type GSTTransactionDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GSTTransactionDetail
     */
    select?: GSTTransactionDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GSTTransactionDetail
     */
    omit?: GSTTransactionDetailOmit<ExtArgs> | null
    /**
     * Filter, which GSTTransactionDetails to fetch.
     */
    where?: GSTTransactionDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GSTTransactionDetails to fetch.
     */
    orderBy?: GSTTransactionDetailOrderByWithRelationInput | GSTTransactionDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GSTTransactionDetails.
     */
    cursor?: GSTTransactionDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GSTTransactionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GSTTransactionDetails.
     */
    skip?: number
    distinct?: GSTTransactionDetailScalarFieldEnum | GSTTransactionDetailScalarFieldEnum[]
  }

  /**
   * GSTTransactionDetail create
   */
  export type GSTTransactionDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GSTTransactionDetail
     */
    select?: GSTTransactionDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GSTTransactionDetail
     */
    omit?: GSTTransactionDetailOmit<ExtArgs> | null
    /**
     * The data needed to create a GSTTransactionDetail.
     */
    data: XOR<GSTTransactionDetailCreateInput, GSTTransactionDetailUncheckedCreateInput>
  }

  /**
   * GSTTransactionDetail createMany
   */
  export type GSTTransactionDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GSTTransactionDetails.
     */
    data: GSTTransactionDetailCreateManyInput | GSTTransactionDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GSTTransactionDetail createManyAndReturn
   */
  export type GSTTransactionDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GSTTransactionDetail
     */
    select?: GSTTransactionDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GSTTransactionDetail
     */
    omit?: GSTTransactionDetailOmit<ExtArgs> | null
    /**
     * The data used to create many GSTTransactionDetails.
     */
    data: GSTTransactionDetailCreateManyInput | GSTTransactionDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GSTTransactionDetail update
   */
  export type GSTTransactionDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GSTTransactionDetail
     */
    select?: GSTTransactionDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GSTTransactionDetail
     */
    omit?: GSTTransactionDetailOmit<ExtArgs> | null
    /**
     * The data needed to update a GSTTransactionDetail.
     */
    data: XOR<GSTTransactionDetailUpdateInput, GSTTransactionDetailUncheckedUpdateInput>
    /**
     * Choose, which GSTTransactionDetail to update.
     */
    where: GSTTransactionDetailWhereUniqueInput
  }

  /**
   * GSTTransactionDetail updateMany
   */
  export type GSTTransactionDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GSTTransactionDetails.
     */
    data: XOR<GSTTransactionDetailUpdateManyMutationInput, GSTTransactionDetailUncheckedUpdateManyInput>
    /**
     * Filter which GSTTransactionDetails to update
     */
    where?: GSTTransactionDetailWhereInput
    /**
     * Limit how many GSTTransactionDetails to update.
     */
    limit?: number
  }

  /**
   * GSTTransactionDetail updateManyAndReturn
   */
  export type GSTTransactionDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GSTTransactionDetail
     */
    select?: GSTTransactionDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GSTTransactionDetail
     */
    omit?: GSTTransactionDetailOmit<ExtArgs> | null
    /**
     * The data used to update GSTTransactionDetails.
     */
    data: XOR<GSTTransactionDetailUpdateManyMutationInput, GSTTransactionDetailUncheckedUpdateManyInput>
    /**
     * Filter which GSTTransactionDetails to update
     */
    where?: GSTTransactionDetailWhereInput
    /**
     * Limit how many GSTTransactionDetails to update.
     */
    limit?: number
  }

  /**
   * GSTTransactionDetail upsert
   */
  export type GSTTransactionDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GSTTransactionDetail
     */
    select?: GSTTransactionDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GSTTransactionDetail
     */
    omit?: GSTTransactionDetailOmit<ExtArgs> | null
    /**
     * The filter to search for the GSTTransactionDetail to update in case it exists.
     */
    where: GSTTransactionDetailWhereUniqueInput
    /**
     * In case the GSTTransactionDetail found by the `where` argument doesn't exist, create a new GSTTransactionDetail with this data.
     */
    create: XOR<GSTTransactionDetailCreateInput, GSTTransactionDetailUncheckedCreateInput>
    /**
     * In case the GSTTransactionDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GSTTransactionDetailUpdateInput, GSTTransactionDetailUncheckedUpdateInput>
  }

  /**
   * GSTTransactionDetail delete
   */
  export type GSTTransactionDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GSTTransactionDetail
     */
    select?: GSTTransactionDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GSTTransactionDetail
     */
    omit?: GSTTransactionDetailOmit<ExtArgs> | null
    /**
     * Filter which GSTTransactionDetail to delete.
     */
    where: GSTTransactionDetailWhereUniqueInput
  }

  /**
   * GSTTransactionDetail deleteMany
   */
  export type GSTTransactionDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GSTTransactionDetails to delete
     */
    where?: GSTTransactionDetailWhereInput
    /**
     * Limit how many GSTTransactionDetails to delete.
     */
    limit?: number
  }

  /**
   * GSTTransactionDetail without action
   */
  export type GSTTransactionDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GSTTransactionDetail
     */
    select?: GSTTransactionDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GSTTransactionDetail
     */
    omit?: GSTTransactionDetailOmit<ExtArgs> | null
  }


  /**
   * Model ComplianceConfiguration
   */

  export type AggregateComplianceConfiguration = {
    _count: ComplianceConfigurationCountAggregateOutputType | null
    _avg: ComplianceConfigurationAvgAggregateOutputType | null
    _sum: ComplianceConfigurationSumAggregateOutputType | null
    _min: ComplianceConfigurationMinAggregateOutputType | null
    _max: ComplianceConfigurationMaxAggregateOutputType | null
  }

  export type ComplianceConfigurationAvgAggregateOutputType = {
    dataRetentionDays: number | null
    consentExpireDays: number | null
    incidentReportHours: number | null
    gstRate: Decimal | null
  }

  export type ComplianceConfigurationSumAggregateOutputType = {
    dataRetentionDays: number | null
    consentExpireDays: number | null
    incidentReportHours: number | null
    gstRate: Decimal | null
  }

  export type ComplianceConfigurationMinAggregateOutputType = {
    id: string | null
    configType: string | null
    isActive: boolean | null
    dataRetentionDays: number | null
    consentExpireDays: number | null
    incidentReportHours: number | null
    backupFrequency: string | null
    gstRate: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplianceConfigurationMaxAggregateOutputType = {
    id: string | null
    configType: string | null
    isActive: boolean | null
    dataRetentionDays: number | null
    consentExpireDays: number | null
    incidentReportHours: number | null
    backupFrequency: string | null
    gstRate: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplianceConfigurationCountAggregateOutputType = {
    id: number
    configType: number
    configData: number
    isActive: number
    amlThresholds: number
    dataRetentionDays: number
    consentExpireDays: number
    incidentReportHours: number
    backupFrequency: number
    gstRate: number
    basReportingCodes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComplianceConfigurationAvgAggregateInputType = {
    dataRetentionDays?: true
    consentExpireDays?: true
    incidentReportHours?: true
    gstRate?: true
  }

  export type ComplianceConfigurationSumAggregateInputType = {
    dataRetentionDays?: true
    consentExpireDays?: true
    incidentReportHours?: true
    gstRate?: true
  }

  export type ComplianceConfigurationMinAggregateInputType = {
    id?: true
    configType?: true
    isActive?: true
    dataRetentionDays?: true
    consentExpireDays?: true
    incidentReportHours?: true
    backupFrequency?: true
    gstRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplianceConfigurationMaxAggregateInputType = {
    id?: true
    configType?: true
    isActive?: true
    dataRetentionDays?: true
    consentExpireDays?: true
    incidentReportHours?: true
    backupFrequency?: true
    gstRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplianceConfigurationCountAggregateInputType = {
    id?: true
    configType?: true
    configData?: true
    isActive?: true
    amlThresholds?: true
    dataRetentionDays?: true
    consentExpireDays?: true
    incidentReportHours?: true
    backupFrequency?: true
    gstRate?: true
    basReportingCodes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComplianceConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceConfiguration to aggregate.
     */
    where?: ComplianceConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceConfigurations to fetch.
     */
    orderBy?: ComplianceConfigurationOrderByWithRelationInput | ComplianceConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplianceConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplianceConfigurations
    **/
    _count?: true | ComplianceConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplianceConfigurationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplianceConfigurationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplianceConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplianceConfigurationMaxAggregateInputType
  }

  export type GetComplianceConfigurationAggregateType<T extends ComplianceConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateComplianceConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplianceConfiguration[P]>
      : GetScalarType<T[P], AggregateComplianceConfiguration[P]>
  }




  export type ComplianceConfigurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceConfigurationWhereInput
    orderBy?: ComplianceConfigurationOrderByWithAggregationInput | ComplianceConfigurationOrderByWithAggregationInput[]
    by: ComplianceConfigurationScalarFieldEnum[] | ComplianceConfigurationScalarFieldEnum
    having?: ComplianceConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplianceConfigurationCountAggregateInputType | true
    _avg?: ComplianceConfigurationAvgAggregateInputType
    _sum?: ComplianceConfigurationSumAggregateInputType
    _min?: ComplianceConfigurationMinAggregateInputType
    _max?: ComplianceConfigurationMaxAggregateInputType
  }

  export type ComplianceConfigurationGroupByOutputType = {
    id: string
    configType: string
    configData: JsonValue
    isActive: boolean
    amlThresholds: JsonValue | null
    dataRetentionDays: number | null
    consentExpireDays: number | null
    incidentReportHours: number | null
    backupFrequency: string | null
    gstRate: Decimal | null
    basReportingCodes: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ComplianceConfigurationCountAggregateOutputType | null
    _avg: ComplianceConfigurationAvgAggregateOutputType | null
    _sum: ComplianceConfigurationSumAggregateOutputType | null
    _min: ComplianceConfigurationMinAggregateOutputType | null
    _max: ComplianceConfigurationMaxAggregateOutputType | null
  }

  type GetComplianceConfigurationGroupByPayload<T extends ComplianceConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplianceConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplianceConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplianceConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], ComplianceConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type ComplianceConfigurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    configType?: boolean
    configData?: boolean
    isActive?: boolean
    amlThresholds?: boolean
    dataRetentionDays?: boolean
    consentExpireDays?: boolean
    incidentReportHours?: boolean
    backupFrequency?: boolean
    gstRate?: boolean
    basReportingCodes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["complianceConfiguration"]>

  export type ComplianceConfigurationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    configType?: boolean
    configData?: boolean
    isActive?: boolean
    amlThresholds?: boolean
    dataRetentionDays?: boolean
    consentExpireDays?: boolean
    incidentReportHours?: boolean
    backupFrequency?: boolean
    gstRate?: boolean
    basReportingCodes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["complianceConfiguration"]>

  export type ComplianceConfigurationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    configType?: boolean
    configData?: boolean
    isActive?: boolean
    amlThresholds?: boolean
    dataRetentionDays?: boolean
    consentExpireDays?: boolean
    incidentReportHours?: boolean
    backupFrequency?: boolean
    gstRate?: boolean
    basReportingCodes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["complianceConfiguration"]>

  export type ComplianceConfigurationSelectScalar = {
    id?: boolean
    configType?: boolean
    configData?: boolean
    isActive?: boolean
    amlThresholds?: boolean
    dataRetentionDays?: boolean
    consentExpireDays?: boolean
    incidentReportHours?: boolean
    backupFrequency?: boolean
    gstRate?: boolean
    basReportingCodes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComplianceConfigurationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "configType" | "configData" | "isActive" | "amlThresholds" | "dataRetentionDays" | "consentExpireDays" | "incidentReportHours" | "backupFrequency" | "gstRate" | "basReportingCodes" | "createdAt" | "updatedAt", ExtArgs["result"]["complianceConfiguration"]>

  export type $ComplianceConfigurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplianceConfiguration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      configType: string
      configData: Prisma.JsonValue
      isActive: boolean
      amlThresholds: Prisma.JsonValue | null
      dataRetentionDays: number | null
      consentExpireDays: number | null
      incidentReportHours: number | null
      backupFrequency: string | null
      gstRate: Prisma.Decimal | null
      basReportingCodes: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["complianceConfiguration"]>
    composites: {}
  }

  type ComplianceConfigurationGetPayload<S extends boolean | null | undefined | ComplianceConfigurationDefaultArgs> = $Result.GetResult<Prisma.$ComplianceConfigurationPayload, S>

  type ComplianceConfigurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplianceConfigurationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplianceConfigurationCountAggregateInputType | true
    }

  export interface ComplianceConfigurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplianceConfiguration'], meta: { name: 'ComplianceConfiguration' } }
    /**
     * Find zero or one ComplianceConfiguration that matches the filter.
     * @param {ComplianceConfigurationFindUniqueArgs} args - Arguments to find a ComplianceConfiguration
     * @example
     * // Get one ComplianceConfiguration
     * const complianceConfiguration = await prisma.complianceConfiguration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplianceConfigurationFindUniqueArgs>(args: SelectSubset<T, ComplianceConfigurationFindUniqueArgs<ExtArgs>>): Prisma__ComplianceConfigurationClient<$Result.GetResult<Prisma.$ComplianceConfigurationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComplianceConfiguration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplianceConfigurationFindUniqueOrThrowArgs} args - Arguments to find a ComplianceConfiguration
     * @example
     * // Get one ComplianceConfiguration
     * const complianceConfiguration = await prisma.complianceConfiguration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplianceConfigurationFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplianceConfigurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplianceConfigurationClient<$Result.GetResult<Prisma.$ComplianceConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplianceConfiguration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceConfigurationFindFirstArgs} args - Arguments to find a ComplianceConfiguration
     * @example
     * // Get one ComplianceConfiguration
     * const complianceConfiguration = await prisma.complianceConfiguration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplianceConfigurationFindFirstArgs>(args?: SelectSubset<T, ComplianceConfigurationFindFirstArgs<ExtArgs>>): Prisma__ComplianceConfigurationClient<$Result.GetResult<Prisma.$ComplianceConfigurationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplianceConfiguration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceConfigurationFindFirstOrThrowArgs} args - Arguments to find a ComplianceConfiguration
     * @example
     * // Get one ComplianceConfiguration
     * const complianceConfiguration = await prisma.complianceConfiguration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplianceConfigurationFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplianceConfigurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplianceConfigurationClient<$Result.GetResult<Prisma.$ComplianceConfigurationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComplianceConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceConfigurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplianceConfigurations
     * const complianceConfigurations = await prisma.complianceConfiguration.findMany()
     * 
     * // Get first 10 ComplianceConfigurations
     * const complianceConfigurations = await prisma.complianceConfiguration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complianceConfigurationWithIdOnly = await prisma.complianceConfiguration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplianceConfigurationFindManyArgs>(args?: SelectSubset<T, ComplianceConfigurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceConfigurationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComplianceConfiguration.
     * @param {ComplianceConfigurationCreateArgs} args - Arguments to create a ComplianceConfiguration.
     * @example
     * // Create one ComplianceConfiguration
     * const ComplianceConfiguration = await prisma.complianceConfiguration.create({
     *   data: {
     *     // ... data to create a ComplianceConfiguration
     *   }
     * })
     * 
     */
    create<T extends ComplianceConfigurationCreateArgs>(args: SelectSubset<T, ComplianceConfigurationCreateArgs<ExtArgs>>): Prisma__ComplianceConfigurationClient<$Result.GetResult<Prisma.$ComplianceConfigurationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComplianceConfigurations.
     * @param {ComplianceConfigurationCreateManyArgs} args - Arguments to create many ComplianceConfigurations.
     * @example
     * // Create many ComplianceConfigurations
     * const complianceConfiguration = await prisma.complianceConfiguration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplianceConfigurationCreateManyArgs>(args?: SelectSubset<T, ComplianceConfigurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComplianceConfigurations and returns the data saved in the database.
     * @param {ComplianceConfigurationCreateManyAndReturnArgs} args - Arguments to create many ComplianceConfigurations.
     * @example
     * // Create many ComplianceConfigurations
     * const complianceConfiguration = await prisma.complianceConfiguration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComplianceConfigurations and only return the `id`
     * const complianceConfigurationWithIdOnly = await prisma.complianceConfiguration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplianceConfigurationCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplianceConfigurationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceConfigurationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ComplianceConfiguration.
     * @param {ComplianceConfigurationDeleteArgs} args - Arguments to delete one ComplianceConfiguration.
     * @example
     * // Delete one ComplianceConfiguration
     * const ComplianceConfiguration = await prisma.complianceConfiguration.delete({
     *   where: {
     *     // ... filter to delete one ComplianceConfiguration
     *   }
     * })
     * 
     */
    delete<T extends ComplianceConfigurationDeleteArgs>(args: SelectSubset<T, ComplianceConfigurationDeleteArgs<ExtArgs>>): Prisma__ComplianceConfigurationClient<$Result.GetResult<Prisma.$ComplianceConfigurationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComplianceConfiguration.
     * @param {ComplianceConfigurationUpdateArgs} args - Arguments to update one ComplianceConfiguration.
     * @example
     * // Update one ComplianceConfiguration
     * const complianceConfiguration = await prisma.complianceConfiguration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplianceConfigurationUpdateArgs>(args: SelectSubset<T, ComplianceConfigurationUpdateArgs<ExtArgs>>): Prisma__ComplianceConfigurationClient<$Result.GetResult<Prisma.$ComplianceConfigurationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComplianceConfigurations.
     * @param {ComplianceConfigurationDeleteManyArgs} args - Arguments to filter ComplianceConfigurations to delete.
     * @example
     * // Delete a few ComplianceConfigurations
     * const { count } = await prisma.complianceConfiguration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplianceConfigurationDeleteManyArgs>(args?: SelectSubset<T, ComplianceConfigurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplianceConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplianceConfigurations
     * const complianceConfiguration = await prisma.complianceConfiguration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplianceConfigurationUpdateManyArgs>(args: SelectSubset<T, ComplianceConfigurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplianceConfigurations and returns the data updated in the database.
     * @param {ComplianceConfigurationUpdateManyAndReturnArgs} args - Arguments to update many ComplianceConfigurations.
     * @example
     * // Update many ComplianceConfigurations
     * const complianceConfiguration = await prisma.complianceConfiguration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ComplianceConfigurations and only return the `id`
     * const complianceConfigurationWithIdOnly = await prisma.complianceConfiguration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComplianceConfigurationUpdateManyAndReturnArgs>(args: SelectSubset<T, ComplianceConfigurationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceConfigurationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ComplianceConfiguration.
     * @param {ComplianceConfigurationUpsertArgs} args - Arguments to update or create a ComplianceConfiguration.
     * @example
     * // Update or create a ComplianceConfiguration
     * const complianceConfiguration = await prisma.complianceConfiguration.upsert({
     *   create: {
     *     // ... data to create a ComplianceConfiguration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplianceConfiguration we want to update
     *   }
     * })
     */
    upsert<T extends ComplianceConfigurationUpsertArgs>(args: SelectSubset<T, ComplianceConfigurationUpsertArgs<ExtArgs>>): Prisma__ComplianceConfigurationClient<$Result.GetResult<Prisma.$ComplianceConfigurationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComplianceConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceConfigurationCountArgs} args - Arguments to filter ComplianceConfigurations to count.
     * @example
     * // Count the number of ComplianceConfigurations
     * const count = await prisma.complianceConfiguration.count({
     *   where: {
     *     // ... the filter for the ComplianceConfigurations we want to count
     *   }
     * })
    **/
    count<T extends ComplianceConfigurationCountArgs>(
      args?: Subset<T, ComplianceConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplianceConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplianceConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplianceConfigurationAggregateArgs>(args: Subset<T, ComplianceConfigurationAggregateArgs>): Prisma.PrismaPromise<GetComplianceConfigurationAggregateType<T>>

    /**
     * Group by ComplianceConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplianceConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplianceConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: ComplianceConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplianceConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplianceConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplianceConfiguration model
   */
  readonly fields: ComplianceConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplianceConfiguration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplianceConfigurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplianceConfiguration model
   */
  interface ComplianceConfigurationFieldRefs {
    readonly id: FieldRef<"ComplianceConfiguration", 'String'>
    readonly configType: FieldRef<"ComplianceConfiguration", 'String'>
    readonly configData: FieldRef<"ComplianceConfiguration", 'Json'>
    readonly isActive: FieldRef<"ComplianceConfiguration", 'Boolean'>
    readonly amlThresholds: FieldRef<"ComplianceConfiguration", 'Json'>
    readonly dataRetentionDays: FieldRef<"ComplianceConfiguration", 'Int'>
    readonly consentExpireDays: FieldRef<"ComplianceConfiguration", 'Int'>
    readonly incidentReportHours: FieldRef<"ComplianceConfiguration", 'Int'>
    readonly backupFrequency: FieldRef<"ComplianceConfiguration", 'String'>
    readonly gstRate: FieldRef<"ComplianceConfiguration", 'Decimal'>
    readonly basReportingCodes: FieldRef<"ComplianceConfiguration", 'Json'>
    readonly createdAt: FieldRef<"ComplianceConfiguration", 'DateTime'>
    readonly updatedAt: FieldRef<"ComplianceConfiguration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComplianceConfiguration findUnique
   */
  export type ComplianceConfigurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceConfiguration
     */
    select?: ComplianceConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceConfiguration
     */
    omit?: ComplianceConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which ComplianceConfiguration to fetch.
     */
    where: ComplianceConfigurationWhereUniqueInput
  }

  /**
   * ComplianceConfiguration findUniqueOrThrow
   */
  export type ComplianceConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceConfiguration
     */
    select?: ComplianceConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceConfiguration
     */
    omit?: ComplianceConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which ComplianceConfiguration to fetch.
     */
    where: ComplianceConfigurationWhereUniqueInput
  }

  /**
   * ComplianceConfiguration findFirst
   */
  export type ComplianceConfigurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceConfiguration
     */
    select?: ComplianceConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceConfiguration
     */
    omit?: ComplianceConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which ComplianceConfiguration to fetch.
     */
    where?: ComplianceConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceConfigurations to fetch.
     */
    orderBy?: ComplianceConfigurationOrderByWithRelationInput | ComplianceConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceConfigurations.
     */
    cursor?: ComplianceConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceConfigurations.
     */
    distinct?: ComplianceConfigurationScalarFieldEnum | ComplianceConfigurationScalarFieldEnum[]
  }

  /**
   * ComplianceConfiguration findFirstOrThrow
   */
  export type ComplianceConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceConfiguration
     */
    select?: ComplianceConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceConfiguration
     */
    omit?: ComplianceConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which ComplianceConfiguration to fetch.
     */
    where?: ComplianceConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceConfigurations to fetch.
     */
    orderBy?: ComplianceConfigurationOrderByWithRelationInput | ComplianceConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceConfigurations.
     */
    cursor?: ComplianceConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceConfigurations.
     */
    distinct?: ComplianceConfigurationScalarFieldEnum | ComplianceConfigurationScalarFieldEnum[]
  }

  /**
   * ComplianceConfiguration findMany
   */
  export type ComplianceConfigurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceConfiguration
     */
    select?: ComplianceConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceConfiguration
     */
    omit?: ComplianceConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which ComplianceConfigurations to fetch.
     */
    where?: ComplianceConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceConfigurations to fetch.
     */
    orderBy?: ComplianceConfigurationOrderByWithRelationInput | ComplianceConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplianceConfigurations.
     */
    cursor?: ComplianceConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceConfigurations.
     */
    skip?: number
    distinct?: ComplianceConfigurationScalarFieldEnum | ComplianceConfigurationScalarFieldEnum[]
  }

  /**
   * ComplianceConfiguration create
   */
  export type ComplianceConfigurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceConfiguration
     */
    select?: ComplianceConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceConfiguration
     */
    omit?: ComplianceConfigurationOmit<ExtArgs> | null
    /**
     * The data needed to create a ComplianceConfiguration.
     */
    data: XOR<ComplianceConfigurationCreateInput, ComplianceConfigurationUncheckedCreateInput>
  }

  /**
   * ComplianceConfiguration createMany
   */
  export type ComplianceConfigurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplianceConfigurations.
     */
    data: ComplianceConfigurationCreateManyInput | ComplianceConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplianceConfiguration createManyAndReturn
   */
  export type ComplianceConfigurationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceConfiguration
     */
    select?: ComplianceConfigurationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceConfiguration
     */
    omit?: ComplianceConfigurationOmit<ExtArgs> | null
    /**
     * The data used to create many ComplianceConfigurations.
     */
    data: ComplianceConfigurationCreateManyInput | ComplianceConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplianceConfiguration update
   */
  export type ComplianceConfigurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceConfiguration
     */
    select?: ComplianceConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceConfiguration
     */
    omit?: ComplianceConfigurationOmit<ExtArgs> | null
    /**
     * The data needed to update a ComplianceConfiguration.
     */
    data: XOR<ComplianceConfigurationUpdateInput, ComplianceConfigurationUncheckedUpdateInput>
    /**
     * Choose, which ComplianceConfiguration to update.
     */
    where: ComplianceConfigurationWhereUniqueInput
  }

  /**
   * ComplianceConfiguration updateMany
   */
  export type ComplianceConfigurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplianceConfigurations.
     */
    data: XOR<ComplianceConfigurationUpdateManyMutationInput, ComplianceConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which ComplianceConfigurations to update
     */
    where?: ComplianceConfigurationWhereInput
    /**
     * Limit how many ComplianceConfigurations to update.
     */
    limit?: number
  }

  /**
   * ComplianceConfiguration updateManyAndReturn
   */
  export type ComplianceConfigurationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceConfiguration
     */
    select?: ComplianceConfigurationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceConfiguration
     */
    omit?: ComplianceConfigurationOmit<ExtArgs> | null
    /**
     * The data used to update ComplianceConfigurations.
     */
    data: XOR<ComplianceConfigurationUpdateManyMutationInput, ComplianceConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which ComplianceConfigurations to update
     */
    where?: ComplianceConfigurationWhereInput
    /**
     * Limit how many ComplianceConfigurations to update.
     */
    limit?: number
  }

  /**
   * ComplianceConfiguration upsert
   */
  export type ComplianceConfigurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceConfiguration
     */
    select?: ComplianceConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceConfiguration
     */
    omit?: ComplianceConfigurationOmit<ExtArgs> | null
    /**
     * The filter to search for the ComplianceConfiguration to update in case it exists.
     */
    where: ComplianceConfigurationWhereUniqueInput
    /**
     * In case the ComplianceConfiguration found by the `where` argument doesn't exist, create a new ComplianceConfiguration with this data.
     */
    create: XOR<ComplianceConfigurationCreateInput, ComplianceConfigurationUncheckedCreateInput>
    /**
     * In case the ComplianceConfiguration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplianceConfigurationUpdateInput, ComplianceConfigurationUncheckedUpdateInput>
  }

  /**
   * ComplianceConfiguration delete
   */
  export type ComplianceConfigurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceConfiguration
     */
    select?: ComplianceConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceConfiguration
     */
    omit?: ComplianceConfigurationOmit<ExtArgs> | null
    /**
     * Filter which ComplianceConfiguration to delete.
     */
    where: ComplianceConfigurationWhereUniqueInput
  }

  /**
   * ComplianceConfiguration deleteMany
   */
  export type ComplianceConfigurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceConfigurations to delete
     */
    where?: ComplianceConfigurationWhereInput
    /**
     * Limit how many ComplianceConfigurations to delete.
     */
    limit?: number
  }

  /**
   * ComplianceConfiguration without action
   */
  export type ComplianceConfigurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceConfiguration
     */
    select?: ComplianceConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceConfiguration
     */
    omit?: ComplianceConfigurationOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    emailVerified: 'emailVerified',
    name: 'name',
    phone: 'phone',
    password: 'password',
    image: 'image',
    role: 'role',
    abn: 'abn',
    tfn: 'tfn',
    taxResidency: 'taxResidency',
    failedLoginAttempts: 'failedLoginAttempts',
    lockedUntil: 'lockedUntil',
    lastLoginAt: 'lastLoginAt',
    lastLoginIp: 'lastLoginIp',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorSecret: 'twoFactorSecret',
    emailVerificationToken: 'emailVerificationToken',
    emailVerificationExpires: 'emailVerificationExpires',
    passwordResetToken: 'passwordResetToken',
    passwordResetExpires: 'passwordResetExpires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    event: 'event',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    metadata: 'metadata',
    success: 'success',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const FinancialAuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sessionId: 'sessionId',
    operationType: 'operationType',
    resourceType: 'resourceType',
    resourceId: 'resourceId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    httpMethod: 'httpMethod',
    endpoint: 'endpoint',
    previousData: 'previousData',
    currentData: 'currentData',
    changedFields: 'changedFields',
    amount: 'amount',
    gstAmount: 'gstAmount',
    currency: 'currency',
    taxYear: 'taxYear',
    success: 'success',
    errorMessage: 'errorMessage',
    hashChain: 'hashChain',
    previousHash: 'previousHash',
    createdAt: 'createdAt',
    timezone: 'timezone'
  };

  export type FinancialAuditLogScalarFieldEnum = (typeof FinancialAuditLogScalarFieldEnum)[keyof typeof FinancialAuditLogScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    stripePriceId: 'stripePriceId',
    status: 'status',
    plan: 'plan',
    interval: 'interval',
    amount: 'amount',
    currency: 'currency',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    cancelledAt: 'cancelledAt',
    trialEnd: 'trialEnd',
    defaultPaymentMethodId: 'defaultPaymentMethodId',
    lastPaymentAttempt: 'lastPaymentAttempt',
    failedPaymentCount: 'failedPaymentCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const TaxReturnScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    year: 'year',
    data: 'data',
    status: 'status',
    submittedAt: 'submittedAt',
    processedAt: 'processedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaxReturnScalarFieldEnum = (typeof TaxReturnScalarFieldEnum)[keyof typeof TaxReturnScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    stripePaymentIntentId: 'stripePaymentIntentId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    description: 'description',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    stripeInvoiceId: 'stripeInvoiceId',
    customerName: 'customerName',
    customerEmail: 'customerEmail',
    customerABN: 'customerABN',
    subtotal: 'subtotal',
    gstAmount: 'gstAmount',
    total: 'total',
    status: 'status',
    invoiceDate: 'invoiceDate',
    paidAt: 'paidAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceLineItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    description: 'description',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceLineItemScalarFieldEnum = (typeof InvoiceLineItemScalarFieldEnum)[keyof typeof InvoiceLineItemScalarFieldEnum]


  export const AIConversationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sessionId: 'sessionId',
    provider: 'provider',
    model: 'model',
    messages: 'messages',
    context: 'context',
    tokensUsed: 'tokensUsed',
    costUsd: 'costUsd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIConversationScalarFieldEnum = (typeof AIConversationScalarFieldEnum)[keyof typeof AIConversationScalarFieldEnum]


  export const AIInsightScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    insightType: 'insightType',
    category: 'category',
    content: 'content',
    confidenceScore: 'confidenceScore',
    sourceDataIds: 'sourceDataIds',
    provider: 'provider',
    model: 'model',
    isActive: 'isActive',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type AIInsightScalarFieldEnum = (typeof AIInsightScalarFieldEnum)[keyof typeof AIInsightScalarFieldEnum]


  export const AIUsageTrackingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    model: 'model',
    operationType: 'operationType',
    tokensInput: 'tokensInput',
    tokensOutput: 'tokensOutput',
    costUsd: 'costUsd',
    responseTimeMs: 'responseTimeMs',
    success: 'success',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt'
  };

  export type AIUsageTrackingScalarFieldEnum = (typeof AIUsageTrackingScalarFieldEnum)[keyof typeof AIUsageTrackingScalarFieldEnum]


  export const AICacheScalarFieldEnum: {
    id: 'id',
    cacheKey: 'cacheKey',
    operationType: 'operationType',
    inputHash: 'inputHash',
    response: 'response',
    provider: 'provider',
    model: 'model',
    hitCount: 'hitCount',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type AICacheScalarFieldEnum = (typeof AICacheScalarFieldEnum)[keyof typeof AICacheScalarFieldEnum]


  export const AIProviderHealthScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    status: 'status',
    consecutiveFailures: 'consecutiveFailures',
    lastFailureAt: 'lastFailureAt',
    lastSuccessAt: 'lastSuccessAt',
    circuitOpenUntil: 'circuitOpenUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIProviderHealthScalarFieldEnum = (typeof AIProviderHealthScalarFieldEnum)[keyof typeof AIProviderHealthScalarFieldEnum]


  export const Basiq_usersScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    basiq_user_id: 'basiq_user_id',
    email: 'email',
    mobile: 'mobile',
    connection_status: 'connection_status',
    consent_id: 'consent_id',
    consent_status: 'consent_status',
    consent_expires_at: 'consent_expires_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Basiq_usersScalarFieldEnum = (typeof Basiq_usersScalarFieldEnum)[keyof typeof Basiq_usersScalarFieldEnum]


  export const Bank_connectionsScalarFieldEnum: {
    id: 'id',
    basiq_user_id: 'basiq_user_id',
    connection_id: 'connection_id',
    institution_id: 'institution_id',
    institution_name: 'institution_name',
    institution_short_name: 'institution_short_name',
    institution_logo_url: 'institution_logo_url',
    status: 'status',
    last_synced: 'last_synced',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Bank_connectionsScalarFieldEnum = (typeof Bank_connectionsScalarFieldEnum)[keyof typeof Bank_connectionsScalarFieldEnum]


  export const Bank_accountsScalarFieldEnum: {
    id: 'id',
    basiq_user_id: 'basiq_user_id',
    connection_id: 'connection_id',
    basiq_account_id: 'basiq_account_id',
    account_holder: 'account_holder',
    account_number: 'account_number',
    bsb: 'bsb',
    institution_name: 'institution_name',
    account_type: 'account_type',
    account_name: 'account_name',
    balance_available: 'balance_available',
    balance_current: 'balance_current',
    currency: 'currency',
    status: 'status',
    is_business_account: 'is_business_account',
    last_synced: 'last_synced',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Bank_accountsScalarFieldEnum = (typeof Bank_accountsScalarFieldEnum)[keyof typeof Bank_accountsScalarFieldEnum]


  export const Bank_transactionsScalarFieldEnum: {
    id: 'id',
    bank_account_id: 'bank_account_id',
    basiq_transaction_id: 'basiq_transaction_id',
    description: 'description',
    amount: 'amount',
    transaction_date: 'transaction_date',
    post_date: 'post_date',
    balance: 'balance',
    transaction_type: 'transaction_type',
    direction: 'direction',
    category: 'category',
    subcategory: 'subcategory',
    merchant_name: 'merchant_name',
    status: 'status',
    is_business_expense: 'is_business_expense',
    tax_category: 'tax_category',
    gst_amount: 'gst_amount',
    receipt_id: 'receipt_id',
    notes: 'notes',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Bank_transactionsScalarFieldEnum = (typeof Bank_transactionsScalarFieldEnum)[keyof typeof Bank_transactionsScalarFieldEnum]


  export const Basiq_webhooksScalarFieldEnum: {
    id: 'id',
    webhook_id: 'webhook_id',
    event_type: 'event_type',
    resource_type: 'resource_type',
    resource_id: 'resource_id',
    payload: 'payload',
    status: 'status',
    processed_at: 'processed_at',
    error_message: 'error_message',
    retry_count: 'retry_count',
    created_at: 'created_at'
  };

  export type Basiq_webhooksScalarFieldEnum = (typeof Basiq_webhooksScalarFieldEnum)[keyof typeof Basiq_webhooksScalarFieldEnum]


  export const Basiq_api_logsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    endpoint: 'endpoint',
    method: 'method',
    request_body: 'request_body',
    response_status: 'response_status',
    response_body: 'response_body',
    error_message: 'error_message',
    duration_ms: 'duration_ms',
    created_at: 'created_at'
  };

  export type Basiq_api_logsScalarFieldEnum = (typeof Basiq_api_logsScalarFieldEnum)[keyof typeof Basiq_api_logsScalarFieldEnum]


  export const ReceiptScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    merchant: 'merchant',
    totalAmount: 'totalAmount',
    gstAmount: 'gstAmount',
    date: 'date',
    items: 'items',
    imageUrl: 'imageUrl',
    aiProcessed: 'aiProcessed',
    aiConfidence: 'aiConfidence',
    aiProvider: 'aiProvider',
    aiModel: 'aiModel',
    processingStatus: 'processingStatus',
    abn: 'abn',
    taxInvoiceNumber: 'taxInvoiceNumber',
    taxCategory: 'taxCategory',
    isGstRegistered: 'isGstRegistered',
    matchedTransactionId: 'matchedTransactionId',
    matchConfidence: 'matchConfidence',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReceiptScalarFieldEnum = (typeof ReceiptScalarFieldEnum)[keyof typeof ReceiptScalarFieldEnum]


  export const BudgetScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    monthlyBudget: 'monthlyBudget',
    targetSavings: 'targetSavings',
    monthlyIncome: 'monthlyIncome',
    predictions: 'predictions',
    categoryLimits: 'categoryLimits',
    confidenceScore: 'confidenceScore',
    aiProvider: 'aiProvider',
    aiModel: 'aiModel',
    analysisPeriod: 'analysisPeriod',
    predictionPeriod: 'predictionPeriod',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BudgetScalarFieldEnum = (typeof BudgetScalarFieldEnum)[keyof typeof BudgetScalarFieldEnum]


  export const BudgetTrackingScalarFieldEnum: {
    id: 'id',
    budgetId: 'budgetId',
    userId: 'userId',
    month: 'month',
    year: 'year',
    predictedAmount: 'predictedAmount',
    actualAmount: 'actualAmount',
    variance: 'variance',
    category: 'category',
    createdAt: 'createdAt'
  };

  export type BudgetTrackingScalarFieldEnum = (typeof BudgetTrackingScalarFieldEnum)[keyof typeof BudgetTrackingScalarFieldEnum]


  export const FinancialInsightScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    insightType: 'insightType',
    category: 'category',
    content: 'content',
    confidenceScore: 'confidenceScore',
    sourceDataIds: 'sourceDataIds',
    provider: 'provider',
    model: 'model',
    title: 'title',
    description: 'description',
    recommendations: 'recommendations',
    priority: 'priority',
    isActive: 'isActive',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type FinancialInsightScalarFieldEnum = (typeof FinancialInsightScalarFieldEnum)[keyof typeof FinancialInsightScalarFieldEnum]


  export const GoalScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    targetAmount: 'targetAmount',
    currentAmount: 'currentAmount',
    targetDate: 'targetDate',
    category: 'category',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GoalScalarFieldEnum = (typeof GoalScalarFieldEnum)[keyof typeof GoalScalarFieldEnum]


  export const AMLTransactionMonitoringScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    transactionId: 'transactionId',
    monitoringType: 'monitoringType',
    riskScore: 'riskScore',
    riskFactors: 'riskFactors',
    amount: 'amount',
    currency: 'currency',
    patternType: 'patternType',
    patternDetails: 'patternDetails',
    velocityScore: 'velocityScore',
    requiresReview: 'requiresReview',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    reportedToAUSTRAC: 'reportedToAUSTRAC',
    reportReference: 'reportReference',
    reportedAt: 'reportedAt',
    falsePositive: 'falsePositive',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AMLTransactionMonitoringScalarFieldEnum = (typeof AMLTransactionMonitoringScalarFieldEnum)[keyof typeof AMLTransactionMonitoringScalarFieldEnum]


  export const PrivacyConsentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    consentType: 'consentType',
    consentVersion: 'consentVersion',
    consentStatus: 'consentStatus',
    consentDate: 'consentDate',
    expiryDate: 'expiryDate',
    purposes: 'purposes',
    dataCategories: 'dataCategories',
    thirdParties: 'thirdParties',
    withdrawnAt: 'withdrawnAt',
    withdrawalReason: 'withdrawalReason',
    legalBasis: 'legalBasis',
    jurisdiction: 'jurisdiction',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PrivacyConsentScalarFieldEnum = (typeof PrivacyConsentScalarFieldEnum)[keyof typeof PrivacyConsentScalarFieldEnum]


  export const DataAccessRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    requestType: 'requestType',
    requestStatus: 'requestStatus',
    requestDate: 'requestDate',
    requestDetails: 'requestDetails',
    verificationMethod: 'verificationMethod',
    verifiedAt: 'verifiedAt',
    processedBy: 'processedBy',
    processedAt: 'processedAt',
    completedAt: 'completedAt',
    responseMethod: 'responseMethod',
    responseUrl: 'responseUrl',
    responseExpiryDate: 'responseExpiryDate',
    dueDate: 'dueDate',
    extensionReason: 'extensionReason',
    extendedDueDate: 'extendedDueDate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DataAccessRequestScalarFieldEnum = (typeof DataAccessRequestScalarFieldEnum)[keyof typeof DataAccessRequestScalarFieldEnum]


  export const APRAIncidentReportScalarFieldEnum: {
    id: 'id',
    incidentType: 'incidentType',
    severity: 'severity',
    status: 'status',
    title: 'title',
    description: 'description',
    detectedAt: 'detectedAt',
    reportedAt: 'reportedAt',
    resolvedAt: 'resolvedAt',
    affectedUsers: 'affectedUsers',
    affectedSystems: 'affectedSystems',
    dataCompromised: 'dataCompromised',
    financialImpact: 'financialImpact',
    immediateActions: 'immediateActions',
    rootCause: 'rootCause',
    remediation: 'remediation',
    preventiveMeasures: 'preventiveMeasures',
    reportedToAPRA: 'reportedToAPRA',
    apraReference: 'apraReference',
    reportedToOAIC: 'reportedToOAIC',
    oaicReference: 'oaicReference',
    bcpActivated: 'bcpActivated',
    serviceDowntime: 'serviceDowntime',
    dataRecoveryTime: 'dataRecoveryTime',
    reportedBy: 'reportedBy',
    responsibleTeam: 'responsibleTeam',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type APRAIncidentReportScalarFieldEnum = (typeof APRAIncidentReportScalarFieldEnum)[keyof typeof APRAIncidentReportScalarFieldEnum]


  export const GSTTransactionDetailScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    invoiceId: 'invoiceId',
    baseAmount: 'baseAmount',
    gstRate: 'gstRate',
    gstAmount: 'gstAmount',
    totalAmount: 'totalAmount',
    taxCategory: 'taxCategory',
    gstTreatment: 'gstTreatment',
    inputTaxCredit: 'inputTaxCredit',
    supplierABN: 'supplierABN',
    supplierName: 'supplierName',
    isGSTRegistered: 'isGSTRegistered',
    basReportingCode: 'basReportingCode',
    taxPeriod: 'taxPeriod',
    reportedInBAS: 'reportedInBAS',
    basReference: 'basReference',
    validated: 'validated',
    validationErrors: 'validationErrors',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GSTTransactionDetailScalarFieldEnum = (typeof GSTTransactionDetailScalarFieldEnum)[keyof typeof GSTTransactionDetailScalarFieldEnum]


  export const ComplianceConfigurationScalarFieldEnum: {
    id: 'id',
    configType: 'configType',
    configData: 'configData',
    isActive: 'isActive',
    amlThresholds: 'amlThresholds',
    dataRetentionDays: 'dataRetentionDays',
    consentExpireDays: 'consentExpireDays',
    incidentReportHours: 'incidentReportHours',
    backupFrequency: 'backupFrequency',
    gstRate: 'gstRate',
    basReportingCodes: 'basReportingCodes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComplianceConfigurationScalarFieldEnum = (typeof ComplianceConfigurationScalarFieldEnum)[keyof typeof ComplianceConfigurationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'TaxResidency'
   */
  export type EnumTaxResidencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaxResidency'>
    


  /**
   * Reference to a field of type 'TaxResidency[]'
   */
  export type ListEnumTaxResidencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaxResidency[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AuthEvent'
   */
  export type EnumAuthEventFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthEvent'>
    


  /**
   * Reference to a field of type 'AuthEvent[]'
   */
  export type ListEnumAuthEventFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthEvent[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'FinancialOperation'
   */
  export type EnumFinancialOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinancialOperation'>
    


  /**
   * Reference to a field of type 'FinancialOperation[]'
   */
  export type ListEnumFinancialOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinancialOperation[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Plan'
   */
  export type EnumPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Plan'>
    


  /**
   * Reference to a field of type 'Plan[]'
   */
  export type ListEnumPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Plan[]'>
    


  /**
   * Reference to a field of type 'TaxReturnStatus'
   */
  export type EnumTaxReturnStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaxReturnStatus'>
    


  /**
   * Reference to a field of type 'TaxReturnStatus[]'
   */
  export type ListEnumTaxReturnStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaxReturnStatus[]'>
    


  /**
   * Reference to a field of type 'ReceiptStatus'
   */
  export type EnumReceiptStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReceiptStatus'>
    


  /**
   * Reference to a field of type 'ReceiptStatus[]'
   */
  export type ListEnumReceiptStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReceiptStatus[]'>
    


  /**
   * Reference to a field of type 'BudgetStatus'
   */
  export type EnumBudgetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetStatus'>
    


  /**
   * Reference to a field of type 'BudgetStatus[]'
   */
  export type ListEnumBudgetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetStatus[]'>
    


  /**
   * Reference to a field of type 'InsightPriority'
   */
  export type EnumInsightPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightPriority'>
    


  /**
   * Reference to a field of type 'InsightPriority[]'
   */
  export type ListEnumInsightPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightPriority[]'>
    


  /**
   * Reference to a field of type 'GoalStatus'
   */
  export type EnumGoalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalStatus'>
    


  /**
   * Reference to a field of type 'GoalStatus[]'
   */
  export type ListEnumGoalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalStatus[]'>
    


  /**
   * Reference to a field of type 'AMLMonitoringType'
   */
  export type EnumAMLMonitoringTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AMLMonitoringType'>
    


  /**
   * Reference to a field of type 'AMLMonitoringType[]'
   */
  export type ListEnumAMLMonitoringTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AMLMonitoringType[]'>
    


  /**
   * Reference to a field of type 'ConsentType'
   */
  export type EnumConsentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentType'>
    


  /**
   * Reference to a field of type 'ConsentType[]'
   */
  export type ListEnumConsentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentType[]'>
    


  /**
   * Reference to a field of type 'ConsentStatus'
   */
  export type EnumConsentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentStatus'>
    


  /**
   * Reference to a field of type 'ConsentStatus[]'
   */
  export type ListEnumConsentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentStatus[]'>
    


  /**
   * Reference to a field of type 'DataRequestType'
   */
  export type EnumDataRequestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataRequestType'>
    


  /**
   * Reference to a field of type 'DataRequestType[]'
   */
  export type ListEnumDataRequestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataRequestType[]'>
    


  /**
   * Reference to a field of type 'DataRequestStatus'
   */
  export type EnumDataRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataRequestStatus'>
    


  /**
   * Reference to a field of type 'DataRequestStatus[]'
   */
  export type ListEnumDataRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataRequestStatus[]'>
    


  /**
   * Reference to a field of type 'IncidentType'
   */
  export type EnumIncidentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentType'>
    


  /**
   * Reference to a field of type 'IncidentType[]'
   */
  export type ListEnumIncidentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentType[]'>
    


  /**
   * Reference to a field of type 'IncidentSeverity'
   */
  export type EnumIncidentSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentSeverity'>
    


  /**
   * Reference to a field of type 'IncidentSeverity[]'
   */
  export type ListEnumIncidentSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentSeverity[]'>
    


  /**
   * Reference to a field of type 'IncidentStatus'
   */
  export type EnumIncidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentStatus'>
    


  /**
   * Reference to a field of type 'IncidentStatus[]'
   */
  export type ListEnumIncidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentStatus[]'>
    


  /**
   * Reference to a field of type 'GSTTreatment'
   */
  export type EnumGSTTreatmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GSTTreatment'>
    


  /**
   * Reference to a field of type 'GSTTreatment[]'
   */
  export type ListEnumGSTTreatmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GSTTreatment[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    abn?: StringNullableFilter<"User"> | string | null
    tfn?: StringNullableFilter<"User"> | string | null
    taxResidency?: EnumTaxResidencyFilter<"User"> | $Enums.TaxResidency
    failedLoginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    emailVerificationToken?: StringNullableFilter<"User"> | string | null
    emailVerificationExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    taxReturns?: TaxReturnListRelationFilter
    payments?: PaymentListRelationFilter
    aiConversations?: AIConversationListRelationFilter
    aiInsights?: AIInsightListRelationFilter
    aiUsageTracking?: AIUsageTrackingListRelationFilter
    basiq_users?: XOR<Basiq_usersNullableScalarRelationFilter, basiq_usersWhereInput> | null
    basiq_api_logs?: Basiq_api_logsListRelationFilter
    receipts?: ReceiptListRelationFilter
    budgets?: BudgetListRelationFilter
    budgetTracking?: BudgetTrackingListRelationFilter
    financialInsights?: FinancialInsightListRelationFilter
    goals?: GoalListRelationFilter
    financialAuditLogs?: FinancialAuditLogListRelationFilter
    amlMonitoring?: AMLTransactionMonitoringListRelationFilter
    privacyConsents?: PrivacyConsentListRelationFilter
    dataAccessRequests?: DataAccessRequestListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    abn?: SortOrderInput | SortOrder
    tfn?: SortOrderInput | SortOrder
    taxResidency?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    emailVerificationExpires?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpires?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    taxReturns?: TaxReturnOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    aiConversations?: AIConversationOrderByRelationAggregateInput
    aiInsights?: AIInsightOrderByRelationAggregateInput
    aiUsageTracking?: AIUsageTrackingOrderByRelationAggregateInput
    basiq_users?: basiq_usersOrderByWithRelationInput
    basiq_api_logs?: basiq_api_logsOrderByRelationAggregateInput
    receipts?: ReceiptOrderByRelationAggregateInput
    budgets?: BudgetOrderByRelationAggregateInput
    budgetTracking?: BudgetTrackingOrderByRelationAggregateInput
    financialInsights?: FinancialInsightOrderByRelationAggregateInput
    goals?: GoalOrderByRelationAggregateInput
    financialAuditLogs?: FinancialAuditLogOrderByRelationAggregateInput
    amlMonitoring?: AMLTransactionMonitoringOrderByRelationAggregateInput
    privacyConsents?: PrivacyConsentOrderByRelationAggregateInput
    dataAccessRequests?: DataAccessRequestOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    emailVerificationToken?: string
    passwordResetToken?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    abn?: StringNullableFilter<"User"> | string | null
    tfn?: StringNullableFilter<"User"> | string | null
    taxResidency?: EnumTaxResidencyFilter<"User"> | $Enums.TaxResidency
    failedLoginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    emailVerificationExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    taxReturns?: TaxReturnListRelationFilter
    payments?: PaymentListRelationFilter
    aiConversations?: AIConversationListRelationFilter
    aiInsights?: AIInsightListRelationFilter
    aiUsageTracking?: AIUsageTrackingListRelationFilter
    basiq_users?: XOR<Basiq_usersNullableScalarRelationFilter, basiq_usersWhereInput> | null
    basiq_api_logs?: Basiq_api_logsListRelationFilter
    receipts?: ReceiptListRelationFilter
    budgets?: BudgetListRelationFilter
    budgetTracking?: BudgetTrackingListRelationFilter
    financialInsights?: FinancialInsightListRelationFilter
    goals?: GoalListRelationFilter
    financialAuditLogs?: FinancialAuditLogListRelationFilter
    amlMonitoring?: AMLTransactionMonitoringListRelationFilter
    privacyConsents?: PrivacyConsentListRelationFilter
    dataAccessRequests?: DataAccessRequestListRelationFilter
  }, "id" | "email" | "emailVerificationToken" | "passwordResetToken">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    abn?: SortOrderInput | SortOrder
    tfn?: SortOrderInput | SortOrder
    taxResidency?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    emailVerificationExpires?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpires?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    name?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    abn?: StringNullableWithAggregatesFilter<"User"> | string | null
    tfn?: StringNullableWithAggregatesFilter<"User"> | string | null
    taxResidency?: EnumTaxResidencyWithAggregatesFilter<"User"> | $Enums.TaxResidency
    failedLoginAttempts?: IntWithAggregatesFilter<"User"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerificationExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    event?: EnumAuthEventFilter<"AuditLog"> | $Enums.AuthEvent
    ipAddress?: StringFilter<"AuditLog"> | string
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    success?: BoolFilter<"AuditLog"> | boolean
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    event?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    success?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    event?: EnumAuthEventFilter<"AuditLog"> | $Enums.AuthEvent
    ipAddress?: StringFilter<"AuditLog"> | string
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    success?: BoolFilter<"AuditLog"> | boolean
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    event?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    success?: SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    event?: EnumAuthEventWithAggregatesFilter<"AuditLog"> | $Enums.AuthEvent
    ipAddress?: StringWithAggregatesFilter<"AuditLog"> | string
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    success?: BoolWithAggregatesFilter<"AuditLog"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type FinancialAuditLogWhereInput = {
    AND?: FinancialAuditLogWhereInput | FinancialAuditLogWhereInput[]
    OR?: FinancialAuditLogWhereInput[]
    NOT?: FinancialAuditLogWhereInput | FinancialAuditLogWhereInput[]
    id?: StringFilter<"FinancialAuditLog"> | string
    userId?: StringFilter<"FinancialAuditLog"> | string
    sessionId?: UuidNullableFilter<"FinancialAuditLog"> | string | null
    operationType?: EnumFinancialOperationFilter<"FinancialAuditLog"> | $Enums.FinancialOperation
    resourceType?: StringFilter<"FinancialAuditLog"> | string
    resourceId?: UuidNullableFilter<"FinancialAuditLog"> | string | null
    ipAddress?: StringFilter<"FinancialAuditLog"> | string
    userAgent?: StringNullableFilter<"FinancialAuditLog"> | string | null
    httpMethod?: StringNullableFilter<"FinancialAuditLog"> | string | null
    endpoint?: StringNullableFilter<"FinancialAuditLog"> | string | null
    previousData?: JsonNullableFilter<"FinancialAuditLog">
    currentData?: JsonNullableFilter<"FinancialAuditLog">
    changedFields?: StringNullableListFilter<"FinancialAuditLog">
    amount?: DecimalNullableFilter<"FinancialAuditLog"> | Decimal | DecimalJsLike | number | string | null
    gstAmount?: DecimalNullableFilter<"FinancialAuditLog"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"FinancialAuditLog"> | string | null
    taxYear?: StringNullableFilter<"FinancialAuditLog"> | string | null
    success?: BoolFilter<"FinancialAuditLog"> | boolean
    errorMessage?: StringNullableFilter<"FinancialAuditLog"> | string | null
    hashChain?: StringNullableFilter<"FinancialAuditLog"> | string | null
    previousHash?: StringNullableFilter<"FinancialAuditLog"> | string | null
    createdAt?: DateTimeFilter<"FinancialAuditLog"> | Date | string
    timezone?: StringFilter<"FinancialAuditLog"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FinancialAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    operationType?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    httpMethod?: SortOrderInput | SortOrder
    endpoint?: SortOrderInput | SortOrder
    previousData?: SortOrderInput | SortOrder
    currentData?: SortOrderInput | SortOrder
    changedFields?: SortOrder
    amount?: SortOrderInput | SortOrder
    gstAmount?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    taxYear?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    hashChain?: SortOrderInput | SortOrder
    previousHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    timezone?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FinancialAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FinancialAuditLogWhereInput | FinancialAuditLogWhereInput[]
    OR?: FinancialAuditLogWhereInput[]
    NOT?: FinancialAuditLogWhereInput | FinancialAuditLogWhereInput[]
    userId?: StringFilter<"FinancialAuditLog"> | string
    sessionId?: UuidNullableFilter<"FinancialAuditLog"> | string | null
    operationType?: EnumFinancialOperationFilter<"FinancialAuditLog"> | $Enums.FinancialOperation
    resourceType?: StringFilter<"FinancialAuditLog"> | string
    resourceId?: UuidNullableFilter<"FinancialAuditLog"> | string | null
    ipAddress?: StringFilter<"FinancialAuditLog"> | string
    userAgent?: StringNullableFilter<"FinancialAuditLog"> | string | null
    httpMethod?: StringNullableFilter<"FinancialAuditLog"> | string | null
    endpoint?: StringNullableFilter<"FinancialAuditLog"> | string | null
    previousData?: JsonNullableFilter<"FinancialAuditLog">
    currentData?: JsonNullableFilter<"FinancialAuditLog">
    changedFields?: StringNullableListFilter<"FinancialAuditLog">
    amount?: DecimalNullableFilter<"FinancialAuditLog"> | Decimal | DecimalJsLike | number | string | null
    gstAmount?: DecimalNullableFilter<"FinancialAuditLog"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"FinancialAuditLog"> | string | null
    taxYear?: StringNullableFilter<"FinancialAuditLog"> | string | null
    success?: BoolFilter<"FinancialAuditLog"> | boolean
    errorMessage?: StringNullableFilter<"FinancialAuditLog"> | string | null
    hashChain?: StringNullableFilter<"FinancialAuditLog"> | string | null
    previousHash?: StringNullableFilter<"FinancialAuditLog"> | string | null
    createdAt?: DateTimeFilter<"FinancialAuditLog"> | Date | string
    timezone?: StringFilter<"FinancialAuditLog"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FinancialAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    operationType?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    httpMethod?: SortOrderInput | SortOrder
    endpoint?: SortOrderInput | SortOrder
    previousData?: SortOrderInput | SortOrder
    currentData?: SortOrderInput | SortOrder
    changedFields?: SortOrder
    amount?: SortOrderInput | SortOrder
    gstAmount?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    taxYear?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    hashChain?: SortOrderInput | SortOrder
    previousHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    timezone?: SortOrder
    _count?: FinancialAuditLogCountOrderByAggregateInput
    _avg?: FinancialAuditLogAvgOrderByAggregateInput
    _max?: FinancialAuditLogMaxOrderByAggregateInput
    _min?: FinancialAuditLogMinOrderByAggregateInput
    _sum?: FinancialAuditLogSumOrderByAggregateInput
  }

  export type FinancialAuditLogScalarWhereWithAggregatesInput = {
    AND?: FinancialAuditLogScalarWhereWithAggregatesInput | FinancialAuditLogScalarWhereWithAggregatesInput[]
    OR?: FinancialAuditLogScalarWhereWithAggregatesInput[]
    NOT?: FinancialAuditLogScalarWhereWithAggregatesInput | FinancialAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FinancialAuditLog"> | string
    userId?: StringWithAggregatesFilter<"FinancialAuditLog"> | string
    sessionId?: UuidNullableWithAggregatesFilter<"FinancialAuditLog"> | string | null
    operationType?: EnumFinancialOperationWithAggregatesFilter<"FinancialAuditLog"> | $Enums.FinancialOperation
    resourceType?: StringWithAggregatesFilter<"FinancialAuditLog"> | string
    resourceId?: UuidNullableWithAggregatesFilter<"FinancialAuditLog"> | string | null
    ipAddress?: StringWithAggregatesFilter<"FinancialAuditLog"> | string
    userAgent?: StringNullableWithAggregatesFilter<"FinancialAuditLog"> | string | null
    httpMethod?: StringNullableWithAggregatesFilter<"FinancialAuditLog"> | string | null
    endpoint?: StringNullableWithAggregatesFilter<"FinancialAuditLog"> | string | null
    previousData?: JsonNullableWithAggregatesFilter<"FinancialAuditLog">
    currentData?: JsonNullableWithAggregatesFilter<"FinancialAuditLog">
    changedFields?: StringNullableListFilter<"FinancialAuditLog">
    amount?: DecimalNullableWithAggregatesFilter<"FinancialAuditLog"> | Decimal | DecimalJsLike | number | string | null
    gstAmount?: DecimalNullableWithAggregatesFilter<"FinancialAuditLog"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableWithAggregatesFilter<"FinancialAuditLog"> | string | null
    taxYear?: StringNullableWithAggregatesFilter<"FinancialAuditLog"> | string | null
    success?: BoolWithAggregatesFilter<"FinancialAuditLog"> | boolean
    errorMessage?: StringNullableWithAggregatesFilter<"FinancialAuditLog"> | string | null
    hashChain?: StringNullableWithAggregatesFilter<"FinancialAuditLog"> | string | null
    previousHash?: StringNullableWithAggregatesFilter<"FinancialAuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FinancialAuditLog"> | Date | string
    timezone?: StringWithAggregatesFilter<"FinancialAuditLog"> | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    stripeCustomerId?: StringFilter<"Subscription"> | string
    stripeSubscriptionId?: StringFilter<"Subscription"> | string
    stripePriceId?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    plan?: EnumPlanFilter<"Subscription"> | $Enums.Plan
    interval?: StringFilter<"Subscription"> | string
    amount?: IntFilter<"Subscription"> | number
    currency?: StringFilter<"Subscription"> | string
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    defaultPaymentMethodId?: StringNullableFilter<"Subscription"> | string | null
    lastPaymentAttempt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    failedPaymentCount?: IntFilter<"Subscription"> | number
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    status?: SortOrder
    plan?: SortOrder
    interval?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    defaultPaymentMethodId?: SortOrderInput | SortOrder
    lastPaymentAttempt?: SortOrderInput | SortOrder
    failedPaymentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    stripeCustomerId?: string
    stripeSubscriptionId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    stripePriceId?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    plan?: EnumPlanFilter<"Subscription"> | $Enums.Plan
    interval?: StringFilter<"Subscription"> | string
    amount?: IntFilter<"Subscription"> | number
    currency?: StringFilter<"Subscription"> | string
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    defaultPaymentMethodId?: StringNullableFilter<"Subscription"> | string | null
    lastPaymentAttempt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    failedPaymentCount?: IntFilter<"Subscription"> | number
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId" | "stripeCustomerId" | "stripeSubscriptionId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    status?: SortOrder
    plan?: SortOrder
    interval?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    defaultPaymentMethodId?: SortOrderInput | SortOrder
    lastPaymentAttempt?: SortOrderInput | SortOrder
    failedPaymentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: StringWithAggregatesFilter<"Subscription"> | string
    stripeCustomerId?: StringWithAggregatesFilter<"Subscription"> | string
    stripeSubscriptionId?: StringWithAggregatesFilter<"Subscription"> | string
    stripePriceId?: StringWithAggregatesFilter<"Subscription"> | string
    status?: StringWithAggregatesFilter<"Subscription"> | string
    plan?: EnumPlanWithAggregatesFilter<"Subscription"> | $Enums.Plan
    interval?: StringWithAggregatesFilter<"Subscription"> | string
    amount?: IntWithAggregatesFilter<"Subscription"> | number
    currency?: StringWithAggregatesFilter<"Subscription"> | string
    currentPeriodStart?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"Subscription"> | boolean
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    defaultPaymentMethodId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    lastPaymentAttempt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    failedPaymentCount?: IntWithAggregatesFilter<"Subscription"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type TaxReturnWhereInput = {
    AND?: TaxReturnWhereInput | TaxReturnWhereInput[]
    OR?: TaxReturnWhereInput[]
    NOT?: TaxReturnWhereInput | TaxReturnWhereInput[]
    id?: StringFilter<"TaxReturn"> | string
    userId?: StringFilter<"TaxReturn"> | string
    year?: StringFilter<"TaxReturn"> | string
    data?: JsonFilter<"TaxReturn">
    status?: EnumTaxReturnStatusFilter<"TaxReturn"> | $Enums.TaxReturnStatus
    submittedAt?: DateTimeNullableFilter<"TaxReturn"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"TaxReturn"> | Date | string | null
    createdAt?: DateTimeFilter<"TaxReturn"> | Date | string
    updatedAt?: DateTimeFilter<"TaxReturn"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TaxReturnOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    data?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TaxReturnWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_year?: TaxReturnUserIdYearCompoundUniqueInput
    AND?: TaxReturnWhereInput | TaxReturnWhereInput[]
    OR?: TaxReturnWhereInput[]
    NOT?: TaxReturnWhereInput | TaxReturnWhereInput[]
    userId?: StringFilter<"TaxReturn"> | string
    year?: StringFilter<"TaxReturn"> | string
    data?: JsonFilter<"TaxReturn">
    status?: EnumTaxReturnStatusFilter<"TaxReturn"> | $Enums.TaxReturnStatus
    submittedAt?: DateTimeNullableFilter<"TaxReturn"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"TaxReturn"> | Date | string | null
    createdAt?: DateTimeFilter<"TaxReturn"> | Date | string
    updatedAt?: DateTimeFilter<"TaxReturn"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_year">

  export type TaxReturnOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    data?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaxReturnCountOrderByAggregateInput
    _max?: TaxReturnMaxOrderByAggregateInput
    _min?: TaxReturnMinOrderByAggregateInput
  }

  export type TaxReturnScalarWhereWithAggregatesInput = {
    AND?: TaxReturnScalarWhereWithAggregatesInput | TaxReturnScalarWhereWithAggregatesInput[]
    OR?: TaxReturnScalarWhereWithAggregatesInput[]
    NOT?: TaxReturnScalarWhereWithAggregatesInput | TaxReturnScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaxReturn"> | string
    userId?: StringWithAggregatesFilter<"TaxReturn"> | string
    year?: StringWithAggregatesFilter<"TaxReturn"> | string
    data?: JsonWithAggregatesFilter<"TaxReturn">
    status?: EnumTaxReturnStatusWithAggregatesFilter<"TaxReturn"> | $Enums.TaxReturnStatus
    submittedAt?: DateTimeNullableWithAggregatesFilter<"TaxReturn"> | Date | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"TaxReturn"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TaxReturn"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaxReturn"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    stripePaymentIntentId?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    description?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripePaymentIntentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripePaymentIntentId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    userId?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    description?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "stripePaymentIntentId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripePaymentIntentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    stripePaymentIntentId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: IntWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: StringWithAggregatesFilter<"Payment"> | string
    description?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Payment">
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    stripeInvoiceId?: StringFilter<"Invoice"> | string
    customerName?: StringFilter<"Invoice"> | string
    customerEmail?: StringFilter<"Invoice"> | string
    customerABN?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: IntFilter<"Invoice"> | number
    gstAmount?: IntFilter<"Invoice"> | number
    total?: IntFilter<"Invoice"> | number
    status?: StringFilter<"Invoice"> | string
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    lineItems?: InvoiceLineItemListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    stripeInvoiceId?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerABN?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    gstAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    invoiceDate?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lineItems?: InvoiceLineItemOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    stripeInvoiceId?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    customerName?: StringFilter<"Invoice"> | string
    customerEmail?: StringFilter<"Invoice"> | string
    customerABN?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: IntFilter<"Invoice"> | number
    gstAmount?: IntFilter<"Invoice"> | number
    total?: IntFilter<"Invoice"> | number
    status?: StringFilter<"Invoice"> | string
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    lineItems?: InvoiceLineItemListRelationFilter
  }, "id" | "invoiceNumber" | "stripeInvoiceId">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    stripeInvoiceId?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerABN?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    gstAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    invoiceDate?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    stripeInvoiceId?: StringWithAggregatesFilter<"Invoice"> | string
    customerName?: StringWithAggregatesFilter<"Invoice"> | string
    customerEmail?: StringWithAggregatesFilter<"Invoice"> | string
    customerABN?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    subtotal?: IntWithAggregatesFilter<"Invoice"> | number
    gstAmount?: IntWithAggregatesFilter<"Invoice"> | number
    total?: IntWithAggregatesFilter<"Invoice"> | number
    status?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceLineItemWhereInput = {
    AND?: InvoiceLineItemWhereInput | InvoiceLineItemWhereInput[]
    OR?: InvoiceLineItemWhereInput[]
    NOT?: InvoiceLineItemWhereInput | InvoiceLineItemWhereInput[]
    id?: StringFilter<"InvoiceLineItem"> | string
    invoiceId?: StringFilter<"InvoiceLineItem"> | string
    description?: StringFilter<"InvoiceLineItem"> | string
    quantity?: IntFilter<"InvoiceLineItem"> | number
    unitPrice?: IntFilter<"InvoiceLineItem"> | number
    totalPrice?: IntFilter<"InvoiceLineItem"> | number
    createdAt?: DateTimeFilter<"InvoiceLineItem"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceLineItem"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceLineItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceLineItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceLineItemWhereInput | InvoiceLineItemWhereInput[]
    OR?: InvoiceLineItemWhereInput[]
    NOT?: InvoiceLineItemWhereInput | InvoiceLineItemWhereInput[]
    invoiceId?: StringFilter<"InvoiceLineItem"> | string
    description?: StringFilter<"InvoiceLineItem"> | string
    quantity?: IntFilter<"InvoiceLineItem"> | number
    unitPrice?: IntFilter<"InvoiceLineItem"> | number
    totalPrice?: IntFilter<"InvoiceLineItem"> | number
    createdAt?: DateTimeFilter<"InvoiceLineItem"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceLineItem"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }, "id">

  export type InvoiceLineItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceLineItemCountOrderByAggregateInput
    _avg?: InvoiceLineItemAvgOrderByAggregateInput
    _max?: InvoiceLineItemMaxOrderByAggregateInput
    _min?: InvoiceLineItemMinOrderByAggregateInput
    _sum?: InvoiceLineItemSumOrderByAggregateInput
  }

  export type InvoiceLineItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceLineItemScalarWhereWithAggregatesInput | InvoiceLineItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceLineItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceLineItemScalarWhereWithAggregatesInput | InvoiceLineItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceLineItem"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoiceLineItem"> | string
    description?: StringWithAggregatesFilter<"InvoiceLineItem"> | string
    quantity?: IntWithAggregatesFilter<"InvoiceLineItem"> | number
    unitPrice?: IntWithAggregatesFilter<"InvoiceLineItem"> | number
    totalPrice?: IntWithAggregatesFilter<"InvoiceLineItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceLineItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InvoiceLineItem"> | Date | string
  }

  export type AIConversationWhereInput = {
    AND?: AIConversationWhereInput | AIConversationWhereInput[]
    OR?: AIConversationWhereInput[]
    NOT?: AIConversationWhereInput | AIConversationWhereInput[]
    id?: StringFilter<"AIConversation"> | string
    userId?: StringFilter<"AIConversation"> | string
    sessionId?: UuidFilter<"AIConversation"> | string
    provider?: StringFilter<"AIConversation"> | string
    model?: StringFilter<"AIConversation"> | string
    messages?: JsonFilter<"AIConversation">
    context?: JsonNullableFilter<"AIConversation">
    tokensUsed?: IntFilter<"AIConversation"> | number
    costUsd?: DecimalFilter<"AIConversation"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"AIConversation"> | Date | string
    updatedAt?: DateTimeFilter<"AIConversation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AIConversationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    messages?: SortOrder
    context?: SortOrderInput | SortOrder
    tokensUsed?: SortOrder
    costUsd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AIConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIConversationWhereInput | AIConversationWhereInput[]
    OR?: AIConversationWhereInput[]
    NOT?: AIConversationWhereInput | AIConversationWhereInput[]
    userId?: StringFilter<"AIConversation"> | string
    sessionId?: UuidFilter<"AIConversation"> | string
    provider?: StringFilter<"AIConversation"> | string
    model?: StringFilter<"AIConversation"> | string
    messages?: JsonFilter<"AIConversation">
    context?: JsonNullableFilter<"AIConversation">
    tokensUsed?: IntFilter<"AIConversation"> | number
    costUsd?: DecimalFilter<"AIConversation"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"AIConversation"> | Date | string
    updatedAt?: DateTimeFilter<"AIConversation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AIConversationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    messages?: SortOrder
    context?: SortOrderInput | SortOrder
    tokensUsed?: SortOrder
    costUsd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIConversationCountOrderByAggregateInput
    _avg?: AIConversationAvgOrderByAggregateInput
    _max?: AIConversationMaxOrderByAggregateInput
    _min?: AIConversationMinOrderByAggregateInput
    _sum?: AIConversationSumOrderByAggregateInput
  }

  export type AIConversationScalarWhereWithAggregatesInput = {
    AND?: AIConversationScalarWhereWithAggregatesInput | AIConversationScalarWhereWithAggregatesInput[]
    OR?: AIConversationScalarWhereWithAggregatesInput[]
    NOT?: AIConversationScalarWhereWithAggregatesInput | AIConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIConversation"> | string
    userId?: StringWithAggregatesFilter<"AIConversation"> | string
    sessionId?: UuidWithAggregatesFilter<"AIConversation"> | string
    provider?: StringWithAggregatesFilter<"AIConversation"> | string
    model?: StringWithAggregatesFilter<"AIConversation"> | string
    messages?: JsonWithAggregatesFilter<"AIConversation">
    context?: JsonNullableWithAggregatesFilter<"AIConversation">
    tokensUsed?: IntWithAggregatesFilter<"AIConversation"> | number
    costUsd?: DecimalWithAggregatesFilter<"AIConversation"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"AIConversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIConversation"> | Date | string
  }

  export type AIInsightWhereInput = {
    AND?: AIInsightWhereInput | AIInsightWhereInput[]
    OR?: AIInsightWhereInput[]
    NOT?: AIInsightWhereInput | AIInsightWhereInput[]
    id?: StringFilter<"AIInsight"> | string
    userId?: StringFilter<"AIInsight"> | string
    insightType?: StringFilter<"AIInsight"> | string
    category?: StringFilter<"AIInsight"> | string
    content?: JsonFilter<"AIInsight">
    confidenceScore?: DecimalNullableFilter<"AIInsight"> | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: StringNullableListFilter<"AIInsight">
    provider?: StringFilter<"AIInsight"> | string
    model?: StringFilter<"AIInsight"> | string
    isActive?: BoolFilter<"AIInsight"> | boolean
    expiresAt?: DateTimeNullableFilter<"AIInsight"> | Date | string | null
    createdAt?: DateTimeFilter<"AIInsight"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AIInsightOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    category?: SortOrder
    content?: SortOrder
    confidenceScore?: SortOrderInput | SortOrder
    sourceDataIds?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AIInsightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIInsightWhereInput | AIInsightWhereInput[]
    OR?: AIInsightWhereInput[]
    NOT?: AIInsightWhereInput | AIInsightWhereInput[]
    userId?: StringFilter<"AIInsight"> | string
    insightType?: StringFilter<"AIInsight"> | string
    category?: StringFilter<"AIInsight"> | string
    content?: JsonFilter<"AIInsight">
    confidenceScore?: DecimalNullableFilter<"AIInsight"> | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: StringNullableListFilter<"AIInsight">
    provider?: StringFilter<"AIInsight"> | string
    model?: StringFilter<"AIInsight"> | string
    isActive?: BoolFilter<"AIInsight"> | boolean
    expiresAt?: DateTimeNullableFilter<"AIInsight"> | Date | string | null
    createdAt?: DateTimeFilter<"AIInsight"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AIInsightOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    category?: SortOrder
    content?: SortOrder
    confidenceScore?: SortOrderInput | SortOrder
    sourceDataIds?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIInsightCountOrderByAggregateInput
    _avg?: AIInsightAvgOrderByAggregateInput
    _max?: AIInsightMaxOrderByAggregateInput
    _min?: AIInsightMinOrderByAggregateInput
    _sum?: AIInsightSumOrderByAggregateInput
  }

  export type AIInsightScalarWhereWithAggregatesInput = {
    AND?: AIInsightScalarWhereWithAggregatesInput | AIInsightScalarWhereWithAggregatesInput[]
    OR?: AIInsightScalarWhereWithAggregatesInput[]
    NOT?: AIInsightScalarWhereWithAggregatesInput | AIInsightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIInsight"> | string
    userId?: StringWithAggregatesFilter<"AIInsight"> | string
    insightType?: StringWithAggregatesFilter<"AIInsight"> | string
    category?: StringWithAggregatesFilter<"AIInsight"> | string
    content?: JsonWithAggregatesFilter<"AIInsight">
    confidenceScore?: DecimalNullableWithAggregatesFilter<"AIInsight"> | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: StringNullableListFilter<"AIInsight">
    provider?: StringWithAggregatesFilter<"AIInsight"> | string
    model?: StringWithAggregatesFilter<"AIInsight"> | string
    isActive?: BoolWithAggregatesFilter<"AIInsight"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"AIInsight"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIInsight"> | Date | string
  }

  export type AIUsageTrackingWhereInput = {
    AND?: AIUsageTrackingWhereInput | AIUsageTrackingWhereInput[]
    OR?: AIUsageTrackingWhereInput[]
    NOT?: AIUsageTrackingWhereInput | AIUsageTrackingWhereInput[]
    id?: StringFilter<"AIUsageTracking"> | string
    userId?: StringFilter<"AIUsageTracking"> | string
    provider?: StringFilter<"AIUsageTracking"> | string
    model?: StringFilter<"AIUsageTracking"> | string
    operationType?: StringFilter<"AIUsageTracking"> | string
    tokensInput?: IntFilter<"AIUsageTracking"> | number
    tokensOutput?: IntFilter<"AIUsageTracking"> | number
    costUsd?: DecimalFilter<"AIUsageTracking"> | Decimal | DecimalJsLike | number | string
    responseTimeMs?: IntNullableFilter<"AIUsageTracking"> | number | null
    success?: BoolFilter<"AIUsageTracking"> | boolean
    errorMessage?: StringNullableFilter<"AIUsageTracking"> | string | null
    createdAt?: DateTimeFilter<"AIUsageTracking"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AIUsageTrackingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    operationType?: SortOrder
    tokensInput?: SortOrder
    tokensOutput?: SortOrder
    costUsd?: SortOrder
    responseTimeMs?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AIUsageTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIUsageTrackingWhereInput | AIUsageTrackingWhereInput[]
    OR?: AIUsageTrackingWhereInput[]
    NOT?: AIUsageTrackingWhereInput | AIUsageTrackingWhereInput[]
    userId?: StringFilter<"AIUsageTracking"> | string
    provider?: StringFilter<"AIUsageTracking"> | string
    model?: StringFilter<"AIUsageTracking"> | string
    operationType?: StringFilter<"AIUsageTracking"> | string
    tokensInput?: IntFilter<"AIUsageTracking"> | number
    tokensOutput?: IntFilter<"AIUsageTracking"> | number
    costUsd?: DecimalFilter<"AIUsageTracking"> | Decimal | DecimalJsLike | number | string
    responseTimeMs?: IntNullableFilter<"AIUsageTracking"> | number | null
    success?: BoolFilter<"AIUsageTracking"> | boolean
    errorMessage?: StringNullableFilter<"AIUsageTracking"> | string | null
    createdAt?: DateTimeFilter<"AIUsageTracking"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AIUsageTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    operationType?: SortOrder
    tokensInput?: SortOrder
    tokensOutput?: SortOrder
    costUsd?: SortOrder
    responseTimeMs?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIUsageTrackingCountOrderByAggregateInput
    _avg?: AIUsageTrackingAvgOrderByAggregateInput
    _max?: AIUsageTrackingMaxOrderByAggregateInput
    _min?: AIUsageTrackingMinOrderByAggregateInput
    _sum?: AIUsageTrackingSumOrderByAggregateInput
  }

  export type AIUsageTrackingScalarWhereWithAggregatesInput = {
    AND?: AIUsageTrackingScalarWhereWithAggregatesInput | AIUsageTrackingScalarWhereWithAggregatesInput[]
    OR?: AIUsageTrackingScalarWhereWithAggregatesInput[]
    NOT?: AIUsageTrackingScalarWhereWithAggregatesInput | AIUsageTrackingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIUsageTracking"> | string
    userId?: StringWithAggregatesFilter<"AIUsageTracking"> | string
    provider?: StringWithAggregatesFilter<"AIUsageTracking"> | string
    model?: StringWithAggregatesFilter<"AIUsageTracking"> | string
    operationType?: StringWithAggregatesFilter<"AIUsageTracking"> | string
    tokensInput?: IntWithAggregatesFilter<"AIUsageTracking"> | number
    tokensOutput?: IntWithAggregatesFilter<"AIUsageTracking"> | number
    costUsd?: DecimalWithAggregatesFilter<"AIUsageTracking"> | Decimal | DecimalJsLike | number | string
    responseTimeMs?: IntNullableWithAggregatesFilter<"AIUsageTracking"> | number | null
    success?: BoolWithAggregatesFilter<"AIUsageTracking"> | boolean
    errorMessage?: StringNullableWithAggregatesFilter<"AIUsageTracking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIUsageTracking"> | Date | string
  }

  export type AICacheWhereInput = {
    AND?: AICacheWhereInput | AICacheWhereInput[]
    OR?: AICacheWhereInput[]
    NOT?: AICacheWhereInput | AICacheWhereInput[]
    id?: StringFilter<"AICache"> | string
    cacheKey?: StringFilter<"AICache"> | string
    operationType?: StringFilter<"AICache"> | string
    inputHash?: StringFilter<"AICache"> | string
    response?: JsonFilter<"AICache">
    provider?: StringFilter<"AICache"> | string
    model?: StringFilter<"AICache"> | string
    hitCount?: IntFilter<"AICache"> | number
    expiresAt?: DateTimeFilter<"AICache"> | Date | string
    createdAt?: DateTimeFilter<"AICache"> | Date | string
  }

  export type AICacheOrderByWithRelationInput = {
    id?: SortOrder
    cacheKey?: SortOrder
    operationType?: SortOrder
    inputHash?: SortOrder
    response?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    hitCount?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AICacheWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cacheKey?: string
    AND?: AICacheWhereInput | AICacheWhereInput[]
    OR?: AICacheWhereInput[]
    NOT?: AICacheWhereInput | AICacheWhereInput[]
    operationType?: StringFilter<"AICache"> | string
    inputHash?: StringFilter<"AICache"> | string
    response?: JsonFilter<"AICache">
    provider?: StringFilter<"AICache"> | string
    model?: StringFilter<"AICache"> | string
    hitCount?: IntFilter<"AICache"> | number
    expiresAt?: DateTimeFilter<"AICache"> | Date | string
    createdAt?: DateTimeFilter<"AICache"> | Date | string
  }, "id" | "cacheKey">

  export type AICacheOrderByWithAggregationInput = {
    id?: SortOrder
    cacheKey?: SortOrder
    operationType?: SortOrder
    inputHash?: SortOrder
    response?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    hitCount?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: AICacheCountOrderByAggregateInput
    _avg?: AICacheAvgOrderByAggregateInput
    _max?: AICacheMaxOrderByAggregateInput
    _min?: AICacheMinOrderByAggregateInput
    _sum?: AICacheSumOrderByAggregateInput
  }

  export type AICacheScalarWhereWithAggregatesInput = {
    AND?: AICacheScalarWhereWithAggregatesInput | AICacheScalarWhereWithAggregatesInput[]
    OR?: AICacheScalarWhereWithAggregatesInput[]
    NOT?: AICacheScalarWhereWithAggregatesInput | AICacheScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AICache"> | string
    cacheKey?: StringWithAggregatesFilter<"AICache"> | string
    operationType?: StringWithAggregatesFilter<"AICache"> | string
    inputHash?: StringWithAggregatesFilter<"AICache"> | string
    response?: JsonWithAggregatesFilter<"AICache">
    provider?: StringWithAggregatesFilter<"AICache"> | string
    model?: StringWithAggregatesFilter<"AICache"> | string
    hitCount?: IntWithAggregatesFilter<"AICache"> | number
    expiresAt?: DateTimeWithAggregatesFilter<"AICache"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AICache"> | Date | string
  }

  export type AIProviderHealthWhereInput = {
    AND?: AIProviderHealthWhereInput | AIProviderHealthWhereInput[]
    OR?: AIProviderHealthWhereInput[]
    NOT?: AIProviderHealthWhereInput | AIProviderHealthWhereInput[]
    id?: StringFilter<"AIProviderHealth"> | string
    provider?: StringFilter<"AIProviderHealth"> | string
    status?: StringFilter<"AIProviderHealth"> | string
    consecutiveFailures?: IntFilter<"AIProviderHealth"> | number
    lastFailureAt?: DateTimeNullableFilter<"AIProviderHealth"> | Date | string | null
    lastSuccessAt?: DateTimeNullableFilter<"AIProviderHealth"> | Date | string | null
    circuitOpenUntil?: DateTimeNullableFilter<"AIProviderHealth"> | Date | string | null
    createdAt?: DateTimeFilter<"AIProviderHealth"> | Date | string
    updatedAt?: DateTimeFilter<"AIProviderHealth"> | Date | string
  }

  export type AIProviderHealthOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    consecutiveFailures?: SortOrder
    lastFailureAt?: SortOrderInput | SortOrder
    lastSuccessAt?: SortOrderInput | SortOrder
    circuitOpenUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIProviderHealthWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider?: string
    AND?: AIProviderHealthWhereInput | AIProviderHealthWhereInput[]
    OR?: AIProviderHealthWhereInput[]
    NOT?: AIProviderHealthWhereInput | AIProviderHealthWhereInput[]
    status?: StringFilter<"AIProviderHealth"> | string
    consecutiveFailures?: IntFilter<"AIProviderHealth"> | number
    lastFailureAt?: DateTimeNullableFilter<"AIProviderHealth"> | Date | string | null
    lastSuccessAt?: DateTimeNullableFilter<"AIProviderHealth"> | Date | string | null
    circuitOpenUntil?: DateTimeNullableFilter<"AIProviderHealth"> | Date | string | null
    createdAt?: DateTimeFilter<"AIProviderHealth"> | Date | string
    updatedAt?: DateTimeFilter<"AIProviderHealth"> | Date | string
  }, "id" | "provider">

  export type AIProviderHealthOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    consecutiveFailures?: SortOrder
    lastFailureAt?: SortOrderInput | SortOrder
    lastSuccessAt?: SortOrderInput | SortOrder
    circuitOpenUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIProviderHealthCountOrderByAggregateInput
    _avg?: AIProviderHealthAvgOrderByAggregateInput
    _max?: AIProviderHealthMaxOrderByAggregateInput
    _min?: AIProviderHealthMinOrderByAggregateInput
    _sum?: AIProviderHealthSumOrderByAggregateInput
  }

  export type AIProviderHealthScalarWhereWithAggregatesInput = {
    AND?: AIProviderHealthScalarWhereWithAggregatesInput | AIProviderHealthScalarWhereWithAggregatesInput[]
    OR?: AIProviderHealthScalarWhereWithAggregatesInput[]
    NOT?: AIProviderHealthScalarWhereWithAggregatesInput | AIProviderHealthScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIProviderHealth"> | string
    provider?: StringWithAggregatesFilter<"AIProviderHealth"> | string
    status?: StringWithAggregatesFilter<"AIProviderHealth"> | string
    consecutiveFailures?: IntWithAggregatesFilter<"AIProviderHealth"> | number
    lastFailureAt?: DateTimeNullableWithAggregatesFilter<"AIProviderHealth"> | Date | string | null
    lastSuccessAt?: DateTimeNullableWithAggregatesFilter<"AIProviderHealth"> | Date | string | null
    circuitOpenUntil?: DateTimeNullableWithAggregatesFilter<"AIProviderHealth"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIProviderHealth"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIProviderHealth"> | Date | string
  }

  export type basiq_usersWhereInput = {
    AND?: basiq_usersWhereInput | basiq_usersWhereInput[]
    OR?: basiq_usersWhereInput[]
    NOT?: basiq_usersWhereInput | basiq_usersWhereInput[]
    id?: UuidFilter<"basiq_users"> | string
    user_id?: StringFilter<"basiq_users"> | string
    basiq_user_id?: StringFilter<"basiq_users"> | string
    email?: StringFilter<"basiq_users"> | string
    mobile?: StringNullableFilter<"basiq_users"> | string | null
    connection_status?: StringNullableFilter<"basiq_users"> | string | null
    consent_id?: StringNullableFilter<"basiq_users"> | string | null
    consent_status?: StringNullableFilter<"basiq_users"> | string | null
    consent_expires_at?: DateTimeNullableFilter<"basiq_users"> | Date | string | null
    created_at?: DateTimeFilter<"basiq_users"> | Date | string
    updated_at?: DateTimeFilter<"basiq_users"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bank_connections?: Bank_connectionsListRelationFilter
    bank_accounts?: Bank_accountsListRelationFilter
  }

  export type basiq_usersOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    basiq_user_id?: SortOrder
    email?: SortOrder
    mobile?: SortOrderInput | SortOrder
    connection_status?: SortOrderInput | SortOrder
    consent_id?: SortOrderInput | SortOrder
    consent_status?: SortOrderInput | SortOrder
    consent_expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    bank_connections?: bank_connectionsOrderByRelationAggregateInput
    bank_accounts?: bank_accountsOrderByRelationAggregateInput
  }

  export type basiq_usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id?: string
    basiq_user_id?: string
    AND?: basiq_usersWhereInput | basiq_usersWhereInput[]
    OR?: basiq_usersWhereInput[]
    NOT?: basiq_usersWhereInput | basiq_usersWhereInput[]
    email?: StringFilter<"basiq_users"> | string
    mobile?: StringNullableFilter<"basiq_users"> | string | null
    connection_status?: StringNullableFilter<"basiq_users"> | string | null
    consent_id?: StringNullableFilter<"basiq_users"> | string | null
    consent_status?: StringNullableFilter<"basiq_users"> | string | null
    consent_expires_at?: DateTimeNullableFilter<"basiq_users"> | Date | string | null
    created_at?: DateTimeFilter<"basiq_users"> | Date | string
    updated_at?: DateTimeFilter<"basiq_users"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bank_connections?: Bank_connectionsListRelationFilter
    bank_accounts?: Bank_accountsListRelationFilter
  }, "id" | "user_id" | "basiq_user_id">

  export type basiq_usersOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    basiq_user_id?: SortOrder
    email?: SortOrder
    mobile?: SortOrderInput | SortOrder
    connection_status?: SortOrderInput | SortOrder
    consent_id?: SortOrderInput | SortOrder
    consent_status?: SortOrderInput | SortOrder
    consent_expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: basiq_usersCountOrderByAggregateInput
    _max?: basiq_usersMaxOrderByAggregateInput
    _min?: basiq_usersMinOrderByAggregateInput
  }

  export type basiq_usersScalarWhereWithAggregatesInput = {
    AND?: basiq_usersScalarWhereWithAggregatesInput | basiq_usersScalarWhereWithAggregatesInput[]
    OR?: basiq_usersScalarWhereWithAggregatesInput[]
    NOT?: basiq_usersScalarWhereWithAggregatesInput | basiq_usersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"basiq_users"> | string
    user_id?: StringWithAggregatesFilter<"basiq_users"> | string
    basiq_user_id?: StringWithAggregatesFilter<"basiq_users"> | string
    email?: StringWithAggregatesFilter<"basiq_users"> | string
    mobile?: StringNullableWithAggregatesFilter<"basiq_users"> | string | null
    connection_status?: StringNullableWithAggregatesFilter<"basiq_users"> | string | null
    consent_id?: StringNullableWithAggregatesFilter<"basiq_users"> | string | null
    consent_status?: StringNullableWithAggregatesFilter<"basiq_users"> | string | null
    consent_expires_at?: DateTimeNullableWithAggregatesFilter<"basiq_users"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"basiq_users"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"basiq_users"> | Date | string
  }

  export type bank_connectionsWhereInput = {
    AND?: bank_connectionsWhereInput | bank_connectionsWhereInput[]
    OR?: bank_connectionsWhereInput[]
    NOT?: bank_connectionsWhereInput | bank_connectionsWhereInput[]
    id?: UuidFilter<"bank_connections"> | string
    basiq_user_id?: UuidFilter<"bank_connections"> | string
    connection_id?: StringFilter<"bank_connections"> | string
    institution_id?: StringFilter<"bank_connections"> | string
    institution_name?: StringFilter<"bank_connections"> | string
    institution_short_name?: StringNullableFilter<"bank_connections"> | string | null
    institution_logo_url?: StringNullableFilter<"bank_connections"> | string | null
    status?: StringNullableFilter<"bank_connections"> | string | null
    last_synced?: DateTimeNullableFilter<"bank_connections"> | Date | string | null
    created_at?: DateTimeFilter<"bank_connections"> | Date | string
    updated_at?: DateTimeFilter<"bank_connections"> | Date | string
    basiq_user?: XOR<Basiq_usersScalarRelationFilter, basiq_usersWhereInput>
    bank_accounts?: Bank_accountsListRelationFilter
  }

  export type bank_connectionsOrderByWithRelationInput = {
    id?: SortOrder
    basiq_user_id?: SortOrder
    connection_id?: SortOrder
    institution_id?: SortOrder
    institution_name?: SortOrder
    institution_short_name?: SortOrderInput | SortOrder
    institution_logo_url?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    last_synced?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    basiq_user?: basiq_usersOrderByWithRelationInput
    bank_accounts?: bank_accountsOrderByRelationAggregateInput
  }

  export type bank_connectionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    connection_id?: string
    AND?: bank_connectionsWhereInput | bank_connectionsWhereInput[]
    OR?: bank_connectionsWhereInput[]
    NOT?: bank_connectionsWhereInput | bank_connectionsWhereInput[]
    basiq_user_id?: UuidFilter<"bank_connections"> | string
    institution_id?: StringFilter<"bank_connections"> | string
    institution_name?: StringFilter<"bank_connections"> | string
    institution_short_name?: StringNullableFilter<"bank_connections"> | string | null
    institution_logo_url?: StringNullableFilter<"bank_connections"> | string | null
    status?: StringNullableFilter<"bank_connections"> | string | null
    last_synced?: DateTimeNullableFilter<"bank_connections"> | Date | string | null
    created_at?: DateTimeFilter<"bank_connections"> | Date | string
    updated_at?: DateTimeFilter<"bank_connections"> | Date | string
    basiq_user?: XOR<Basiq_usersScalarRelationFilter, basiq_usersWhereInput>
    bank_accounts?: Bank_accountsListRelationFilter
  }, "id" | "connection_id">

  export type bank_connectionsOrderByWithAggregationInput = {
    id?: SortOrder
    basiq_user_id?: SortOrder
    connection_id?: SortOrder
    institution_id?: SortOrder
    institution_name?: SortOrder
    institution_short_name?: SortOrderInput | SortOrder
    institution_logo_url?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    last_synced?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: bank_connectionsCountOrderByAggregateInput
    _max?: bank_connectionsMaxOrderByAggregateInput
    _min?: bank_connectionsMinOrderByAggregateInput
  }

  export type bank_connectionsScalarWhereWithAggregatesInput = {
    AND?: bank_connectionsScalarWhereWithAggregatesInput | bank_connectionsScalarWhereWithAggregatesInput[]
    OR?: bank_connectionsScalarWhereWithAggregatesInput[]
    NOT?: bank_connectionsScalarWhereWithAggregatesInput | bank_connectionsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"bank_connections"> | string
    basiq_user_id?: UuidWithAggregatesFilter<"bank_connections"> | string
    connection_id?: StringWithAggregatesFilter<"bank_connections"> | string
    institution_id?: StringWithAggregatesFilter<"bank_connections"> | string
    institution_name?: StringWithAggregatesFilter<"bank_connections"> | string
    institution_short_name?: StringNullableWithAggregatesFilter<"bank_connections"> | string | null
    institution_logo_url?: StringNullableWithAggregatesFilter<"bank_connections"> | string | null
    status?: StringNullableWithAggregatesFilter<"bank_connections"> | string | null
    last_synced?: DateTimeNullableWithAggregatesFilter<"bank_connections"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"bank_connections"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"bank_connections"> | Date | string
  }

  export type bank_accountsWhereInput = {
    AND?: bank_accountsWhereInput | bank_accountsWhereInput[]
    OR?: bank_accountsWhereInput[]
    NOT?: bank_accountsWhereInput | bank_accountsWhereInput[]
    id?: UuidFilter<"bank_accounts"> | string
    basiq_user_id?: UuidFilter<"bank_accounts"> | string
    connection_id?: UuidFilter<"bank_accounts"> | string
    basiq_account_id?: StringFilter<"bank_accounts"> | string
    account_holder?: StringNullableFilter<"bank_accounts"> | string | null
    account_number?: StringNullableFilter<"bank_accounts"> | string | null
    bsb?: StringNullableFilter<"bank_accounts"> | string | null
    institution_name?: StringNullableFilter<"bank_accounts"> | string | null
    account_type?: StringNullableFilter<"bank_accounts"> | string | null
    account_name?: StringNullableFilter<"bank_accounts"> | string | null
    balance_available?: DecimalNullableFilter<"bank_accounts"> | Decimal | DecimalJsLike | number | string | null
    balance_current?: DecimalNullableFilter<"bank_accounts"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"bank_accounts"> | string | null
    status?: StringNullableFilter<"bank_accounts"> | string | null
    is_business_account?: BoolFilter<"bank_accounts"> | boolean
    last_synced?: DateTimeNullableFilter<"bank_accounts"> | Date | string | null
    created_at?: DateTimeFilter<"bank_accounts"> | Date | string
    updated_at?: DateTimeFilter<"bank_accounts"> | Date | string
    basiq_user?: XOR<Basiq_usersScalarRelationFilter, basiq_usersWhereInput>
    connection?: XOR<Bank_connectionsScalarRelationFilter, bank_connectionsWhereInput>
    bank_transactions?: Bank_transactionsListRelationFilter
  }

  export type bank_accountsOrderByWithRelationInput = {
    id?: SortOrder
    basiq_user_id?: SortOrder
    connection_id?: SortOrder
    basiq_account_id?: SortOrder
    account_holder?: SortOrderInput | SortOrder
    account_number?: SortOrderInput | SortOrder
    bsb?: SortOrderInput | SortOrder
    institution_name?: SortOrderInput | SortOrder
    account_type?: SortOrderInput | SortOrder
    account_name?: SortOrderInput | SortOrder
    balance_available?: SortOrderInput | SortOrder
    balance_current?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    is_business_account?: SortOrder
    last_synced?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    basiq_user?: basiq_usersOrderByWithRelationInput
    connection?: bank_connectionsOrderByWithRelationInput
    bank_transactions?: bank_transactionsOrderByRelationAggregateInput
  }

  export type bank_accountsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    basiq_account_id?: string
    AND?: bank_accountsWhereInput | bank_accountsWhereInput[]
    OR?: bank_accountsWhereInput[]
    NOT?: bank_accountsWhereInput | bank_accountsWhereInput[]
    basiq_user_id?: UuidFilter<"bank_accounts"> | string
    connection_id?: UuidFilter<"bank_accounts"> | string
    account_holder?: StringNullableFilter<"bank_accounts"> | string | null
    account_number?: StringNullableFilter<"bank_accounts"> | string | null
    bsb?: StringNullableFilter<"bank_accounts"> | string | null
    institution_name?: StringNullableFilter<"bank_accounts"> | string | null
    account_type?: StringNullableFilter<"bank_accounts"> | string | null
    account_name?: StringNullableFilter<"bank_accounts"> | string | null
    balance_available?: DecimalNullableFilter<"bank_accounts"> | Decimal | DecimalJsLike | number | string | null
    balance_current?: DecimalNullableFilter<"bank_accounts"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"bank_accounts"> | string | null
    status?: StringNullableFilter<"bank_accounts"> | string | null
    is_business_account?: BoolFilter<"bank_accounts"> | boolean
    last_synced?: DateTimeNullableFilter<"bank_accounts"> | Date | string | null
    created_at?: DateTimeFilter<"bank_accounts"> | Date | string
    updated_at?: DateTimeFilter<"bank_accounts"> | Date | string
    basiq_user?: XOR<Basiq_usersScalarRelationFilter, basiq_usersWhereInput>
    connection?: XOR<Bank_connectionsScalarRelationFilter, bank_connectionsWhereInput>
    bank_transactions?: Bank_transactionsListRelationFilter
  }, "id" | "basiq_account_id">

  export type bank_accountsOrderByWithAggregationInput = {
    id?: SortOrder
    basiq_user_id?: SortOrder
    connection_id?: SortOrder
    basiq_account_id?: SortOrder
    account_holder?: SortOrderInput | SortOrder
    account_number?: SortOrderInput | SortOrder
    bsb?: SortOrderInput | SortOrder
    institution_name?: SortOrderInput | SortOrder
    account_type?: SortOrderInput | SortOrder
    account_name?: SortOrderInput | SortOrder
    balance_available?: SortOrderInput | SortOrder
    balance_current?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    is_business_account?: SortOrder
    last_synced?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: bank_accountsCountOrderByAggregateInput
    _avg?: bank_accountsAvgOrderByAggregateInput
    _max?: bank_accountsMaxOrderByAggregateInput
    _min?: bank_accountsMinOrderByAggregateInput
    _sum?: bank_accountsSumOrderByAggregateInput
  }

  export type bank_accountsScalarWhereWithAggregatesInput = {
    AND?: bank_accountsScalarWhereWithAggregatesInput | bank_accountsScalarWhereWithAggregatesInput[]
    OR?: bank_accountsScalarWhereWithAggregatesInput[]
    NOT?: bank_accountsScalarWhereWithAggregatesInput | bank_accountsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"bank_accounts"> | string
    basiq_user_id?: UuidWithAggregatesFilter<"bank_accounts"> | string
    connection_id?: UuidWithAggregatesFilter<"bank_accounts"> | string
    basiq_account_id?: StringWithAggregatesFilter<"bank_accounts"> | string
    account_holder?: StringNullableWithAggregatesFilter<"bank_accounts"> | string | null
    account_number?: StringNullableWithAggregatesFilter<"bank_accounts"> | string | null
    bsb?: StringNullableWithAggregatesFilter<"bank_accounts"> | string | null
    institution_name?: StringNullableWithAggregatesFilter<"bank_accounts"> | string | null
    account_type?: StringNullableWithAggregatesFilter<"bank_accounts"> | string | null
    account_name?: StringNullableWithAggregatesFilter<"bank_accounts"> | string | null
    balance_available?: DecimalNullableWithAggregatesFilter<"bank_accounts"> | Decimal | DecimalJsLike | number | string | null
    balance_current?: DecimalNullableWithAggregatesFilter<"bank_accounts"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableWithAggregatesFilter<"bank_accounts"> | string | null
    status?: StringNullableWithAggregatesFilter<"bank_accounts"> | string | null
    is_business_account?: BoolWithAggregatesFilter<"bank_accounts"> | boolean
    last_synced?: DateTimeNullableWithAggregatesFilter<"bank_accounts"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"bank_accounts"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"bank_accounts"> | Date | string
  }

  export type bank_transactionsWhereInput = {
    AND?: bank_transactionsWhereInput | bank_transactionsWhereInput[]
    OR?: bank_transactionsWhereInput[]
    NOT?: bank_transactionsWhereInput | bank_transactionsWhereInput[]
    id?: UuidFilter<"bank_transactions"> | string
    bank_account_id?: UuidFilter<"bank_transactions"> | string
    basiq_transaction_id?: StringFilter<"bank_transactions"> | string
    description?: StringNullableFilter<"bank_transactions"> | string | null
    amount?: DecimalFilter<"bank_transactions"> | Decimal | DecimalJsLike | number | string
    transaction_date?: DateTimeFilter<"bank_transactions"> | Date | string
    post_date?: DateTimeNullableFilter<"bank_transactions"> | Date | string | null
    balance?: DecimalNullableFilter<"bank_transactions"> | Decimal | DecimalJsLike | number | string | null
    transaction_type?: StringNullableFilter<"bank_transactions"> | string | null
    direction?: StringNullableFilter<"bank_transactions"> | string | null
    category?: StringNullableFilter<"bank_transactions"> | string | null
    subcategory?: StringNullableFilter<"bank_transactions"> | string | null
    merchant_name?: StringNullableFilter<"bank_transactions"> | string | null
    status?: StringNullableFilter<"bank_transactions"> | string | null
    is_business_expense?: BoolFilter<"bank_transactions"> | boolean
    tax_category?: StringNullableFilter<"bank_transactions"> | string | null
    gst_amount?: DecimalNullableFilter<"bank_transactions"> | Decimal | DecimalJsLike | number | string | null
    receipt_id?: UuidNullableFilter<"bank_transactions"> | string | null
    notes?: StringNullableFilter<"bank_transactions"> | string | null
    created_at?: DateTimeFilter<"bank_transactions"> | Date | string
    updated_at?: DateTimeFilter<"bank_transactions"> | Date | string
    bank_account?: XOR<Bank_accountsScalarRelationFilter, bank_accountsWhereInput>
  }

  export type bank_transactionsOrderByWithRelationInput = {
    id?: SortOrder
    bank_account_id?: SortOrder
    basiq_transaction_id?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    transaction_date?: SortOrder
    post_date?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    transaction_type?: SortOrderInput | SortOrder
    direction?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    subcategory?: SortOrderInput | SortOrder
    merchant_name?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    is_business_expense?: SortOrder
    tax_category?: SortOrderInput | SortOrder
    gst_amount?: SortOrderInput | SortOrder
    receipt_id?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    bank_account?: bank_accountsOrderByWithRelationInput
  }

  export type bank_transactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    basiq_transaction_id?: string
    AND?: bank_transactionsWhereInput | bank_transactionsWhereInput[]
    OR?: bank_transactionsWhereInput[]
    NOT?: bank_transactionsWhereInput | bank_transactionsWhereInput[]
    bank_account_id?: UuidFilter<"bank_transactions"> | string
    description?: StringNullableFilter<"bank_transactions"> | string | null
    amount?: DecimalFilter<"bank_transactions"> | Decimal | DecimalJsLike | number | string
    transaction_date?: DateTimeFilter<"bank_transactions"> | Date | string
    post_date?: DateTimeNullableFilter<"bank_transactions"> | Date | string | null
    balance?: DecimalNullableFilter<"bank_transactions"> | Decimal | DecimalJsLike | number | string | null
    transaction_type?: StringNullableFilter<"bank_transactions"> | string | null
    direction?: StringNullableFilter<"bank_transactions"> | string | null
    category?: StringNullableFilter<"bank_transactions"> | string | null
    subcategory?: StringNullableFilter<"bank_transactions"> | string | null
    merchant_name?: StringNullableFilter<"bank_transactions"> | string | null
    status?: StringNullableFilter<"bank_transactions"> | string | null
    is_business_expense?: BoolFilter<"bank_transactions"> | boolean
    tax_category?: StringNullableFilter<"bank_transactions"> | string | null
    gst_amount?: DecimalNullableFilter<"bank_transactions"> | Decimal | DecimalJsLike | number | string | null
    receipt_id?: UuidNullableFilter<"bank_transactions"> | string | null
    notes?: StringNullableFilter<"bank_transactions"> | string | null
    created_at?: DateTimeFilter<"bank_transactions"> | Date | string
    updated_at?: DateTimeFilter<"bank_transactions"> | Date | string
    bank_account?: XOR<Bank_accountsScalarRelationFilter, bank_accountsWhereInput>
  }, "id" | "basiq_transaction_id">

  export type bank_transactionsOrderByWithAggregationInput = {
    id?: SortOrder
    bank_account_id?: SortOrder
    basiq_transaction_id?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    transaction_date?: SortOrder
    post_date?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    transaction_type?: SortOrderInput | SortOrder
    direction?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    subcategory?: SortOrderInput | SortOrder
    merchant_name?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    is_business_expense?: SortOrder
    tax_category?: SortOrderInput | SortOrder
    gst_amount?: SortOrderInput | SortOrder
    receipt_id?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: bank_transactionsCountOrderByAggregateInput
    _avg?: bank_transactionsAvgOrderByAggregateInput
    _max?: bank_transactionsMaxOrderByAggregateInput
    _min?: bank_transactionsMinOrderByAggregateInput
    _sum?: bank_transactionsSumOrderByAggregateInput
  }

  export type bank_transactionsScalarWhereWithAggregatesInput = {
    AND?: bank_transactionsScalarWhereWithAggregatesInput | bank_transactionsScalarWhereWithAggregatesInput[]
    OR?: bank_transactionsScalarWhereWithAggregatesInput[]
    NOT?: bank_transactionsScalarWhereWithAggregatesInput | bank_transactionsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"bank_transactions"> | string
    bank_account_id?: UuidWithAggregatesFilter<"bank_transactions"> | string
    basiq_transaction_id?: StringWithAggregatesFilter<"bank_transactions"> | string
    description?: StringNullableWithAggregatesFilter<"bank_transactions"> | string | null
    amount?: DecimalWithAggregatesFilter<"bank_transactions"> | Decimal | DecimalJsLike | number | string
    transaction_date?: DateTimeWithAggregatesFilter<"bank_transactions"> | Date | string
    post_date?: DateTimeNullableWithAggregatesFilter<"bank_transactions"> | Date | string | null
    balance?: DecimalNullableWithAggregatesFilter<"bank_transactions"> | Decimal | DecimalJsLike | number | string | null
    transaction_type?: StringNullableWithAggregatesFilter<"bank_transactions"> | string | null
    direction?: StringNullableWithAggregatesFilter<"bank_transactions"> | string | null
    category?: StringNullableWithAggregatesFilter<"bank_transactions"> | string | null
    subcategory?: StringNullableWithAggregatesFilter<"bank_transactions"> | string | null
    merchant_name?: StringNullableWithAggregatesFilter<"bank_transactions"> | string | null
    status?: StringNullableWithAggregatesFilter<"bank_transactions"> | string | null
    is_business_expense?: BoolWithAggregatesFilter<"bank_transactions"> | boolean
    tax_category?: StringNullableWithAggregatesFilter<"bank_transactions"> | string | null
    gst_amount?: DecimalNullableWithAggregatesFilter<"bank_transactions"> | Decimal | DecimalJsLike | number | string | null
    receipt_id?: UuidNullableWithAggregatesFilter<"bank_transactions"> | string | null
    notes?: StringNullableWithAggregatesFilter<"bank_transactions"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"bank_transactions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"bank_transactions"> | Date | string
  }

  export type basiq_webhooksWhereInput = {
    AND?: basiq_webhooksWhereInput | basiq_webhooksWhereInput[]
    OR?: basiq_webhooksWhereInput[]
    NOT?: basiq_webhooksWhereInput | basiq_webhooksWhereInput[]
    id?: UuidFilter<"basiq_webhooks"> | string
    webhook_id?: StringNullableFilter<"basiq_webhooks"> | string | null
    event_type?: StringFilter<"basiq_webhooks"> | string
    resource_type?: StringNullableFilter<"basiq_webhooks"> | string | null
    resource_id?: StringNullableFilter<"basiq_webhooks"> | string | null
    payload?: JsonFilter<"basiq_webhooks">
    status?: StringNullableFilter<"basiq_webhooks"> | string | null
    processed_at?: DateTimeNullableFilter<"basiq_webhooks"> | Date | string | null
    error_message?: StringNullableFilter<"basiq_webhooks"> | string | null
    retry_count?: IntFilter<"basiq_webhooks"> | number
    created_at?: DateTimeFilter<"basiq_webhooks"> | Date | string
  }

  export type basiq_webhooksOrderByWithRelationInput = {
    id?: SortOrder
    webhook_id?: SortOrderInput | SortOrder
    event_type?: SortOrder
    resource_type?: SortOrderInput | SortOrder
    resource_id?: SortOrderInput | SortOrder
    payload?: SortOrder
    status?: SortOrderInput | SortOrder
    processed_at?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    retry_count?: SortOrder
    created_at?: SortOrder
  }

  export type basiq_webhooksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    webhook_id?: string
    AND?: basiq_webhooksWhereInput | basiq_webhooksWhereInput[]
    OR?: basiq_webhooksWhereInput[]
    NOT?: basiq_webhooksWhereInput | basiq_webhooksWhereInput[]
    event_type?: StringFilter<"basiq_webhooks"> | string
    resource_type?: StringNullableFilter<"basiq_webhooks"> | string | null
    resource_id?: StringNullableFilter<"basiq_webhooks"> | string | null
    payload?: JsonFilter<"basiq_webhooks">
    status?: StringNullableFilter<"basiq_webhooks"> | string | null
    processed_at?: DateTimeNullableFilter<"basiq_webhooks"> | Date | string | null
    error_message?: StringNullableFilter<"basiq_webhooks"> | string | null
    retry_count?: IntFilter<"basiq_webhooks"> | number
    created_at?: DateTimeFilter<"basiq_webhooks"> | Date | string
  }, "id" | "webhook_id">

  export type basiq_webhooksOrderByWithAggregationInput = {
    id?: SortOrder
    webhook_id?: SortOrderInput | SortOrder
    event_type?: SortOrder
    resource_type?: SortOrderInput | SortOrder
    resource_id?: SortOrderInput | SortOrder
    payload?: SortOrder
    status?: SortOrderInput | SortOrder
    processed_at?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    retry_count?: SortOrder
    created_at?: SortOrder
    _count?: basiq_webhooksCountOrderByAggregateInput
    _avg?: basiq_webhooksAvgOrderByAggregateInput
    _max?: basiq_webhooksMaxOrderByAggregateInput
    _min?: basiq_webhooksMinOrderByAggregateInput
    _sum?: basiq_webhooksSumOrderByAggregateInput
  }

  export type basiq_webhooksScalarWhereWithAggregatesInput = {
    AND?: basiq_webhooksScalarWhereWithAggregatesInput | basiq_webhooksScalarWhereWithAggregatesInput[]
    OR?: basiq_webhooksScalarWhereWithAggregatesInput[]
    NOT?: basiq_webhooksScalarWhereWithAggregatesInput | basiq_webhooksScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"basiq_webhooks"> | string
    webhook_id?: StringNullableWithAggregatesFilter<"basiq_webhooks"> | string | null
    event_type?: StringWithAggregatesFilter<"basiq_webhooks"> | string
    resource_type?: StringNullableWithAggregatesFilter<"basiq_webhooks"> | string | null
    resource_id?: StringNullableWithAggregatesFilter<"basiq_webhooks"> | string | null
    payload?: JsonWithAggregatesFilter<"basiq_webhooks">
    status?: StringNullableWithAggregatesFilter<"basiq_webhooks"> | string | null
    processed_at?: DateTimeNullableWithAggregatesFilter<"basiq_webhooks"> | Date | string | null
    error_message?: StringNullableWithAggregatesFilter<"basiq_webhooks"> | string | null
    retry_count?: IntWithAggregatesFilter<"basiq_webhooks"> | number
    created_at?: DateTimeWithAggregatesFilter<"basiq_webhooks"> | Date | string
  }

  export type basiq_api_logsWhereInput = {
    AND?: basiq_api_logsWhereInput | basiq_api_logsWhereInput[]
    OR?: basiq_api_logsWhereInput[]
    NOT?: basiq_api_logsWhereInput | basiq_api_logsWhereInput[]
    id?: UuidFilter<"basiq_api_logs"> | string
    user_id?: StringNullableFilter<"basiq_api_logs"> | string | null
    endpoint?: StringFilter<"basiq_api_logs"> | string
    method?: StringFilter<"basiq_api_logs"> | string
    request_body?: JsonNullableFilter<"basiq_api_logs">
    response_status?: IntNullableFilter<"basiq_api_logs"> | number | null
    response_body?: JsonNullableFilter<"basiq_api_logs">
    error_message?: StringNullableFilter<"basiq_api_logs"> | string | null
    duration_ms?: IntNullableFilter<"basiq_api_logs"> | number | null
    created_at?: DateTimeFilter<"basiq_api_logs"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type basiq_api_logsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    request_body?: SortOrderInput | SortOrder
    response_status?: SortOrderInput | SortOrder
    response_body?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    duration_ms?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type basiq_api_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: basiq_api_logsWhereInput | basiq_api_logsWhereInput[]
    OR?: basiq_api_logsWhereInput[]
    NOT?: basiq_api_logsWhereInput | basiq_api_logsWhereInput[]
    user_id?: StringNullableFilter<"basiq_api_logs"> | string | null
    endpoint?: StringFilter<"basiq_api_logs"> | string
    method?: StringFilter<"basiq_api_logs"> | string
    request_body?: JsonNullableFilter<"basiq_api_logs">
    response_status?: IntNullableFilter<"basiq_api_logs"> | number | null
    response_body?: JsonNullableFilter<"basiq_api_logs">
    error_message?: StringNullableFilter<"basiq_api_logs"> | string | null
    duration_ms?: IntNullableFilter<"basiq_api_logs"> | number | null
    created_at?: DateTimeFilter<"basiq_api_logs"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type basiq_api_logsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    request_body?: SortOrderInput | SortOrder
    response_status?: SortOrderInput | SortOrder
    response_body?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    duration_ms?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: basiq_api_logsCountOrderByAggregateInput
    _avg?: basiq_api_logsAvgOrderByAggregateInput
    _max?: basiq_api_logsMaxOrderByAggregateInput
    _min?: basiq_api_logsMinOrderByAggregateInput
    _sum?: basiq_api_logsSumOrderByAggregateInput
  }

  export type basiq_api_logsScalarWhereWithAggregatesInput = {
    AND?: basiq_api_logsScalarWhereWithAggregatesInput | basiq_api_logsScalarWhereWithAggregatesInput[]
    OR?: basiq_api_logsScalarWhereWithAggregatesInput[]
    NOT?: basiq_api_logsScalarWhereWithAggregatesInput | basiq_api_logsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"basiq_api_logs"> | string
    user_id?: StringNullableWithAggregatesFilter<"basiq_api_logs"> | string | null
    endpoint?: StringWithAggregatesFilter<"basiq_api_logs"> | string
    method?: StringWithAggregatesFilter<"basiq_api_logs"> | string
    request_body?: JsonNullableWithAggregatesFilter<"basiq_api_logs">
    response_status?: IntNullableWithAggregatesFilter<"basiq_api_logs"> | number | null
    response_body?: JsonNullableWithAggregatesFilter<"basiq_api_logs">
    error_message?: StringNullableWithAggregatesFilter<"basiq_api_logs"> | string | null
    duration_ms?: IntNullableWithAggregatesFilter<"basiq_api_logs"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"basiq_api_logs"> | Date | string
  }

  export type ReceiptWhereInput = {
    AND?: ReceiptWhereInput | ReceiptWhereInput[]
    OR?: ReceiptWhereInput[]
    NOT?: ReceiptWhereInput | ReceiptWhereInput[]
    id?: StringFilter<"Receipt"> | string
    userId?: StringFilter<"Receipt"> | string
    merchant?: StringNullableFilter<"Receipt"> | string | null
    totalAmount?: DecimalFilter<"Receipt"> | Decimal | DecimalJsLike | number | string
    gstAmount?: DecimalNullableFilter<"Receipt"> | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFilter<"Receipt"> | Date | string
    items?: JsonNullableFilter<"Receipt">
    imageUrl?: StringNullableFilter<"Receipt"> | string | null
    aiProcessed?: BoolFilter<"Receipt"> | boolean
    aiConfidence?: DecimalNullableFilter<"Receipt"> | Decimal | DecimalJsLike | number | string | null
    aiProvider?: StringNullableFilter<"Receipt"> | string | null
    aiModel?: StringNullableFilter<"Receipt"> | string | null
    processingStatus?: EnumReceiptStatusFilter<"Receipt"> | $Enums.ReceiptStatus
    abn?: StringNullableFilter<"Receipt"> | string | null
    taxInvoiceNumber?: StringNullableFilter<"Receipt"> | string | null
    taxCategory?: StringNullableFilter<"Receipt"> | string | null
    isGstRegistered?: BoolFilter<"Receipt"> | boolean
    matchedTransactionId?: StringNullableFilter<"Receipt"> | string | null
    matchConfidence?: DecimalNullableFilter<"Receipt"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Receipt"> | Date | string
    updatedAt?: DateTimeFilter<"Receipt"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReceiptOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    merchant?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    gstAmount?: SortOrderInput | SortOrder
    date?: SortOrder
    items?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    aiProcessed?: SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    aiProvider?: SortOrderInput | SortOrder
    aiModel?: SortOrderInput | SortOrder
    processingStatus?: SortOrder
    abn?: SortOrderInput | SortOrder
    taxInvoiceNumber?: SortOrderInput | SortOrder
    taxCategory?: SortOrderInput | SortOrder
    isGstRegistered?: SortOrder
    matchedTransactionId?: SortOrderInput | SortOrder
    matchConfidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ReceiptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReceiptWhereInput | ReceiptWhereInput[]
    OR?: ReceiptWhereInput[]
    NOT?: ReceiptWhereInput | ReceiptWhereInput[]
    userId?: StringFilter<"Receipt"> | string
    merchant?: StringNullableFilter<"Receipt"> | string | null
    totalAmount?: DecimalFilter<"Receipt"> | Decimal | DecimalJsLike | number | string
    gstAmount?: DecimalNullableFilter<"Receipt"> | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFilter<"Receipt"> | Date | string
    items?: JsonNullableFilter<"Receipt">
    imageUrl?: StringNullableFilter<"Receipt"> | string | null
    aiProcessed?: BoolFilter<"Receipt"> | boolean
    aiConfidence?: DecimalNullableFilter<"Receipt"> | Decimal | DecimalJsLike | number | string | null
    aiProvider?: StringNullableFilter<"Receipt"> | string | null
    aiModel?: StringNullableFilter<"Receipt"> | string | null
    processingStatus?: EnumReceiptStatusFilter<"Receipt"> | $Enums.ReceiptStatus
    abn?: StringNullableFilter<"Receipt"> | string | null
    taxInvoiceNumber?: StringNullableFilter<"Receipt"> | string | null
    taxCategory?: StringNullableFilter<"Receipt"> | string | null
    isGstRegistered?: BoolFilter<"Receipt"> | boolean
    matchedTransactionId?: StringNullableFilter<"Receipt"> | string | null
    matchConfidence?: DecimalNullableFilter<"Receipt"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Receipt"> | Date | string
    updatedAt?: DateTimeFilter<"Receipt"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    merchant?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    gstAmount?: SortOrderInput | SortOrder
    date?: SortOrder
    items?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    aiProcessed?: SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    aiProvider?: SortOrderInput | SortOrder
    aiModel?: SortOrderInput | SortOrder
    processingStatus?: SortOrder
    abn?: SortOrderInput | SortOrder
    taxInvoiceNumber?: SortOrderInput | SortOrder
    taxCategory?: SortOrderInput | SortOrder
    isGstRegistered?: SortOrder
    matchedTransactionId?: SortOrderInput | SortOrder
    matchConfidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReceiptCountOrderByAggregateInput
    _avg?: ReceiptAvgOrderByAggregateInput
    _max?: ReceiptMaxOrderByAggregateInput
    _min?: ReceiptMinOrderByAggregateInput
    _sum?: ReceiptSumOrderByAggregateInput
  }

  export type ReceiptScalarWhereWithAggregatesInput = {
    AND?: ReceiptScalarWhereWithAggregatesInput | ReceiptScalarWhereWithAggregatesInput[]
    OR?: ReceiptScalarWhereWithAggregatesInput[]
    NOT?: ReceiptScalarWhereWithAggregatesInput | ReceiptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Receipt"> | string
    userId?: StringWithAggregatesFilter<"Receipt"> | string
    merchant?: StringNullableWithAggregatesFilter<"Receipt"> | string | null
    totalAmount?: DecimalWithAggregatesFilter<"Receipt"> | Decimal | DecimalJsLike | number | string
    gstAmount?: DecimalNullableWithAggregatesFilter<"Receipt"> | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeWithAggregatesFilter<"Receipt"> | Date | string
    items?: JsonNullableWithAggregatesFilter<"Receipt">
    imageUrl?: StringNullableWithAggregatesFilter<"Receipt"> | string | null
    aiProcessed?: BoolWithAggregatesFilter<"Receipt"> | boolean
    aiConfidence?: DecimalNullableWithAggregatesFilter<"Receipt"> | Decimal | DecimalJsLike | number | string | null
    aiProvider?: StringNullableWithAggregatesFilter<"Receipt"> | string | null
    aiModel?: StringNullableWithAggregatesFilter<"Receipt"> | string | null
    processingStatus?: EnumReceiptStatusWithAggregatesFilter<"Receipt"> | $Enums.ReceiptStatus
    abn?: StringNullableWithAggregatesFilter<"Receipt"> | string | null
    taxInvoiceNumber?: StringNullableWithAggregatesFilter<"Receipt"> | string | null
    taxCategory?: StringNullableWithAggregatesFilter<"Receipt"> | string | null
    isGstRegistered?: BoolWithAggregatesFilter<"Receipt"> | boolean
    matchedTransactionId?: StringNullableWithAggregatesFilter<"Receipt"> | string | null
    matchConfidence?: DecimalNullableWithAggregatesFilter<"Receipt"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Receipt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Receipt"> | Date | string
  }

  export type BudgetWhereInput = {
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    id?: StringFilter<"Budget"> | string
    userId?: StringFilter<"Budget"> | string
    name?: StringNullableFilter<"Budget"> | string | null
    monthlyBudget?: DecimalFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    targetSavings?: DecimalNullableFilter<"Budget"> | Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: DecimalNullableFilter<"Budget"> | Decimal | DecimalJsLike | number | string | null
    predictions?: JsonNullableFilter<"Budget">
    categoryLimits?: JsonNullableFilter<"Budget">
    confidenceScore?: DecimalNullableFilter<"Budget"> | Decimal | DecimalJsLike | number | string | null
    aiProvider?: StringNullableFilter<"Budget"> | string | null
    aiModel?: StringNullableFilter<"Budget"> | string | null
    analysisPeriod?: StringNullableFilter<"Budget"> | string | null
    predictionPeriod?: StringNullableFilter<"Budget"> | string | null
    status?: EnumBudgetStatusFilter<"Budget"> | $Enums.BudgetStatus
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    budgetTracking?: BudgetTrackingListRelationFilter
  }

  export type BudgetOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrderInput | SortOrder
    monthlyBudget?: SortOrder
    targetSavings?: SortOrderInput | SortOrder
    monthlyIncome?: SortOrderInput | SortOrder
    predictions?: SortOrderInput | SortOrder
    categoryLimits?: SortOrderInput | SortOrder
    confidenceScore?: SortOrderInput | SortOrder
    aiProvider?: SortOrderInput | SortOrder
    aiModel?: SortOrderInput | SortOrder
    analysisPeriod?: SortOrderInput | SortOrder
    predictionPeriod?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    budgetTracking?: BudgetTrackingOrderByRelationAggregateInput
  }

  export type BudgetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    userId?: StringFilter<"Budget"> | string
    name?: StringNullableFilter<"Budget"> | string | null
    monthlyBudget?: DecimalFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    targetSavings?: DecimalNullableFilter<"Budget"> | Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: DecimalNullableFilter<"Budget"> | Decimal | DecimalJsLike | number | string | null
    predictions?: JsonNullableFilter<"Budget">
    categoryLimits?: JsonNullableFilter<"Budget">
    confidenceScore?: DecimalNullableFilter<"Budget"> | Decimal | DecimalJsLike | number | string | null
    aiProvider?: StringNullableFilter<"Budget"> | string | null
    aiModel?: StringNullableFilter<"Budget"> | string | null
    analysisPeriod?: StringNullableFilter<"Budget"> | string | null
    predictionPeriod?: StringNullableFilter<"Budget"> | string | null
    status?: EnumBudgetStatusFilter<"Budget"> | $Enums.BudgetStatus
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    budgetTracking?: BudgetTrackingListRelationFilter
  }, "id">

  export type BudgetOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrderInput | SortOrder
    monthlyBudget?: SortOrder
    targetSavings?: SortOrderInput | SortOrder
    monthlyIncome?: SortOrderInput | SortOrder
    predictions?: SortOrderInput | SortOrder
    categoryLimits?: SortOrderInput | SortOrder
    confidenceScore?: SortOrderInput | SortOrder
    aiProvider?: SortOrderInput | SortOrder
    aiModel?: SortOrderInput | SortOrder
    analysisPeriod?: SortOrderInput | SortOrder
    predictionPeriod?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BudgetCountOrderByAggregateInput
    _avg?: BudgetAvgOrderByAggregateInput
    _max?: BudgetMaxOrderByAggregateInput
    _min?: BudgetMinOrderByAggregateInput
    _sum?: BudgetSumOrderByAggregateInput
  }

  export type BudgetScalarWhereWithAggregatesInput = {
    AND?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    OR?: BudgetScalarWhereWithAggregatesInput[]
    NOT?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Budget"> | string
    userId?: StringWithAggregatesFilter<"Budget"> | string
    name?: StringNullableWithAggregatesFilter<"Budget"> | string | null
    monthlyBudget?: DecimalWithAggregatesFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    targetSavings?: DecimalNullableWithAggregatesFilter<"Budget"> | Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: DecimalNullableWithAggregatesFilter<"Budget"> | Decimal | DecimalJsLike | number | string | null
    predictions?: JsonNullableWithAggregatesFilter<"Budget">
    categoryLimits?: JsonNullableWithAggregatesFilter<"Budget">
    confidenceScore?: DecimalNullableWithAggregatesFilter<"Budget"> | Decimal | DecimalJsLike | number | string | null
    aiProvider?: StringNullableWithAggregatesFilter<"Budget"> | string | null
    aiModel?: StringNullableWithAggregatesFilter<"Budget"> | string | null
    analysisPeriod?: StringNullableWithAggregatesFilter<"Budget"> | string | null
    predictionPeriod?: StringNullableWithAggregatesFilter<"Budget"> | string | null
    status?: EnumBudgetStatusWithAggregatesFilter<"Budget"> | $Enums.BudgetStatus
    createdAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
  }

  export type BudgetTrackingWhereInput = {
    AND?: BudgetTrackingWhereInput | BudgetTrackingWhereInput[]
    OR?: BudgetTrackingWhereInput[]
    NOT?: BudgetTrackingWhereInput | BudgetTrackingWhereInput[]
    id?: StringFilter<"BudgetTracking"> | string
    budgetId?: StringFilter<"BudgetTracking"> | string
    userId?: StringFilter<"BudgetTracking"> | string
    month?: IntFilter<"BudgetTracking"> | number
    year?: IntFilter<"BudgetTracking"> | number
    predictedAmount?: DecimalFilter<"BudgetTracking"> | Decimal | DecimalJsLike | number | string
    actualAmount?: DecimalNullableFilter<"BudgetTracking"> | Decimal | DecimalJsLike | number | string | null
    variance?: DecimalNullableFilter<"BudgetTracking"> | Decimal | DecimalJsLike | number | string | null
    category?: StringNullableFilter<"BudgetTracking"> | string | null
    createdAt?: DateTimeFilter<"BudgetTracking"> | Date | string
    budget?: XOR<BudgetScalarRelationFilter, BudgetWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BudgetTrackingOrderByWithRelationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    predictedAmount?: SortOrder
    actualAmount?: SortOrderInput | SortOrder
    variance?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    budget?: BudgetOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BudgetTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BudgetTrackingWhereInput | BudgetTrackingWhereInput[]
    OR?: BudgetTrackingWhereInput[]
    NOT?: BudgetTrackingWhereInput | BudgetTrackingWhereInput[]
    budgetId?: StringFilter<"BudgetTracking"> | string
    userId?: StringFilter<"BudgetTracking"> | string
    month?: IntFilter<"BudgetTracking"> | number
    year?: IntFilter<"BudgetTracking"> | number
    predictedAmount?: DecimalFilter<"BudgetTracking"> | Decimal | DecimalJsLike | number | string
    actualAmount?: DecimalNullableFilter<"BudgetTracking"> | Decimal | DecimalJsLike | number | string | null
    variance?: DecimalNullableFilter<"BudgetTracking"> | Decimal | DecimalJsLike | number | string | null
    category?: StringNullableFilter<"BudgetTracking"> | string | null
    createdAt?: DateTimeFilter<"BudgetTracking"> | Date | string
    budget?: XOR<BudgetScalarRelationFilter, BudgetWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type BudgetTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    predictedAmount?: SortOrder
    actualAmount?: SortOrderInput | SortOrder
    variance?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BudgetTrackingCountOrderByAggregateInput
    _avg?: BudgetTrackingAvgOrderByAggregateInput
    _max?: BudgetTrackingMaxOrderByAggregateInput
    _min?: BudgetTrackingMinOrderByAggregateInput
    _sum?: BudgetTrackingSumOrderByAggregateInput
  }

  export type BudgetTrackingScalarWhereWithAggregatesInput = {
    AND?: BudgetTrackingScalarWhereWithAggregatesInput | BudgetTrackingScalarWhereWithAggregatesInput[]
    OR?: BudgetTrackingScalarWhereWithAggregatesInput[]
    NOT?: BudgetTrackingScalarWhereWithAggregatesInput | BudgetTrackingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BudgetTracking"> | string
    budgetId?: StringWithAggregatesFilter<"BudgetTracking"> | string
    userId?: StringWithAggregatesFilter<"BudgetTracking"> | string
    month?: IntWithAggregatesFilter<"BudgetTracking"> | number
    year?: IntWithAggregatesFilter<"BudgetTracking"> | number
    predictedAmount?: DecimalWithAggregatesFilter<"BudgetTracking"> | Decimal | DecimalJsLike | number | string
    actualAmount?: DecimalNullableWithAggregatesFilter<"BudgetTracking"> | Decimal | DecimalJsLike | number | string | null
    variance?: DecimalNullableWithAggregatesFilter<"BudgetTracking"> | Decimal | DecimalJsLike | number | string | null
    category?: StringNullableWithAggregatesFilter<"BudgetTracking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BudgetTracking"> | Date | string
  }

  export type FinancialInsightWhereInput = {
    AND?: FinancialInsightWhereInput | FinancialInsightWhereInput[]
    OR?: FinancialInsightWhereInput[]
    NOT?: FinancialInsightWhereInput | FinancialInsightWhereInput[]
    id?: StringFilter<"FinancialInsight"> | string
    userId?: StringFilter<"FinancialInsight"> | string
    insightType?: StringFilter<"FinancialInsight"> | string
    category?: StringNullableFilter<"FinancialInsight"> | string | null
    content?: JsonNullableFilter<"FinancialInsight">
    confidenceScore?: DecimalNullableFilter<"FinancialInsight"> | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: StringNullableListFilter<"FinancialInsight">
    provider?: StringNullableFilter<"FinancialInsight"> | string | null
    model?: StringNullableFilter<"FinancialInsight"> | string | null
    title?: StringNullableFilter<"FinancialInsight"> | string | null
    description?: StringNullableFilter<"FinancialInsight"> | string | null
    recommendations?: JsonNullableFilter<"FinancialInsight">
    priority?: EnumInsightPriorityFilter<"FinancialInsight"> | $Enums.InsightPriority
    isActive?: BoolFilter<"FinancialInsight"> | boolean
    createdAt?: DateTimeFilter<"FinancialInsight"> | Date | string
    expiresAt?: DateTimeNullableFilter<"FinancialInsight"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FinancialInsightOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    category?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    confidenceScore?: SortOrderInput | SortOrder
    sourceDataIds?: SortOrder
    provider?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FinancialInsightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FinancialInsightWhereInput | FinancialInsightWhereInput[]
    OR?: FinancialInsightWhereInput[]
    NOT?: FinancialInsightWhereInput | FinancialInsightWhereInput[]
    userId?: StringFilter<"FinancialInsight"> | string
    insightType?: StringFilter<"FinancialInsight"> | string
    category?: StringNullableFilter<"FinancialInsight"> | string | null
    content?: JsonNullableFilter<"FinancialInsight">
    confidenceScore?: DecimalNullableFilter<"FinancialInsight"> | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: StringNullableListFilter<"FinancialInsight">
    provider?: StringNullableFilter<"FinancialInsight"> | string | null
    model?: StringNullableFilter<"FinancialInsight"> | string | null
    title?: StringNullableFilter<"FinancialInsight"> | string | null
    description?: StringNullableFilter<"FinancialInsight"> | string | null
    recommendations?: JsonNullableFilter<"FinancialInsight">
    priority?: EnumInsightPriorityFilter<"FinancialInsight"> | $Enums.InsightPriority
    isActive?: BoolFilter<"FinancialInsight"> | boolean
    createdAt?: DateTimeFilter<"FinancialInsight"> | Date | string
    expiresAt?: DateTimeNullableFilter<"FinancialInsight"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FinancialInsightOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    category?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    confidenceScore?: SortOrderInput | SortOrder
    sourceDataIds?: SortOrder
    provider?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: FinancialInsightCountOrderByAggregateInput
    _avg?: FinancialInsightAvgOrderByAggregateInput
    _max?: FinancialInsightMaxOrderByAggregateInput
    _min?: FinancialInsightMinOrderByAggregateInput
    _sum?: FinancialInsightSumOrderByAggregateInput
  }

  export type FinancialInsightScalarWhereWithAggregatesInput = {
    AND?: FinancialInsightScalarWhereWithAggregatesInput | FinancialInsightScalarWhereWithAggregatesInput[]
    OR?: FinancialInsightScalarWhereWithAggregatesInput[]
    NOT?: FinancialInsightScalarWhereWithAggregatesInput | FinancialInsightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FinancialInsight"> | string
    userId?: StringWithAggregatesFilter<"FinancialInsight"> | string
    insightType?: StringWithAggregatesFilter<"FinancialInsight"> | string
    category?: StringNullableWithAggregatesFilter<"FinancialInsight"> | string | null
    content?: JsonNullableWithAggregatesFilter<"FinancialInsight">
    confidenceScore?: DecimalNullableWithAggregatesFilter<"FinancialInsight"> | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: StringNullableListFilter<"FinancialInsight">
    provider?: StringNullableWithAggregatesFilter<"FinancialInsight"> | string | null
    model?: StringNullableWithAggregatesFilter<"FinancialInsight"> | string | null
    title?: StringNullableWithAggregatesFilter<"FinancialInsight"> | string | null
    description?: StringNullableWithAggregatesFilter<"FinancialInsight"> | string | null
    recommendations?: JsonNullableWithAggregatesFilter<"FinancialInsight">
    priority?: EnumInsightPriorityWithAggregatesFilter<"FinancialInsight"> | $Enums.InsightPriority
    isActive?: BoolWithAggregatesFilter<"FinancialInsight"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FinancialInsight"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"FinancialInsight"> | Date | string | null
  }

  export type GoalWhereInput = {
    AND?: GoalWhereInput | GoalWhereInput[]
    OR?: GoalWhereInput[]
    NOT?: GoalWhereInput | GoalWhereInput[]
    id?: StringFilter<"Goal"> | string
    userId?: StringFilter<"Goal"> | string
    title?: StringFilter<"Goal"> | string
    targetAmount?: DecimalFilter<"Goal"> | Decimal | DecimalJsLike | number | string
    currentAmount?: DecimalFilter<"Goal"> | Decimal | DecimalJsLike | number | string
    targetDate?: DateTimeFilter<"Goal"> | Date | string
    category?: StringNullableFilter<"Goal"> | string | null
    status?: EnumGoalStatusFilter<"Goal"> | $Enums.GoalStatus
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    updatedAt?: DateTimeFilter<"Goal"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GoalOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    targetAmount?: SortOrder
    currentAmount?: SortOrder
    targetDate?: SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type GoalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GoalWhereInput | GoalWhereInput[]
    OR?: GoalWhereInput[]
    NOT?: GoalWhereInput | GoalWhereInput[]
    userId?: StringFilter<"Goal"> | string
    title?: StringFilter<"Goal"> | string
    targetAmount?: DecimalFilter<"Goal"> | Decimal | DecimalJsLike | number | string
    currentAmount?: DecimalFilter<"Goal"> | Decimal | DecimalJsLike | number | string
    targetDate?: DateTimeFilter<"Goal"> | Date | string
    category?: StringNullableFilter<"Goal"> | string | null
    status?: EnumGoalStatusFilter<"Goal"> | $Enums.GoalStatus
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    updatedAt?: DateTimeFilter<"Goal"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type GoalOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    targetAmount?: SortOrder
    currentAmount?: SortOrder
    targetDate?: SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GoalCountOrderByAggregateInput
    _avg?: GoalAvgOrderByAggregateInput
    _max?: GoalMaxOrderByAggregateInput
    _min?: GoalMinOrderByAggregateInput
    _sum?: GoalSumOrderByAggregateInput
  }

  export type GoalScalarWhereWithAggregatesInput = {
    AND?: GoalScalarWhereWithAggregatesInput | GoalScalarWhereWithAggregatesInput[]
    OR?: GoalScalarWhereWithAggregatesInput[]
    NOT?: GoalScalarWhereWithAggregatesInput | GoalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Goal"> | string
    userId?: StringWithAggregatesFilter<"Goal"> | string
    title?: StringWithAggregatesFilter<"Goal"> | string
    targetAmount?: DecimalWithAggregatesFilter<"Goal"> | Decimal | DecimalJsLike | number | string
    currentAmount?: DecimalWithAggregatesFilter<"Goal"> | Decimal | DecimalJsLike | number | string
    targetDate?: DateTimeWithAggregatesFilter<"Goal"> | Date | string
    category?: StringNullableWithAggregatesFilter<"Goal"> | string | null
    status?: EnumGoalStatusWithAggregatesFilter<"Goal"> | $Enums.GoalStatus
    createdAt?: DateTimeWithAggregatesFilter<"Goal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Goal"> | Date | string
  }

  export type AMLTransactionMonitoringWhereInput = {
    AND?: AMLTransactionMonitoringWhereInput | AMLTransactionMonitoringWhereInput[]
    OR?: AMLTransactionMonitoringWhereInput[]
    NOT?: AMLTransactionMonitoringWhereInput | AMLTransactionMonitoringWhereInput[]
    id?: StringFilter<"AMLTransactionMonitoring"> | string
    userId?: StringFilter<"AMLTransactionMonitoring"> | string
    transactionId?: UuidNullableFilter<"AMLTransactionMonitoring"> | string | null
    monitoringType?: EnumAMLMonitoringTypeFilter<"AMLTransactionMonitoring"> | $Enums.AMLMonitoringType
    riskScore?: DecimalFilter<"AMLTransactionMonitoring"> | Decimal | DecimalJsLike | number | string
    riskFactors?: StringNullableListFilter<"AMLTransactionMonitoring">
    amount?: DecimalFilter<"AMLTransactionMonitoring"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"AMLTransactionMonitoring"> | string
    patternType?: StringNullableFilter<"AMLTransactionMonitoring"> | string | null
    patternDetails?: JsonNullableFilter<"AMLTransactionMonitoring">
    velocityScore?: DecimalNullableFilter<"AMLTransactionMonitoring"> | Decimal | DecimalJsLike | number | string | null
    requiresReview?: BoolFilter<"AMLTransactionMonitoring"> | boolean
    reviewedBy?: StringNullableFilter<"AMLTransactionMonitoring"> | string | null
    reviewedAt?: DateTimeNullableFilter<"AMLTransactionMonitoring"> | Date | string | null
    reportedToAUSTRAC?: BoolFilter<"AMLTransactionMonitoring"> | boolean
    reportReference?: StringNullableFilter<"AMLTransactionMonitoring"> | string | null
    reportedAt?: DateTimeNullableFilter<"AMLTransactionMonitoring"> | Date | string | null
    falsePositive?: BoolFilter<"AMLTransactionMonitoring"> | boolean
    notes?: StringNullableFilter<"AMLTransactionMonitoring"> | string | null
    createdAt?: DateTimeFilter<"AMLTransactionMonitoring"> | Date | string
    updatedAt?: DateTimeFilter<"AMLTransactionMonitoring"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AMLTransactionMonitoringOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    monitoringType?: SortOrder
    riskScore?: SortOrder
    riskFactors?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    patternType?: SortOrderInput | SortOrder
    patternDetails?: SortOrderInput | SortOrder
    velocityScore?: SortOrderInput | SortOrder
    requiresReview?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reportedToAUSTRAC?: SortOrder
    reportReference?: SortOrderInput | SortOrder
    reportedAt?: SortOrderInput | SortOrder
    falsePositive?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AMLTransactionMonitoringWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AMLTransactionMonitoringWhereInput | AMLTransactionMonitoringWhereInput[]
    OR?: AMLTransactionMonitoringWhereInput[]
    NOT?: AMLTransactionMonitoringWhereInput | AMLTransactionMonitoringWhereInput[]
    userId?: StringFilter<"AMLTransactionMonitoring"> | string
    transactionId?: UuidNullableFilter<"AMLTransactionMonitoring"> | string | null
    monitoringType?: EnumAMLMonitoringTypeFilter<"AMLTransactionMonitoring"> | $Enums.AMLMonitoringType
    riskScore?: DecimalFilter<"AMLTransactionMonitoring"> | Decimal | DecimalJsLike | number | string
    riskFactors?: StringNullableListFilter<"AMLTransactionMonitoring">
    amount?: DecimalFilter<"AMLTransactionMonitoring"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"AMLTransactionMonitoring"> | string
    patternType?: StringNullableFilter<"AMLTransactionMonitoring"> | string | null
    patternDetails?: JsonNullableFilter<"AMLTransactionMonitoring">
    velocityScore?: DecimalNullableFilter<"AMLTransactionMonitoring"> | Decimal | DecimalJsLike | number | string | null
    requiresReview?: BoolFilter<"AMLTransactionMonitoring"> | boolean
    reviewedBy?: StringNullableFilter<"AMLTransactionMonitoring"> | string | null
    reviewedAt?: DateTimeNullableFilter<"AMLTransactionMonitoring"> | Date | string | null
    reportedToAUSTRAC?: BoolFilter<"AMLTransactionMonitoring"> | boolean
    reportReference?: StringNullableFilter<"AMLTransactionMonitoring"> | string | null
    reportedAt?: DateTimeNullableFilter<"AMLTransactionMonitoring"> | Date | string | null
    falsePositive?: BoolFilter<"AMLTransactionMonitoring"> | boolean
    notes?: StringNullableFilter<"AMLTransactionMonitoring"> | string | null
    createdAt?: DateTimeFilter<"AMLTransactionMonitoring"> | Date | string
    updatedAt?: DateTimeFilter<"AMLTransactionMonitoring"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AMLTransactionMonitoringOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    monitoringType?: SortOrder
    riskScore?: SortOrder
    riskFactors?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    patternType?: SortOrderInput | SortOrder
    patternDetails?: SortOrderInput | SortOrder
    velocityScore?: SortOrderInput | SortOrder
    requiresReview?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reportedToAUSTRAC?: SortOrder
    reportReference?: SortOrderInput | SortOrder
    reportedAt?: SortOrderInput | SortOrder
    falsePositive?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AMLTransactionMonitoringCountOrderByAggregateInput
    _avg?: AMLTransactionMonitoringAvgOrderByAggregateInput
    _max?: AMLTransactionMonitoringMaxOrderByAggregateInput
    _min?: AMLTransactionMonitoringMinOrderByAggregateInput
    _sum?: AMLTransactionMonitoringSumOrderByAggregateInput
  }

  export type AMLTransactionMonitoringScalarWhereWithAggregatesInput = {
    AND?: AMLTransactionMonitoringScalarWhereWithAggregatesInput | AMLTransactionMonitoringScalarWhereWithAggregatesInput[]
    OR?: AMLTransactionMonitoringScalarWhereWithAggregatesInput[]
    NOT?: AMLTransactionMonitoringScalarWhereWithAggregatesInput | AMLTransactionMonitoringScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AMLTransactionMonitoring"> | string
    userId?: StringWithAggregatesFilter<"AMLTransactionMonitoring"> | string
    transactionId?: UuidNullableWithAggregatesFilter<"AMLTransactionMonitoring"> | string | null
    monitoringType?: EnumAMLMonitoringTypeWithAggregatesFilter<"AMLTransactionMonitoring"> | $Enums.AMLMonitoringType
    riskScore?: DecimalWithAggregatesFilter<"AMLTransactionMonitoring"> | Decimal | DecimalJsLike | number | string
    riskFactors?: StringNullableListFilter<"AMLTransactionMonitoring">
    amount?: DecimalWithAggregatesFilter<"AMLTransactionMonitoring"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"AMLTransactionMonitoring"> | string
    patternType?: StringNullableWithAggregatesFilter<"AMLTransactionMonitoring"> | string | null
    patternDetails?: JsonNullableWithAggregatesFilter<"AMLTransactionMonitoring">
    velocityScore?: DecimalNullableWithAggregatesFilter<"AMLTransactionMonitoring"> | Decimal | DecimalJsLike | number | string | null
    requiresReview?: BoolWithAggregatesFilter<"AMLTransactionMonitoring"> | boolean
    reviewedBy?: StringNullableWithAggregatesFilter<"AMLTransactionMonitoring"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"AMLTransactionMonitoring"> | Date | string | null
    reportedToAUSTRAC?: BoolWithAggregatesFilter<"AMLTransactionMonitoring"> | boolean
    reportReference?: StringNullableWithAggregatesFilter<"AMLTransactionMonitoring"> | string | null
    reportedAt?: DateTimeNullableWithAggregatesFilter<"AMLTransactionMonitoring"> | Date | string | null
    falsePositive?: BoolWithAggregatesFilter<"AMLTransactionMonitoring"> | boolean
    notes?: StringNullableWithAggregatesFilter<"AMLTransactionMonitoring"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AMLTransactionMonitoring"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AMLTransactionMonitoring"> | Date | string
  }

  export type PrivacyConsentWhereInput = {
    AND?: PrivacyConsentWhereInput | PrivacyConsentWhereInput[]
    OR?: PrivacyConsentWhereInput[]
    NOT?: PrivacyConsentWhereInput | PrivacyConsentWhereInput[]
    id?: StringFilter<"PrivacyConsent"> | string
    userId?: StringFilter<"PrivacyConsent"> | string
    consentType?: EnumConsentTypeFilter<"PrivacyConsent"> | $Enums.ConsentType
    consentVersion?: StringFilter<"PrivacyConsent"> | string
    consentStatus?: EnumConsentStatusFilter<"PrivacyConsent"> | $Enums.ConsentStatus
    consentDate?: DateTimeNullableFilter<"PrivacyConsent"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"PrivacyConsent"> | Date | string | null
    purposes?: StringNullableListFilter<"PrivacyConsent">
    dataCategories?: StringNullableListFilter<"PrivacyConsent">
    thirdParties?: StringNullableListFilter<"PrivacyConsent">
    withdrawnAt?: DateTimeNullableFilter<"PrivacyConsent"> | Date | string | null
    withdrawalReason?: StringNullableFilter<"PrivacyConsent"> | string | null
    legalBasis?: StringFilter<"PrivacyConsent"> | string
    jurisdiction?: StringFilter<"PrivacyConsent"> | string
    ipAddress?: StringFilter<"PrivacyConsent"> | string
    userAgent?: StringNullableFilter<"PrivacyConsent"> | string | null
    createdAt?: DateTimeFilter<"PrivacyConsent"> | Date | string
    updatedAt?: DateTimeFilter<"PrivacyConsent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PrivacyConsentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    consentVersion?: SortOrder
    consentStatus?: SortOrder
    consentDate?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    purposes?: SortOrder
    dataCategories?: SortOrder
    thirdParties?: SortOrder
    withdrawnAt?: SortOrderInput | SortOrder
    withdrawalReason?: SortOrderInput | SortOrder
    legalBasis?: SortOrder
    jurisdiction?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PrivacyConsentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_consentType_consentVersion?: PrivacyConsentUserIdConsentTypeConsentVersionCompoundUniqueInput
    AND?: PrivacyConsentWhereInput | PrivacyConsentWhereInput[]
    OR?: PrivacyConsentWhereInput[]
    NOT?: PrivacyConsentWhereInput | PrivacyConsentWhereInput[]
    userId?: StringFilter<"PrivacyConsent"> | string
    consentType?: EnumConsentTypeFilter<"PrivacyConsent"> | $Enums.ConsentType
    consentVersion?: StringFilter<"PrivacyConsent"> | string
    consentStatus?: EnumConsentStatusFilter<"PrivacyConsent"> | $Enums.ConsentStatus
    consentDate?: DateTimeNullableFilter<"PrivacyConsent"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"PrivacyConsent"> | Date | string | null
    purposes?: StringNullableListFilter<"PrivacyConsent">
    dataCategories?: StringNullableListFilter<"PrivacyConsent">
    thirdParties?: StringNullableListFilter<"PrivacyConsent">
    withdrawnAt?: DateTimeNullableFilter<"PrivacyConsent"> | Date | string | null
    withdrawalReason?: StringNullableFilter<"PrivacyConsent"> | string | null
    legalBasis?: StringFilter<"PrivacyConsent"> | string
    jurisdiction?: StringFilter<"PrivacyConsent"> | string
    ipAddress?: StringFilter<"PrivacyConsent"> | string
    userAgent?: StringNullableFilter<"PrivacyConsent"> | string | null
    createdAt?: DateTimeFilter<"PrivacyConsent"> | Date | string
    updatedAt?: DateTimeFilter<"PrivacyConsent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_consentType_consentVersion">

  export type PrivacyConsentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    consentVersion?: SortOrder
    consentStatus?: SortOrder
    consentDate?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    purposes?: SortOrder
    dataCategories?: SortOrder
    thirdParties?: SortOrder
    withdrawnAt?: SortOrderInput | SortOrder
    withdrawalReason?: SortOrderInput | SortOrder
    legalBasis?: SortOrder
    jurisdiction?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PrivacyConsentCountOrderByAggregateInput
    _max?: PrivacyConsentMaxOrderByAggregateInput
    _min?: PrivacyConsentMinOrderByAggregateInput
  }

  export type PrivacyConsentScalarWhereWithAggregatesInput = {
    AND?: PrivacyConsentScalarWhereWithAggregatesInput | PrivacyConsentScalarWhereWithAggregatesInput[]
    OR?: PrivacyConsentScalarWhereWithAggregatesInput[]
    NOT?: PrivacyConsentScalarWhereWithAggregatesInput | PrivacyConsentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PrivacyConsent"> | string
    userId?: StringWithAggregatesFilter<"PrivacyConsent"> | string
    consentType?: EnumConsentTypeWithAggregatesFilter<"PrivacyConsent"> | $Enums.ConsentType
    consentVersion?: StringWithAggregatesFilter<"PrivacyConsent"> | string
    consentStatus?: EnumConsentStatusWithAggregatesFilter<"PrivacyConsent"> | $Enums.ConsentStatus
    consentDate?: DateTimeNullableWithAggregatesFilter<"PrivacyConsent"> | Date | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"PrivacyConsent"> | Date | string | null
    purposes?: StringNullableListFilter<"PrivacyConsent">
    dataCategories?: StringNullableListFilter<"PrivacyConsent">
    thirdParties?: StringNullableListFilter<"PrivacyConsent">
    withdrawnAt?: DateTimeNullableWithAggregatesFilter<"PrivacyConsent"> | Date | string | null
    withdrawalReason?: StringNullableWithAggregatesFilter<"PrivacyConsent"> | string | null
    legalBasis?: StringWithAggregatesFilter<"PrivacyConsent"> | string
    jurisdiction?: StringWithAggregatesFilter<"PrivacyConsent"> | string
    ipAddress?: StringWithAggregatesFilter<"PrivacyConsent"> | string
    userAgent?: StringNullableWithAggregatesFilter<"PrivacyConsent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PrivacyConsent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PrivacyConsent"> | Date | string
  }

  export type DataAccessRequestWhereInput = {
    AND?: DataAccessRequestWhereInput | DataAccessRequestWhereInput[]
    OR?: DataAccessRequestWhereInput[]
    NOT?: DataAccessRequestWhereInput | DataAccessRequestWhereInput[]
    id?: StringFilter<"DataAccessRequest"> | string
    userId?: StringFilter<"DataAccessRequest"> | string
    requestType?: EnumDataRequestTypeFilter<"DataAccessRequest"> | $Enums.DataRequestType
    requestStatus?: EnumDataRequestStatusFilter<"DataAccessRequest"> | $Enums.DataRequestStatus
    requestDate?: DateTimeFilter<"DataAccessRequest"> | Date | string
    requestDetails?: JsonNullableFilter<"DataAccessRequest">
    verificationMethod?: StringNullableFilter<"DataAccessRequest"> | string | null
    verifiedAt?: DateTimeNullableFilter<"DataAccessRequest"> | Date | string | null
    processedBy?: StringNullableFilter<"DataAccessRequest"> | string | null
    processedAt?: DateTimeNullableFilter<"DataAccessRequest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DataAccessRequest"> | Date | string | null
    responseMethod?: StringNullableFilter<"DataAccessRequest"> | string | null
    responseUrl?: StringNullableFilter<"DataAccessRequest"> | string | null
    responseExpiryDate?: DateTimeNullableFilter<"DataAccessRequest"> | Date | string | null
    dueDate?: DateTimeFilter<"DataAccessRequest"> | Date | string
    extensionReason?: StringNullableFilter<"DataAccessRequest"> | string | null
    extendedDueDate?: DateTimeNullableFilter<"DataAccessRequest"> | Date | string | null
    notes?: StringNullableFilter<"DataAccessRequest"> | string | null
    createdAt?: DateTimeFilter<"DataAccessRequest"> | Date | string
    updatedAt?: DateTimeFilter<"DataAccessRequest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DataAccessRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    requestType?: SortOrder
    requestStatus?: SortOrder
    requestDate?: SortOrder
    requestDetails?: SortOrderInput | SortOrder
    verificationMethod?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    processedBy?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    responseMethod?: SortOrderInput | SortOrder
    responseUrl?: SortOrderInput | SortOrder
    responseExpiryDate?: SortOrderInput | SortOrder
    dueDate?: SortOrder
    extensionReason?: SortOrderInput | SortOrder
    extendedDueDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DataAccessRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DataAccessRequestWhereInput | DataAccessRequestWhereInput[]
    OR?: DataAccessRequestWhereInput[]
    NOT?: DataAccessRequestWhereInput | DataAccessRequestWhereInput[]
    userId?: StringFilter<"DataAccessRequest"> | string
    requestType?: EnumDataRequestTypeFilter<"DataAccessRequest"> | $Enums.DataRequestType
    requestStatus?: EnumDataRequestStatusFilter<"DataAccessRequest"> | $Enums.DataRequestStatus
    requestDate?: DateTimeFilter<"DataAccessRequest"> | Date | string
    requestDetails?: JsonNullableFilter<"DataAccessRequest">
    verificationMethod?: StringNullableFilter<"DataAccessRequest"> | string | null
    verifiedAt?: DateTimeNullableFilter<"DataAccessRequest"> | Date | string | null
    processedBy?: StringNullableFilter<"DataAccessRequest"> | string | null
    processedAt?: DateTimeNullableFilter<"DataAccessRequest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DataAccessRequest"> | Date | string | null
    responseMethod?: StringNullableFilter<"DataAccessRequest"> | string | null
    responseUrl?: StringNullableFilter<"DataAccessRequest"> | string | null
    responseExpiryDate?: DateTimeNullableFilter<"DataAccessRequest"> | Date | string | null
    dueDate?: DateTimeFilter<"DataAccessRequest"> | Date | string
    extensionReason?: StringNullableFilter<"DataAccessRequest"> | string | null
    extendedDueDate?: DateTimeNullableFilter<"DataAccessRequest"> | Date | string | null
    notes?: StringNullableFilter<"DataAccessRequest"> | string | null
    createdAt?: DateTimeFilter<"DataAccessRequest"> | Date | string
    updatedAt?: DateTimeFilter<"DataAccessRequest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DataAccessRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    requestType?: SortOrder
    requestStatus?: SortOrder
    requestDate?: SortOrder
    requestDetails?: SortOrderInput | SortOrder
    verificationMethod?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    processedBy?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    responseMethod?: SortOrderInput | SortOrder
    responseUrl?: SortOrderInput | SortOrder
    responseExpiryDate?: SortOrderInput | SortOrder
    dueDate?: SortOrder
    extensionReason?: SortOrderInput | SortOrder
    extendedDueDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DataAccessRequestCountOrderByAggregateInput
    _max?: DataAccessRequestMaxOrderByAggregateInput
    _min?: DataAccessRequestMinOrderByAggregateInput
  }

  export type DataAccessRequestScalarWhereWithAggregatesInput = {
    AND?: DataAccessRequestScalarWhereWithAggregatesInput | DataAccessRequestScalarWhereWithAggregatesInput[]
    OR?: DataAccessRequestScalarWhereWithAggregatesInput[]
    NOT?: DataAccessRequestScalarWhereWithAggregatesInput | DataAccessRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataAccessRequest"> | string
    userId?: StringWithAggregatesFilter<"DataAccessRequest"> | string
    requestType?: EnumDataRequestTypeWithAggregatesFilter<"DataAccessRequest"> | $Enums.DataRequestType
    requestStatus?: EnumDataRequestStatusWithAggregatesFilter<"DataAccessRequest"> | $Enums.DataRequestStatus
    requestDate?: DateTimeWithAggregatesFilter<"DataAccessRequest"> | Date | string
    requestDetails?: JsonNullableWithAggregatesFilter<"DataAccessRequest">
    verificationMethod?: StringNullableWithAggregatesFilter<"DataAccessRequest"> | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"DataAccessRequest"> | Date | string | null
    processedBy?: StringNullableWithAggregatesFilter<"DataAccessRequest"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"DataAccessRequest"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"DataAccessRequest"> | Date | string | null
    responseMethod?: StringNullableWithAggregatesFilter<"DataAccessRequest"> | string | null
    responseUrl?: StringNullableWithAggregatesFilter<"DataAccessRequest"> | string | null
    responseExpiryDate?: DateTimeNullableWithAggregatesFilter<"DataAccessRequest"> | Date | string | null
    dueDate?: DateTimeWithAggregatesFilter<"DataAccessRequest"> | Date | string
    extensionReason?: StringNullableWithAggregatesFilter<"DataAccessRequest"> | string | null
    extendedDueDate?: DateTimeNullableWithAggregatesFilter<"DataAccessRequest"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"DataAccessRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DataAccessRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DataAccessRequest"> | Date | string
  }

  export type APRAIncidentReportWhereInput = {
    AND?: APRAIncidentReportWhereInput | APRAIncidentReportWhereInput[]
    OR?: APRAIncidentReportWhereInput[]
    NOT?: APRAIncidentReportWhereInput | APRAIncidentReportWhereInput[]
    id?: StringFilter<"APRAIncidentReport"> | string
    incidentType?: EnumIncidentTypeFilter<"APRAIncidentReport"> | $Enums.IncidentType
    severity?: EnumIncidentSeverityFilter<"APRAIncidentReport"> | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFilter<"APRAIncidentReport"> | $Enums.IncidentStatus
    title?: StringFilter<"APRAIncidentReport"> | string
    description?: StringFilter<"APRAIncidentReport"> | string
    detectedAt?: DateTimeFilter<"APRAIncidentReport"> | Date | string
    reportedAt?: DateTimeNullableFilter<"APRAIncidentReport"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"APRAIncidentReport"> | Date | string | null
    affectedUsers?: IntFilter<"APRAIncidentReport"> | number
    affectedSystems?: StringNullableListFilter<"APRAIncidentReport">
    dataCompromised?: BoolFilter<"APRAIncidentReport"> | boolean
    financialImpact?: DecimalNullableFilter<"APRAIncidentReport"> | Decimal | DecimalJsLike | number | string | null
    immediateActions?: JsonNullableFilter<"APRAIncidentReport">
    rootCause?: StringNullableFilter<"APRAIncidentReport"> | string | null
    remediation?: JsonNullableFilter<"APRAIncidentReport">
    preventiveMeasures?: JsonNullableFilter<"APRAIncidentReport">
    reportedToAPRA?: BoolFilter<"APRAIncidentReport"> | boolean
    apraReference?: StringNullableFilter<"APRAIncidentReport"> | string | null
    reportedToOAIC?: BoolFilter<"APRAIncidentReport"> | boolean
    oaicReference?: StringNullableFilter<"APRAIncidentReport"> | string | null
    bcpActivated?: BoolFilter<"APRAIncidentReport"> | boolean
    serviceDowntime?: IntNullableFilter<"APRAIncidentReport"> | number | null
    dataRecoveryTime?: IntNullableFilter<"APRAIncidentReport"> | number | null
    reportedBy?: StringNullableFilter<"APRAIncidentReport"> | string | null
    responsibleTeam?: StringNullableFilter<"APRAIncidentReport"> | string | null
    createdAt?: DateTimeFilter<"APRAIncidentReport"> | Date | string
    updatedAt?: DateTimeFilter<"APRAIncidentReport"> | Date | string
  }

  export type APRAIncidentReportOrderByWithRelationInput = {
    id?: SortOrder
    incidentType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    detectedAt?: SortOrder
    reportedAt?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    affectedUsers?: SortOrder
    affectedSystems?: SortOrder
    dataCompromised?: SortOrder
    financialImpact?: SortOrderInput | SortOrder
    immediateActions?: SortOrderInput | SortOrder
    rootCause?: SortOrderInput | SortOrder
    remediation?: SortOrderInput | SortOrder
    preventiveMeasures?: SortOrderInput | SortOrder
    reportedToAPRA?: SortOrder
    apraReference?: SortOrderInput | SortOrder
    reportedToOAIC?: SortOrder
    oaicReference?: SortOrderInput | SortOrder
    bcpActivated?: SortOrder
    serviceDowntime?: SortOrderInput | SortOrder
    dataRecoveryTime?: SortOrderInput | SortOrder
    reportedBy?: SortOrderInput | SortOrder
    responsibleTeam?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type APRAIncidentReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: APRAIncidentReportWhereInput | APRAIncidentReportWhereInput[]
    OR?: APRAIncidentReportWhereInput[]
    NOT?: APRAIncidentReportWhereInput | APRAIncidentReportWhereInput[]
    incidentType?: EnumIncidentTypeFilter<"APRAIncidentReport"> | $Enums.IncidentType
    severity?: EnumIncidentSeverityFilter<"APRAIncidentReport"> | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFilter<"APRAIncidentReport"> | $Enums.IncidentStatus
    title?: StringFilter<"APRAIncidentReport"> | string
    description?: StringFilter<"APRAIncidentReport"> | string
    detectedAt?: DateTimeFilter<"APRAIncidentReport"> | Date | string
    reportedAt?: DateTimeNullableFilter<"APRAIncidentReport"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"APRAIncidentReport"> | Date | string | null
    affectedUsers?: IntFilter<"APRAIncidentReport"> | number
    affectedSystems?: StringNullableListFilter<"APRAIncidentReport">
    dataCompromised?: BoolFilter<"APRAIncidentReport"> | boolean
    financialImpact?: DecimalNullableFilter<"APRAIncidentReport"> | Decimal | DecimalJsLike | number | string | null
    immediateActions?: JsonNullableFilter<"APRAIncidentReport">
    rootCause?: StringNullableFilter<"APRAIncidentReport"> | string | null
    remediation?: JsonNullableFilter<"APRAIncidentReport">
    preventiveMeasures?: JsonNullableFilter<"APRAIncidentReport">
    reportedToAPRA?: BoolFilter<"APRAIncidentReport"> | boolean
    apraReference?: StringNullableFilter<"APRAIncidentReport"> | string | null
    reportedToOAIC?: BoolFilter<"APRAIncidentReport"> | boolean
    oaicReference?: StringNullableFilter<"APRAIncidentReport"> | string | null
    bcpActivated?: BoolFilter<"APRAIncidentReport"> | boolean
    serviceDowntime?: IntNullableFilter<"APRAIncidentReport"> | number | null
    dataRecoveryTime?: IntNullableFilter<"APRAIncidentReport"> | number | null
    reportedBy?: StringNullableFilter<"APRAIncidentReport"> | string | null
    responsibleTeam?: StringNullableFilter<"APRAIncidentReport"> | string | null
    createdAt?: DateTimeFilter<"APRAIncidentReport"> | Date | string
    updatedAt?: DateTimeFilter<"APRAIncidentReport"> | Date | string
  }, "id">

  export type APRAIncidentReportOrderByWithAggregationInput = {
    id?: SortOrder
    incidentType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    detectedAt?: SortOrder
    reportedAt?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    affectedUsers?: SortOrder
    affectedSystems?: SortOrder
    dataCompromised?: SortOrder
    financialImpact?: SortOrderInput | SortOrder
    immediateActions?: SortOrderInput | SortOrder
    rootCause?: SortOrderInput | SortOrder
    remediation?: SortOrderInput | SortOrder
    preventiveMeasures?: SortOrderInput | SortOrder
    reportedToAPRA?: SortOrder
    apraReference?: SortOrderInput | SortOrder
    reportedToOAIC?: SortOrder
    oaicReference?: SortOrderInput | SortOrder
    bcpActivated?: SortOrder
    serviceDowntime?: SortOrderInput | SortOrder
    dataRecoveryTime?: SortOrderInput | SortOrder
    reportedBy?: SortOrderInput | SortOrder
    responsibleTeam?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: APRAIncidentReportCountOrderByAggregateInput
    _avg?: APRAIncidentReportAvgOrderByAggregateInput
    _max?: APRAIncidentReportMaxOrderByAggregateInput
    _min?: APRAIncidentReportMinOrderByAggregateInput
    _sum?: APRAIncidentReportSumOrderByAggregateInput
  }

  export type APRAIncidentReportScalarWhereWithAggregatesInput = {
    AND?: APRAIncidentReportScalarWhereWithAggregatesInput | APRAIncidentReportScalarWhereWithAggregatesInput[]
    OR?: APRAIncidentReportScalarWhereWithAggregatesInput[]
    NOT?: APRAIncidentReportScalarWhereWithAggregatesInput | APRAIncidentReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"APRAIncidentReport"> | string
    incidentType?: EnumIncidentTypeWithAggregatesFilter<"APRAIncidentReport"> | $Enums.IncidentType
    severity?: EnumIncidentSeverityWithAggregatesFilter<"APRAIncidentReport"> | $Enums.IncidentSeverity
    status?: EnumIncidentStatusWithAggregatesFilter<"APRAIncidentReport"> | $Enums.IncidentStatus
    title?: StringWithAggregatesFilter<"APRAIncidentReport"> | string
    description?: StringWithAggregatesFilter<"APRAIncidentReport"> | string
    detectedAt?: DateTimeWithAggregatesFilter<"APRAIncidentReport"> | Date | string
    reportedAt?: DateTimeNullableWithAggregatesFilter<"APRAIncidentReport"> | Date | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"APRAIncidentReport"> | Date | string | null
    affectedUsers?: IntWithAggregatesFilter<"APRAIncidentReport"> | number
    affectedSystems?: StringNullableListFilter<"APRAIncidentReport">
    dataCompromised?: BoolWithAggregatesFilter<"APRAIncidentReport"> | boolean
    financialImpact?: DecimalNullableWithAggregatesFilter<"APRAIncidentReport"> | Decimal | DecimalJsLike | number | string | null
    immediateActions?: JsonNullableWithAggregatesFilter<"APRAIncidentReport">
    rootCause?: StringNullableWithAggregatesFilter<"APRAIncidentReport"> | string | null
    remediation?: JsonNullableWithAggregatesFilter<"APRAIncidentReport">
    preventiveMeasures?: JsonNullableWithAggregatesFilter<"APRAIncidentReport">
    reportedToAPRA?: BoolWithAggregatesFilter<"APRAIncidentReport"> | boolean
    apraReference?: StringNullableWithAggregatesFilter<"APRAIncidentReport"> | string | null
    reportedToOAIC?: BoolWithAggregatesFilter<"APRAIncidentReport"> | boolean
    oaicReference?: StringNullableWithAggregatesFilter<"APRAIncidentReport"> | string | null
    bcpActivated?: BoolWithAggregatesFilter<"APRAIncidentReport"> | boolean
    serviceDowntime?: IntNullableWithAggregatesFilter<"APRAIncidentReport"> | number | null
    dataRecoveryTime?: IntNullableWithAggregatesFilter<"APRAIncidentReport"> | number | null
    reportedBy?: StringNullableWithAggregatesFilter<"APRAIncidentReport"> | string | null
    responsibleTeam?: StringNullableWithAggregatesFilter<"APRAIncidentReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"APRAIncidentReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"APRAIncidentReport"> | Date | string
  }

  export type GSTTransactionDetailWhereInput = {
    AND?: GSTTransactionDetailWhereInput | GSTTransactionDetailWhereInput[]
    OR?: GSTTransactionDetailWhereInput[]
    NOT?: GSTTransactionDetailWhereInput | GSTTransactionDetailWhereInput[]
    id?: StringFilter<"GSTTransactionDetail"> | string
    transactionId?: UuidFilter<"GSTTransactionDetail"> | string
    invoiceId?: UuidNullableFilter<"GSTTransactionDetail"> | string | null
    baseAmount?: DecimalFilter<"GSTTransactionDetail"> | Decimal | DecimalJsLike | number | string
    gstRate?: DecimalFilter<"GSTTransactionDetail"> | Decimal | DecimalJsLike | number | string
    gstAmount?: DecimalFilter<"GSTTransactionDetail"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"GSTTransactionDetail"> | Decimal | DecimalJsLike | number | string
    taxCategory?: StringFilter<"GSTTransactionDetail"> | string
    gstTreatment?: EnumGSTTreatmentFilter<"GSTTransactionDetail"> | $Enums.GSTTreatment
    inputTaxCredit?: BoolFilter<"GSTTransactionDetail"> | boolean
    supplierABN?: StringNullableFilter<"GSTTransactionDetail"> | string | null
    supplierName?: StringNullableFilter<"GSTTransactionDetail"> | string | null
    isGSTRegistered?: BoolFilter<"GSTTransactionDetail"> | boolean
    basReportingCode?: StringNullableFilter<"GSTTransactionDetail"> | string | null
    taxPeriod?: StringFilter<"GSTTransactionDetail"> | string
    reportedInBAS?: BoolFilter<"GSTTransactionDetail"> | boolean
    basReference?: StringNullableFilter<"GSTTransactionDetail"> | string | null
    validated?: BoolFilter<"GSTTransactionDetail"> | boolean
    validationErrors?: StringNullableListFilter<"GSTTransactionDetail">
    createdAt?: DateTimeFilter<"GSTTransactionDetail"> | Date | string
    updatedAt?: DateTimeFilter<"GSTTransactionDetail"> | Date | string
  }

  export type GSTTransactionDetailOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    baseAmount?: SortOrder
    gstRate?: SortOrder
    gstAmount?: SortOrder
    totalAmount?: SortOrder
    taxCategory?: SortOrder
    gstTreatment?: SortOrder
    inputTaxCredit?: SortOrder
    supplierABN?: SortOrderInput | SortOrder
    supplierName?: SortOrderInput | SortOrder
    isGSTRegistered?: SortOrder
    basReportingCode?: SortOrderInput | SortOrder
    taxPeriod?: SortOrder
    reportedInBAS?: SortOrder
    basReference?: SortOrderInput | SortOrder
    validated?: SortOrder
    validationErrors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GSTTransactionDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GSTTransactionDetailWhereInput | GSTTransactionDetailWhereInput[]
    OR?: GSTTransactionDetailWhereInput[]
    NOT?: GSTTransactionDetailWhereInput | GSTTransactionDetailWhereInput[]
    transactionId?: UuidFilter<"GSTTransactionDetail"> | string
    invoiceId?: UuidNullableFilter<"GSTTransactionDetail"> | string | null
    baseAmount?: DecimalFilter<"GSTTransactionDetail"> | Decimal | DecimalJsLike | number | string
    gstRate?: DecimalFilter<"GSTTransactionDetail"> | Decimal | DecimalJsLike | number | string
    gstAmount?: DecimalFilter<"GSTTransactionDetail"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"GSTTransactionDetail"> | Decimal | DecimalJsLike | number | string
    taxCategory?: StringFilter<"GSTTransactionDetail"> | string
    gstTreatment?: EnumGSTTreatmentFilter<"GSTTransactionDetail"> | $Enums.GSTTreatment
    inputTaxCredit?: BoolFilter<"GSTTransactionDetail"> | boolean
    supplierABN?: StringNullableFilter<"GSTTransactionDetail"> | string | null
    supplierName?: StringNullableFilter<"GSTTransactionDetail"> | string | null
    isGSTRegistered?: BoolFilter<"GSTTransactionDetail"> | boolean
    basReportingCode?: StringNullableFilter<"GSTTransactionDetail"> | string | null
    taxPeriod?: StringFilter<"GSTTransactionDetail"> | string
    reportedInBAS?: BoolFilter<"GSTTransactionDetail"> | boolean
    basReference?: StringNullableFilter<"GSTTransactionDetail"> | string | null
    validated?: BoolFilter<"GSTTransactionDetail"> | boolean
    validationErrors?: StringNullableListFilter<"GSTTransactionDetail">
    createdAt?: DateTimeFilter<"GSTTransactionDetail"> | Date | string
    updatedAt?: DateTimeFilter<"GSTTransactionDetail"> | Date | string
  }, "id">

  export type GSTTransactionDetailOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    baseAmount?: SortOrder
    gstRate?: SortOrder
    gstAmount?: SortOrder
    totalAmount?: SortOrder
    taxCategory?: SortOrder
    gstTreatment?: SortOrder
    inputTaxCredit?: SortOrder
    supplierABN?: SortOrderInput | SortOrder
    supplierName?: SortOrderInput | SortOrder
    isGSTRegistered?: SortOrder
    basReportingCode?: SortOrderInput | SortOrder
    taxPeriod?: SortOrder
    reportedInBAS?: SortOrder
    basReference?: SortOrderInput | SortOrder
    validated?: SortOrder
    validationErrors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GSTTransactionDetailCountOrderByAggregateInput
    _avg?: GSTTransactionDetailAvgOrderByAggregateInput
    _max?: GSTTransactionDetailMaxOrderByAggregateInput
    _min?: GSTTransactionDetailMinOrderByAggregateInput
    _sum?: GSTTransactionDetailSumOrderByAggregateInput
  }

  export type GSTTransactionDetailScalarWhereWithAggregatesInput = {
    AND?: GSTTransactionDetailScalarWhereWithAggregatesInput | GSTTransactionDetailScalarWhereWithAggregatesInput[]
    OR?: GSTTransactionDetailScalarWhereWithAggregatesInput[]
    NOT?: GSTTransactionDetailScalarWhereWithAggregatesInput | GSTTransactionDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GSTTransactionDetail"> | string
    transactionId?: UuidWithAggregatesFilter<"GSTTransactionDetail"> | string
    invoiceId?: UuidNullableWithAggregatesFilter<"GSTTransactionDetail"> | string | null
    baseAmount?: DecimalWithAggregatesFilter<"GSTTransactionDetail"> | Decimal | DecimalJsLike | number | string
    gstRate?: DecimalWithAggregatesFilter<"GSTTransactionDetail"> | Decimal | DecimalJsLike | number | string
    gstAmount?: DecimalWithAggregatesFilter<"GSTTransactionDetail"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalWithAggregatesFilter<"GSTTransactionDetail"> | Decimal | DecimalJsLike | number | string
    taxCategory?: StringWithAggregatesFilter<"GSTTransactionDetail"> | string
    gstTreatment?: EnumGSTTreatmentWithAggregatesFilter<"GSTTransactionDetail"> | $Enums.GSTTreatment
    inputTaxCredit?: BoolWithAggregatesFilter<"GSTTransactionDetail"> | boolean
    supplierABN?: StringNullableWithAggregatesFilter<"GSTTransactionDetail"> | string | null
    supplierName?: StringNullableWithAggregatesFilter<"GSTTransactionDetail"> | string | null
    isGSTRegistered?: BoolWithAggregatesFilter<"GSTTransactionDetail"> | boolean
    basReportingCode?: StringNullableWithAggregatesFilter<"GSTTransactionDetail"> | string | null
    taxPeriod?: StringWithAggregatesFilter<"GSTTransactionDetail"> | string
    reportedInBAS?: BoolWithAggregatesFilter<"GSTTransactionDetail"> | boolean
    basReference?: StringNullableWithAggregatesFilter<"GSTTransactionDetail"> | string | null
    validated?: BoolWithAggregatesFilter<"GSTTransactionDetail"> | boolean
    validationErrors?: StringNullableListFilter<"GSTTransactionDetail">
    createdAt?: DateTimeWithAggregatesFilter<"GSTTransactionDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GSTTransactionDetail"> | Date | string
  }

  export type ComplianceConfigurationWhereInput = {
    AND?: ComplianceConfigurationWhereInput | ComplianceConfigurationWhereInput[]
    OR?: ComplianceConfigurationWhereInput[]
    NOT?: ComplianceConfigurationWhereInput | ComplianceConfigurationWhereInput[]
    id?: StringFilter<"ComplianceConfiguration"> | string
    configType?: StringFilter<"ComplianceConfiguration"> | string
    configData?: JsonFilter<"ComplianceConfiguration">
    isActive?: BoolFilter<"ComplianceConfiguration"> | boolean
    amlThresholds?: JsonNullableFilter<"ComplianceConfiguration">
    dataRetentionDays?: IntNullableFilter<"ComplianceConfiguration"> | number | null
    consentExpireDays?: IntNullableFilter<"ComplianceConfiguration"> | number | null
    incidentReportHours?: IntNullableFilter<"ComplianceConfiguration"> | number | null
    backupFrequency?: StringNullableFilter<"ComplianceConfiguration"> | string | null
    gstRate?: DecimalNullableFilter<"ComplianceConfiguration"> | Decimal | DecimalJsLike | number | string | null
    basReportingCodes?: JsonNullableFilter<"ComplianceConfiguration">
    createdAt?: DateTimeFilter<"ComplianceConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceConfiguration"> | Date | string
  }

  export type ComplianceConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    configType?: SortOrder
    configData?: SortOrder
    isActive?: SortOrder
    amlThresholds?: SortOrderInput | SortOrder
    dataRetentionDays?: SortOrderInput | SortOrder
    consentExpireDays?: SortOrderInput | SortOrder
    incidentReportHours?: SortOrderInput | SortOrder
    backupFrequency?: SortOrderInput | SortOrder
    gstRate?: SortOrderInput | SortOrder
    basReportingCodes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    configType?: string
    AND?: ComplianceConfigurationWhereInput | ComplianceConfigurationWhereInput[]
    OR?: ComplianceConfigurationWhereInput[]
    NOT?: ComplianceConfigurationWhereInput | ComplianceConfigurationWhereInput[]
    configData?: JsonFilter<"ComplianceConfiguration">
    isActive?: BoolFilter<"ComplianceConfiguration"> | boolean
    amlThresholds?: JsonNullableFilter<"ComplianceConfiguration">
    dataRetentionDays?: IntNullableFilter<"ComplianceConfiguration"> | number | null
    consentExpireDays?: IntNullableFilter<"ComplianceConfiguration"> | number | null
    incidentReportHours?: IntNullableFilter<"ComplianceConfiguration"> | number | null
    backupFrequency?: StringNullableFilter<"ComplianceConfiguration"> | string | null
    gstRate?: DecimalNullableFilter<"ComplianceConfiguration"> | Decimal | DecimalJsLike | number | string | null
    basReportingCodes?: JsonNullableFilter<"ComplianceConfiguration">
    createdAt?: DateTimeFilter<"ComplianceConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceConfiguration"> | Date | string
  }, "id" | "configType">

  export type ComplianceConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    configType?: SortOrder
    configData?: SortOrder
    isActive?: SortOrder
    amlThresholds?: SortOrderInput | SortOrder
    dataRetentionDays?: SortOrderInput | SortOrder
    consentExpireDays?: SortOrderInput | SortOrder
    incidentReportHours?: SortOrderInput | SortOrder
    backupFrequency?: SortOrderInput | SortOrder
    gstRate?: SortOrderInput | SortOrder
    basReportingCodes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComplianceConfigurationCountOrderByAggregateInput
    _avg?: ComplianceConfigurationAvgOrderByAggregateInput
    _max?: ComplianceConfigurationMaxOrderByAggregateInput
    _min?: ComplianceConfigurationMinOrderByAggregateInput
    _sum?: ComplianceConfigurationSumOrderByAggregateInput
  }

  export type ComplianceConfigurationScalarWhereWithAggregatesInput = {
    AND?: ComplianceConfigurationScalarWhereWithAggregatesInput | ComplianceConfigurationScalarWhereWithAggregatesInput[]
    OR?: ComplianceConfigurationScalarWhereWithAggregatesInput[]
    NOT?: ComplianceConfigurationScalarWhereWithAggregatesInput | ComplianceConfigurationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComplianceConfiguration"> | string
    configType?: StringWithAggregatesFilter<"ComplianceConfiguration"> | string
    configData?: JsonWithAggregatesFilter<"ComplianceConfiguration">
    isActive?: BoolWithAggregatesFilter<"ComplianceConfiguration"> | boolean
    amlThresholds?: JsonNullableWithAggregatesFilter<"ComplianceConfiguration">
    dataRetentionDays?: IntNullableWithAggregatesFilter<"ComplianceConfiguration"> | number | null
    consentExpireDays?: IntNullableWithAggregatesFilter<"ComplianceConfiguration"> | number | null
    incidentReportHours?: IntNullableWithAggregatesFilter<"ComplianceConfiguration"> | number | null
    backupFrequency?: StringNullableWithAggregatesFilter<"ComplianceConfiguration"> | string | null
    gstRate?: DecimalNullableWithAggregatesFilter<"ComplianceConfiguration"> | Decimal | DecimalJsLike | number | string | null
    basReportingCodes?: JsonNullableWithAggregatesFilter<"ComplianceConfiguration">
    createdAt?: DateTimeWithAggregatesFilter<"ComplianceConfiguration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ComplianceConfiguration"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    event: $Enums.AuthEvent
    ipAddress: string
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    success?: boolean
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    event: $Enums.AuthEvent
    ipAddress: string
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    success?: boolean
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: EnumAuthEventFieldUpdateOperationsInput | $Enums.AuthEvent
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    event?: EnumAuthEventFieldUpdateOperationsInput | $Enums.AuthEvent
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    event: $Enums.AuthEvent
    ipAddress: string
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    success?: boolean
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: EnumAuthEventFieldUpdateOperationsInput | $Enums.AuthEvent
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    event?: EnumAuthEventFieldUpdateOperationsInput | $Enums.AuthEvent
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialAuditLogCreateInput = {
    id?: string
    sessionId?: string | null
    operationType: $Enums.FinancialOperation
    resourceType: string
    resourceId?: string | null
    ipAddress: string
    userAgent?: string | null
    httpMethod?: string | null
    endpoint?: string | null
    previousData?: NullableJsonNullValueInput | InputJsonValue
    currentData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: FinancialAuditLogCreatechangedFieldsInput | string[]
    amount?: Decimal | DecimalJsLike | number | string | null
    gstAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    taxYear?: string | null
    success?: boolean
    errorMessage?: string | null
    hashChain?: string | null
    previousHash?: string | null
    createdAt?: Date | string
    timezone?: string
    user: UserCreateNestedOneWithoutFinancialAuditLogsInput
  }

  export type FinancialAuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    sessionId?: string | null
    operationType: $Enums.FinancialOperation
    resourceType: string
    resourceId?: string | null
    ipAddress: string
    userAgent?: string | null
    httpMethod?: string | null
    endpoint?: string | null
    previousData?: NullableJsonNullValueInput | InputJsonValue
    currentData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: FinancialAuditLogCreatechangedFieldsInput | string[]
    amount?: Decimal | DecimalJsLike | number | string | null
    gstAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    taxYear?: string | null
    success?: boolean
    errorMessage?: string | null
    hashChain?: string | null
    previousHash?: string | null
    createdAt?: Date | string
    timezone?: string
  }

  export type FinancialAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    operationType?: EnumFinancialOperationFieldUpdateOperationsInput | $Enums.FinancialOperation
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    httpMethod?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    previousData?: NullableJsonNullValueInput | InputJsonValue
    currentData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: FinancialAuditLogUpdatechangedFieldsInput | string[]
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gstAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    taxYear?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    hashChain?: NullableStringFieldUpdateOperationsInput | string | null
    previousHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutFinancialAuditLogsNestedInput
  }

  export type FinancialAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    operationType?: EnumFinancialOperationFieldUpdateOperationsInput | $Enums.FinancialOperation
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    httpMethod?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    previousData?: NullableJsonNullValueInput | InputJsonValue
    currentData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: FinancialAuditLogUpdatechangedFieldsInput | string[]
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gstAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    taxYear?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    hashChain?: NullableStringFieldUpdateOperationsInput | string | null
    previousHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
  }

  export type FinancialAuditLogCreateManyInput = {
    id?: string
    userId: string
    sessionId?: string | null
    operationType: $Enums.FinancialOperation
    resourceType: string
    resourceId?: string | null
    ipAddress: string
    userAgent?: string | null
    httpMethod?: string | null
    endpoint?: string | null
    previousData?: NullableJsonNullValueInput | InputJsonValue
    currentData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: FinancialAuditLogCreatechangedFieldsInput | string[]
    amount?: Decimal | DecimalJsLike | number | string | null
    gstAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    taxYear?: string | null
    success?: boolean
    errorMessage?: string | null
    hashChain?: string | null
    previousHash?: string | null
    createdAt?: Date | string
    timezone?: string
  }

  export type FinancialAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    operationType?: EnumFinancialOperationFieldUpdateOperationsInput | $Enums.FinancialOperation
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    httpMethod?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    previousData?: NullableJsonNullValueInput | InputJsonValue
    currentData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: FinancialAuditLogUpdatechangedFieldsInput | string[]
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gstAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    taxYear?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    hashChain?: NullableStringFieldUpdateOperationsInput | string | null
    previousHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
  }

  export type FinancialAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    operationType?: EnumFinancialOperationFieldUpdateOperationsInput | $Enums.FinancialOperation
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    httpMethod?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    previousData?: NullableJsonNullValueInput | InputJsonValue
    currentData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: FinancialAuditLogUpdatechangedFieldsInput | string[]
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gstAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    taxYear?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    hashChain?: NullableStringFieldUpdateOperationsInput | string | null
    previousHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    stripePriceId: string
    status: string
    plan: $Enums.Plan
    interval?: string
    amount: number
    currency?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    trialEnd?: Date | string | null
    defaultPaymentMethodId?: string | null
    lastPaymentAttempt?: Date | string | null
    failedPaymentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    stripePriceId: string
    status: string
    plan: $Enums.Plan
    interval?: string
    amount: number
    currency?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    trialEnd?: Date | string | null
    defaultPaymentMethodId?: string | null
    lastPaymentAttempt?: Date | string | null
    failedPaymentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    interval?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedPaymentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    interval?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedPaymentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    stripePriceId: string
    status: string
    plan: $Enums.Plan
    interval?: string
    amount: number
    currency?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    trialEnd?: Date | string | null
    defaultPaymentMethodId?: string | null
    lastPaymentAttempt?: Date | string | null
    failedPaymentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    interval?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedPaymentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    interval?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedPaymentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxReturnCreateInput = {
    id?: string
    year: string
    data: JsonNullValueInput | InputJsonValue
    status?: $Enums.TaxReturnStatus
    submittedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTaxReturnsInput
  }

  export type TaxReturnUncheckedCreateInput = {
    id?: string
    userId: string
    year: string
    data: JsonNullValueInput | InputJsonValue
    status?: $Enums.TaxReturnStatus
    submittedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxReturnUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumTaxReturnStatusFieldUpdateOperationsInput | $Enums.TaxReturnStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTaxReturnsNestedInput
  }

  export type TaxReturnUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumTaxReturnStatusFieldUpdateOperationsInput | $Enums.TaxReturnStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxReturnCreateManyInput = {
    id?: string
    userId: string
    year: string
    data: JsonNullValueInput | InputJsonValue
    status?: $Enums.TaxReturnStatus
    submittedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxReturnUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumTaxReturnStatusFieldUpdateOperationsInput | $Enums.TaxReturnStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxReturnUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumTaxReturnStatusFieldUpdateOperationsInput | $Enums.TaxReturnStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    stripePaymentIntentId: string
    amount: number
    currency: string
    status: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    userId: string
    stripePaymentIntentId: string
    amount: number
    currency: string
    status: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    userId: string
    stripePaymentIntentId: string
    amount: number
    currency: string
    status: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    stripeInvoiceId: string
    customerName: string
    customerEmail: string
    customerABN?: string | null
    subtotal: number
    gstAmount: number
    total: number
    status: string
    invoiceDate: Date | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: InvoiceLineItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    invoiceNumber: string
    stripeInvoiceId: string
    customerName: string
    customerEmail: string
    customerABN?: string | null
    subtotal: number
    gstAmount: number
    total: number
    status: string
    invoiceDate: Date | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerABN?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: IntFieldUpdateOperationsInput | number
    gstAmount?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: InvoiceLineItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerABN?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: IntFieldUpdateOperationsInput | number
    gstAmount?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: InvoiceLineItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    invoiceNumber: string
    stripeInvoiceId: string
    customerName: string
    customerEmail: string
    customerABN?: string | null
    subtotal: number
    gstAmount: number
    total: number
    status: string
    invoiceDate: Date | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerABN?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: IntFieldUpdateOperationsInput | number
    gstAmount?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerABN?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: IntFieldUpdateOperationsInput | number
    gstAmount?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemCreateInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutLineItemsInput
  }

  export type InvoiceLineItemUncheckedCreateInput = {
    id?: string
    invoiceId: string
    description: string
    quantity: number
    unitPrice: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutLineItemsNestedInput
  }

  export type InvoiceLineItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemCreateManyInput = {
    id?: string
    invoiceId: string
    description: string
    quantity: number
    unitPrice: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationCreateInput = {
    id?: string
    sessionId: string
    provider: string
    model: string
    messages: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: number
    costUsd?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAiConversationsInput
  }

  export type AIConversationUncheckedCreateInput = {
    id?: string
    userId: string
    sessionId: string
    provider: string
    model: string
    messages: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: number
    costUsd?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAiConversationsNestedInput
  }

  export type AIConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationCreateManyInput = {
    id?: string
    userId: string
    sessionId: string
    provider: string
    model: string
    messages: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: number
    costUsd?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInsightCreateInput = {
    id?: string
    insightType: string
    category: string
    content: JsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: AIInsightCreatesourceDataIdsInput | string[]
    provider: string
    model: string
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAiInsightsInput
  }

  export type AIInsightUncheckedCreateInput = {
    id?: string
    userId: string
    insightType: string
    category: string
    content: JsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: AIInsightCreatesourceDataIdsInput | string[]
    provider: string
    model: string
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AIInsightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: AIInsightUpdatesourceDataIdsInput | string[]
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAiInsightsNestedInput
  }

  export type AIInsightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: AIInsightUpdatesourceDataIdsInput | string[]
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInsightCreateManyInput = {
    id?: string
    userId: string
    insightType: string
    category: string
    content: JsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: AIInsightCreatesourceDataIdsInput | string[]
    provider: string
    model: string
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AIInsightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: AIInsightUpdatesourceDataIdsInput | string[]
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInsightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: AIInsightUpdatesourceDataIdsInput | string[]
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageTrackingCreateInput = {
    id?: string
    provider: string
    model: string
    operationType: string
    tokensInput?: number
    tokensOutput?: number
    costUsd?: Decimal | DecimalJsLike | number | string
    responseTimeMs?: number | null
    success?: boolean
    errorMessage?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAiUsageTrackingInput
  }

  export type AIUsageTrackingUncheckedCreateInput = {
    id?: string
    userId: string
    provider: string
    model: string
    operationType: string
    tokensInput?: number
    tokensOutput?: number
    costUsd?: Decimal | DecimalJsLike | number | string
    responseTimeMs?: number | null
    success?: boolean
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type AIUsageTrackingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    tokensInput?: IntFieldUpdateOperationsInput | number
    tokensOutput?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAiUsageTrackingNestedInput
  }

  export type AIUsageTrackingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    tokensInput?: IntFieldUpdateOperationsInput | number
    tokensOutput?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageTrackingCreateManyInput = {
    id?: string
    userId: string
    provider: string
    model: string
    operationType: string
    tokensInput?: number
    tokensOutput?: number
    costUsd?: Decimal | DecimalJsLike | number | string
    responseTimeMs?: number | null
    success?: boolean
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type AIUsageTrackingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    tokensInput?: IntFieldUpdateOperationsInput | number
    tokensOutput?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageTrackingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    tokensInput?: IntFieldUpdateOperationsInput | number
    tokensOutput?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AICacheCreateInput = {
    id?: string
    cacheKey: string
    operationType: string
    inputHash: string
    response: JsonNullValueInput | InputJsonValue
    provider: string
    model: string
    hitCount?: number
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AICacheUncheckedCreateInput = {
    id?: string
    cacheKey: string
    operationType: string
    inputHash: string
    response: JsonNullValueInput | InputJsonValue
    provider: string
    model: string
    hitCount?: number
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AICacheUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacheKey?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    inputHash?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    hitCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AICacheUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacheKey?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    inputHash?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    hitCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AICacheCreateManyInput = {
    id?: string
    cacheKey: string
    operationType: string
    inputHash: string
    response: JsonNullValueInput | InputJsonValue
    provider: string
    model: string
    hitCount?: number
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AICacheUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacheKey?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    inputHash?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    hitCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AICacheUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacheKey?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    inputHash?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    hitCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIProviderHealthCreateInput = {
    id?: string
    provider: string
    status?: string
    consecutiveFailures?: number
    lastFailureAt?: Date | string | null
    lastSuccessAt?: Date | string | null
    circuitOpenUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIProviderHealthUncheckedCreateInput = {
    id?: string
    provider: string
    status?: string
    consecutiveFailures?: number
    lastFailureAt?: Date | string | null
    lastSuccessAt?: Date | string | null
    circuitOpenUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIProviderHealthUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    consecutiveFailures?: IntFieldUpdateOperationsInput | number
    lastFailureAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    circuitOpenUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIProviderHealthUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    consecutiveFailures?: IntFieldUpdateOperationsInput | number
    lastFailureAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    circuitOpenUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIProviderHealthCreateManyInput = {
    id?: string
    provider: string
    status?: string
    consecutiveFailures?: number
    lastFailureAt?: Date | string | null
    lastSuccessAt?: Date | string | null
    circuitOpenUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIProviderHealthUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    consecutiveFailures?: IntFieldUpdateOperationsInput | number
    lastFailureAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    circuitOpenUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIProviderHealthUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    consecutiveFailures?: IntFieldUpdateOperationsInput | number
    lastFailureAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    circuitOpenUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type basiq_usersCreateInput = {
    id?: string
    basiq_user_id: string
    email: string
    mobile?: string | null
    connection_status?: string | null
    consent_id?: string | null
    consent_status?: string | null
    consent_expires_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutBasiq_usersInput
    bank_connections?: bank_connectionsCreateNestedManyWithoutBasiq_userInput
    bank_accounts?: bank_accountsCreateNestedManyWithoutBasiq_userInput
  }

  export type basiq_usersUncheckedCreateInput = {
    id?: string
    user_id: string
    basiq_user_id: string
    email: string
    mobile?: string | null
    connection_status?: string | null
    consent_id?: string | null
    consent_status?: string | null
    consent_expires_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    bank_connections?: bank_connectionsUncheckedCreateNestedManyWithoutBasiq_userInput
    bank_accounts?: bank_accountsUncheckedCreateNestedManyWithoutBasiq_userInput
  }

  export type basiq_usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    connection_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_id?: NullableStringFieldUpdateOperationsInput | string | null
    consent_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBasiq_usersNestedInput
    bank_connections?: bank_connectionsUpdateManyWithoutBasiq_userNestedInput
    bank_accounts?: bank_accountsUpdateManyWithoutBasiq_userNestedInput
  }

  export type basiq_usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    basiq_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    connection_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_id?: NullableStringFieldUpdateOperationsInput | string | null
    consent_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bank_connections?: bank_connectionsUncheckedUpdateManyWithoutBasiq_userNestedInput
    bank_accounts?: bank_accountsUncheckedUpdateManyWithoutBasiq_userNestedInput
  }

  export type basiq_usersCreateManyInput = {
    id?: string
    user_id: string
    basiq_user_id: string
    email: string
    mobile?: string | null
    connection_status?: string | null
    consent_id?: string | null
    consent_status?: string | null
    consent_expires_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type basiq_usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    connection_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_id?: NullableStringFieldUpdateOperationsInput | string | null
    consent_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type basiq_usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    basiq_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    connection_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_id?: NullableStringFieldUpdateOperationsInput | string | null
    consent_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bank_connectionsCreateInput = {
    id?: string
    connection_id: string
    institution_id: string
    institution_name: string
    institution_short_name?: string | null
    institution_logo_url?: string | null
    status?: string | null
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    basiq_user: basiq_usersCreateNestedOneWithoutBank_connectionsInput
    bank_accounts?: bank_accountsCreateNestedManyWithoutConnectionInput
  }

  export type bank_connectionsUncheckedCreateInput = {
    id?: string
    basiq_user_id: string
    connection_id: string
    institution_id: string
    institution_name: string
    institution_short_name?: string | null
    institution_logo_url?: string | null
    status?: string | null
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    bank_accounts?: bank_accountsUncheckedCreateNestedManyWithoutConnectionInput
  }

  export type bank_connectionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    institution_id?: StringFieldUpdateOperationsInput | string
    institution_name?: StringFieldUpdateOperationsInput | string
    institution_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    institution_logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    basiq_user?: basiq_usersUpdateOneRequiredWithoutBank_connectionsNestedInput
    bank_accounts?: bank_accountsUpdateManyWithoutConnectionNestedInput
  }

  export type bank_connectionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_user_id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    institution_id?: StringFieldUpdateOperationsInput | string
    institution_name?: StringFieldUpdateOperationsInput | string
    institution_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    institution_logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bank_accounts?: bank_accountsUncheckedUpdateManyWithoutConnectionNestedInput
  }

  export type bank_connectionsCreateManyInput = {
    id?: string
    basiq_user_id: string
    connection_id: string
    institution_id: string
    institution_name: string
    institution_short_name?: string | null
    institution_logo_url?: string | null
    status?: string | null
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type bank_connectionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    institution_id?: StringFieldUpdateOperationsInput | string
    institution_name?: StringFieldUpdateOperationsInput | string
    institution_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    institution_logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bank_connectionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_user_id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    institution_id?: StringFieldUpdateOperationsInput | string
    institution_name?: StringFieldUpdateOperationsInput | string
    institution_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    institution_logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bank_accountsCreateInput = {
    id?: string
    basiq_account_id: string
    account_holder?: string | null
    account_number?: string | null
    bsb?: string | null
    institution_name?: string | null
    account_type?: string | null
    account_name?: string | null
    balance_available?: Decimal | DecimalJsLike | number | string | null
    balance_current?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    is_business_account?: boolean
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    basiq_user: basiq_usersCreateNestedOneWithoutBank_accountsInput
    connection: bank_connectionsCreateNestedOneWithoutBank_accountsInput
    bank_transactions?: bank_transactionsCreateNestedManyWithoutBank_accountInput
  }

  export type bank_accountsUncheckedCreateInput = {
    id?: string
    basiq_user_id: string
    connection_id: string
    basiq_account_id: string
    account_holder?: string | null
    account_number?: string | null
    bsb?: string | null
    institution_name?: string | null
    account_type?: string | null
    account_name?: string | null
    balance_available?: Decimal | DecimalJsLike | number | string | null
    balance_current?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    is_business_account?: boolean
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    bank_transactions?: bank_transactionsUncheckedCreateNestedManyWithoutBank_accountInput
  }

  export type bank_accountsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_account_id?: StringFieldUpdateOperationsInput | string
    account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bsb?: NullableStringFieldUpdateOperationsInput | string | null
    institution_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    balance_available?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balance_current?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_account?: BoolFieldUpdateOperationsInput | boolean
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    basiq_user?: basiq_usersUpdateOneRequiredWithoutBank_accountsNestedInput
    connection?: bank_connectionsUpdateOneRequiredWithoutBank_accountsNestedInput
    bank_transactions?: bank_transactionsUpdateManyWithoutBank_accountNestedInput
  }

  export type bank_accountsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_user_id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    basiq_account_id?: StringFieldUpdateOperationsInput | string
    account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bsb?: NullableStringFieldUpdateOperationsInput | string | null
    institution_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    balance_available?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balance_current?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_account?: BoolFieldUpdateOperationsInput | boolean
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bank_transactions?: bank_transactionsUncheckedUpdateManyWithoutBank_accountNestedInput
  }

  export type bank_accountsCreateManyInput = {
    id?: string
    basiq_user_id: string
    connection_id: string
    basiq_account_id: string
    account_holder?: string | null
    account_number?: string | null
    bsb?: string | null
    institution_name?: string | null
    account_type?: string | null
    account_name?: string | null
    balance_available?: Decimal | DecimalJsLike | number | string | null
    balance_current?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    is_business_account?: boolean
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type bank_accountsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_account_id?: StringFieldUpdateOperationsInput | string
    account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bsb?: NullableStringFieldUpdateOperationsInput | string | null
    institution_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    balance_available?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balance_current?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_account?: BoolFieldUpdateOperationsInput | boolean
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bank_accountsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_user_id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    basiq_account_id?: StringFieldUpdateOperationsInput | string
    account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bsb?: NullableStringFieldUpdateOperationsInput | string | null
    institution_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    balance_available?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balance_current?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_account?: BoolFieldUpdateOperationsInput | boolean
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bank_transactionsCreateInput = {
    id?: string
    basiq_transaction_id: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    transaction_date: Date | string
    post_date?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    transaction_type?: string | null
    direction?: string | null
    category?: string | null
    subcategory?: string | null
    merchant_name?: string | null
    status?: string | null
    is_business_expense?: boolean
    tax_category?: string | null
    gst_amount?: Decimal | DecimalJsLike | number | string | null
    receipt_id?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    bank_account: bank_accountsCreateNestedOneWithoutBank_transactionsInput
  }

  export type bank_transactionsUncheckedCreateInput = {
    id?: string
    bank_account_id: string
    basiq_transaction_id: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    transaction_date: Date | string
    post_date?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    transaction_type?: string | null
    direction?: string | null
    category?: string | null
    subcategory?: string | null
    merchant_name?: string | null
    status?: string | null
    is_business_expense?: boolean
    tax_category?: string | null
    gst_amount?: Decimal | DecimalJsLike | number | string | null
    receipt_id?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type bank_transactionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_transaction_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    post_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transaction_type?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_expense?: BoolFieldUpdateOperationsInput | boolean
    tax_category?: NullableStringFieldUpdateOperationsInput | string | null
    gst_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    receipt_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bank_account?: bank_accountsUpdateOneRequiredWithoutBank_transactionsNestedInput
  }

  export type bank_transactionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_account_id?: StringFieldUpdateOperationsInput | string
    basiq_transaction_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    post_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transaction_type?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_expense?: BoolFieldUpdateOperationsInput | boolean
    tax_category?: NullableStringFieldUpdateOperationsInput | string | null
    gst_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    receipt_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bank_transactionsCreateManyInput = {
    id?: string
    bank_account_id: string
    basiq_transaction_id: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    transaction_date: Date | string
    post_date?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    transaction_type?: string | null
    direction?: string | null
    category?: string | null
    subcategory?: string | null
    merchant_name?: string | null
    status?: string | null
    is_business_expense?: boolean
    tax_category?: string | null
    gst_amount?: Decimal | DecimalJsLike | number | string | null
    receipt_id?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type bank_transactionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_transaction_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    post_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transaction_type?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_expense?: BoolFieldUpdateOperationsInput | boolean
    tax_category?: NullableStringFieldUpdateOperationsInput | string | null
    gst_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    receipt_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bank_transactionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_account_id?: StringFieldUpdateOperationsInput | string
    basiq_transaction_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    post_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transaction_type?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_expense?: BoolFieldUpdateOperationsInput | boolean
    tax_category?: NullableStringFieldUpdateOperationsInput | string | null
    gst_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    receipt_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type basiq_webhooksCreateInput = {
    id?: string
    webhook_id?: string | null
    event_type: string
    resource_type?: string | null
    resource_id?: string | null
    payload: JsonNullValueInput | InputJsonValue
    status?: string | null
    processed_at?: Date | string | null
    error_message?: string | null
    retry_count?: number
    created_at?: Date | string
  }

  export type basiq_webhooksUncheckedCreateInput = {
    id?: string
    webhook_id?: string | null
    event_type: string
    resource_type?: string | null
    resource_id?: string | null
    payload: JsonNullValueInput | InputJsonValue
    status?: string | null
    processed_at?: Date | string | null
    error_message?: string | null
    retry_count?: number
    created_at?: Date | string
  }

  export type basiq_webhooksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhook_id?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: StringFieldUpdateOperationsInput | string
    resource_type?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    retry_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type basiq_webhooksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhook_id?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: StringFieldUpdateOperationsInput | string
    resource_type?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    retry_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type basiq_webhooksCreateManyInput = {
    id?: string
    webhook_id?: string | null
    event_type: string
    resource_type?: string | null
    resource_id?: string | null
    payload: JsonNullValueInput | InputJsonValue
    status?: string | null
    processed_at?: Date | string | null
    error_message?: string | null
    retry_count?: number
    created_at?: Date | string
  }

  export type basiq_webhooksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhook_id?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: StringFieldUpdateOperationsInput | string
    resource_type?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    retry_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type basiq_webhooksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhook_id?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: StringFieldUpdateOperationsInput | string
    resource_type?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    retry_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type basiq_api_logsCreateInput = {
    id?: string
    endpoint: string
    method: string
    request_body?: NullableJsonNullValueInput | InputJsonValue
    response_status?: number | null
    response_body?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    duration_ms?: number | null
    created_at?: Date | string
    user?: UserCreateNestedOneWithoutBasiq_api_logsInput
  }

  export type basiq_api_logsUncheckedCreateInput = {
    id?: string
    user_id?: string | null
    endpoint: string
    method: string
    request_body?: NullableJsonNullValueInput | InputJsonValue
    response_status?: number | null
    response_body?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    duration_ms?: number | null
    created_at?: Date | string
  }

  export type basiq_api_logsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    request_body?: NullableJsonNullValueInput | InputJsonValue
    response_status?: NullableIntFieldUpdateOperationsInput | number | null
    response_body?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutBasiq_api_logsNestedInput
  }

  export type basiq_api_logsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    request_body?: NullableJsonNullValueInput | InputJsonValue
    response_status?: NullableIntFieldUpdateOperationsInput | number | null
    response_body?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type basiq_api_logsCreateManyInput = {
    id?: string
    user_id?: string | null
    endpoint: string
    method: string
    request_body?: NullableJsonNullValueInput | InputJsonValue
    response_status?: number | null
    response_body?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    duration_ms?: number | null
    created_at?: Date | string
  }

  export type basiq_api_logsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    request_body?: NullableJsonNullValueInput | InputJsonValue
    response_status?: NullableIntFieldUpdateOperationsInput | number | null
    response_body?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type basiq_api_logsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    request_body?: NullableJsonNullValueInput | InputJsonValue
    response_status?: NullableIntFieldUpdateOperationsInput | number | null
    response_body?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptCreateInput = {
    id?: string
    merchant?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    gstAmount?: Decimal | DecimalJsLike | number | string | null
    date: Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    aiProcessed?: boolean
    aiConfidence?: Decimal | DecimalJsLike | number | string | null
    aiProvider?: string | null
    aiModel?: string | null
    processingStatus?: $Enums.ReceiptStatus
    abn?: string | null
    taxInvoiceNumber?: string | null
    taxCategory?: string | null
    isGstRegistered?: boolean
    matchedTransactionId?: string | null
    matchConfidence?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReceiptsInput
  }

  export type ReceiptUncheckedCreateInput = {
    id?: string
    userId: string
    merchant?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    gstAmount?: Decimal | DecimalJsLike | number | string | null
    date: Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    aiProcessed?: boolean
    aiConfidence?: Decimal | DecimalJsLike | number | string | null
    aiProvider?: string | null
    aiModel?: string | null
    processingStatus?: $Enums.ReceiptStatus
    abn?: string | null
    taxInvoiceNumber?: string | null
    taxCategory?: string | null
    isGstRegistered?: boolean
    matchedTransactionId?: string | null
    matchConfidence?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceiptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gstAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    processingStatus?: EnumReceiptStatusFieldUpdateOperationsInput | $Enums.ReceiptStatus
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    taxInvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxCategory?: NullableStringFieldUpdateOperationsInput | string | null
    isGstRegistered?: BoolFieldUpdateOperationsInput | boolean
    matchedTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReceiptsNestedInput
  }

  export type ReceiptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gstAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    processingStatus?: EnumReceiptStatusFieldUpdateOperationsInput | $Enums.ReceiptStatus
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    taxInvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxCategory?: NullableStringFieldUpdateOperationsInput | string | null
    isGstRegistered?: BoolFieldUpdateOperationsInput | boolean
    matchedTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptCreateManyInput = {
    id?: string
    userId: string
    merchant?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    gstAmount?: Decimal | DecimalJsLike | number | string | null
    date: Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    aiProcessed?: boolean
    aiConfidence?: Decimal | DecimalJsLike | number | string | null
    aiProvider?: string | null
    aiModel?: string | null
    processingStatus?: $Enums.ReceiptStatus
    abn?: string | null
    taxInvoiceNumber?: string | null
    taxCategory?: string | null
    isGstRegistered?: boolean
    matchedTransactionId?: string | null
    matchConfidence?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceiptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gstAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    processingStatus?: EnumReceiptStatusFieldUpdateOperationsInput | $Enums.ReceiptStatus
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    taxInvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxCategory?: NullableStringFieldUpdateOperationsInput | string | null
    isGstRegistered?: BoolFieldUpdateOperationsInput | boolean
    matchedTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gstAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    processingStatus?: EnumReceiptStatusFieldUpdateOperationsInput | $Enums.ReceiptStatus
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    taxInvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxCategory?: NullableStringFieldUpdateOperationsInput | string | null
    isGstRegistered?: BoolFieldUpdateOperationsInput | boolean
    matchedTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCreateInput = {
    id?: string
    name?: string | null
    monthlyBudget: Decimal | DecimalJsLike | number | string
    targetSavings?: Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: Decimal | DecimalJsLike | number | string | null
    predictions?: NullableJsonNullValueInput | InputJsonValue
    categoryLimits?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    aiProvider?: string | null
    aiModel?: string | null
    analysisPeriod?: string | null
    predictionPeriod?: string | null
    status?: $Enums.BudgetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBudgetsInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateInput = {
    id?: string
    userId: string
    name?: string | null
    monthlyBudget: Decimal | DecimalJsLike | number | string
    targetSavings?: Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: Decimal | DecimalJsLike | number | string | null
    predictions?: NullableJsonNullValueInput | InputJsonValue
    categoryLimits?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    aiProvider?: string | null
    aiModel?: string | null
    analysisPeriod?: string | null
    predictionPeriod?: string | null
    status?: $Enums.BudgetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    predictions?: NullableJsonNullValueInput | InputJsonValue
    categoryLimits?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    analysisPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    predictionPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBudgetsNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    predictions?: NullableJsonNullValueInput | InputJsonValue
    categoryLimits?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    analysisPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    predictionPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetCreateManyInput = {
    id?: string
    userId: string
    name?: string | null
    monthlyBudget: Decimal | DecimalJsLike | number | string
    targetSavings?: Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: Decimal | DecimalJsLike | number | string | null
    predictions?: NullableJsonNullValueInput | InputJsonValue
    categoryLimits?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    aiProvider?: string | null
    aiModel?: string | null
    analysisPeriod?: string | null
    predictionPeriod?: string | null
    status?: $Enums.BudgetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    predictions?: NullableJsonNullValueInput | InputJsonValue
    categoryLimits?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    analysisPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    predictionPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    predictions?: NullableJsonNullValueInput | InputJsonValue
    categoryLimits?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    analysisPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    predictionPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetTrackingCreateInput = {
    id?: string
    month: number
    year: number
    predictedAmount: Decimal | DecimalJsLike | number | string
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    category?: string | null
    createdAt?: Date | string
    budget: BudgetCreateNestedOneWithoutBudgetTrackingInput
    user: UserCreateNestedOneWithoutBudgetTrackingInput
  }

  export type BudgetTrackingUncheckedCreateInput = {
    id?: string
    budgetId: string
    userId: string
    month: number
    year: number
    predictedAmount: Decimal | DecimalJsLike | number | string
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    category?: string | null
    createdAt?: Date | string
  }

  export type BudgetTrackingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    predictedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: BudgetUpdateOneRequiredWithoutBudgetTrackingNestedInput
    user?: UserUpdateOneRequiredWithoutBudgetTrackingNestedInput
  }

  export type BudgetTrackingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    predictedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetTrackingCreateManyInput = {
    id?: string
    budgetId: string
    userId: string
    month: number
    year: number
    predictedAmount: Decimal | DecimalJsLike | number | string
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    category?: string | null
    createdAt?: Date | string
  }

  export type BudgetTrackingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    predictedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetTrackingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    predictedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialInsightCreateInput = {
    id?: string
    insightType: string
    category?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: FinancialInsightCreatesourceDataIdsInput | string[]
    provider?: string | null
    model?: string | null
    title?: string | null
    description?: string | null
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    priority?: $Enums.InsightPriority
    isActive?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutFinancialInsightsInput
  }

  export type FinancialInsightUncheckedCreateInput = {
    id?: string
    userId: string
    insightType: string
    category?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: FinancialInsightCreatesourceDataIdsInput | string[]
    provider?: string | null
    model?: string | null
    title?: string | null
    description?: string | null
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    priority?: $Enums.InsightPriority
    isActive?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type FinancialInsightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: FinancialInsightUpdatesourceDataIdsInput | string[]
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    priority?: EnumInsightPriorityFieldUpdateOperationsInput | $Enums.InsightPriority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutFinancialInsightsNestedInput
  }

  export type FinancialInsightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: FinancialInsightUpdatesourceDataIdsInput | string[]
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    priority?: EnumInsightPriorityFieldUpdateOperationsInput | $Enums.InsightPriority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FinancialInsightCreateManyInput = {
    id?: string
    userId: string
    insightType: string
    category?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: FinancialInsightCreatesourceDataIdsInput | string[]
    provider?: string | null
    model?: string | null
    title?: string | null
    description?: string | null
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    priority?: $Enums.InsightPriority
    isActive?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type FinancialInsightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: FinancialInsightUpdatesourceDataIdsInput | string[]
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    priority?: EnumInsightPriorityFieldUpdateOperationsInput | $Enums.InsightPriority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FinancialInsightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: FinancialInsightUpdatesourceDataIdsInput | string[]
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    priority?: EnumInsightPriorityFieldUpdateOperationsInput | $Enums.InsightPriority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GoalCreateInput = {
    id?: string
    title: string
    targetAmount: Decimal | DecimalJsLike | number | string
    currentAmount?: Decimal | DecimalJsLike | number | string
    targetDate: Date | string
    category?: string | null
    status?: $Enums.GoalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGoalsInput
  }

  export type GoalUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    targetAmount: Decimal | DecimalJsLike | number | string
    currentAmount?: Decimal | DecimalJsLike | number | string
    targetDate: Date | string
    category?: string | null
    status?: $Enums.GoalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGoalsNestedInput
  }

  export type GoalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalCreateManyInput = {
    id?: string
    userId: string
    title: string
    targetAmount: Decimal | DecimalJsLike | number | string
    currentAmount?: Decimal | DecimalJsLike | number | string
    targetDate: Date | string
    category?: string | null
    status?: $Enums.GoalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AMLTransactionMonitoringCreateInput = {
    id?: string
    transactionId?: string | null
    monitoringType: $Enums.AMLMonitoringType
    riskScore: Decimal | DecimalJsLike | number | string
    riskFactors?: AMLTransactionMonitoringCreateriskFactorsInput | string[]
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    patternType?: string | null
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    velocityScore?: Decimal | DecimalJsLike | number | string | null
    requiresReview?: boolean
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reportedToAUSTRAC?: boolean
    reportReference?: string | null
    reportedAt?: Date | string | null
    falsePositive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAmlMonitoringInput
  }

  export type AMLTransactionMonitoringUncheckedCreateInput = {
    id?: string
    userId: string
    transactionId?: string | null
    monitoringType: $Enums.AMLMonitoringType
    riskScore: Decimal | DecimalJsLike | number | string
    riskFactors?: AMLTransactionMonitoringCreateriskFactorsInput | string[]
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    patternType?: string | null
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    velocityScore?: Decimal | DecimalJsLike | number | string | null
    requiresReview?: boolean
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reportedToAUSTRAC?: boolean
    reportReference?: string | null
    reportedAt?: Date | string | null
    falsePositive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AMLTransactionMonitoringUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    monitoringType?: EnumAMLMonitoringTypeFieldUpdateOperationsInput | $Enums.AMLMonitoringType
    riskScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskFactors?: AMLTransactionMonitoringUpdateriskFactorsInput | string[]
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    patternType?: NullableStringFieldUpdateOperationsInput | string | null
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    velocityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportedToAUSTRAC?: BoolFieldUpdateOperationsInput | boolean
    reportReference?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    falsePositive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAmlMonitoringNestedInput
  }

  export type AMLTransactionMonitoringUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    monitoringType?: EnumAMLMonitoringTypeFieldUpdateOperationsInput | $Enums.AMLMonitoringType
    riskScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskFactors?: AMLTransactionMonitoringUpdateriskFactorsInput | string[]
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    patternType?: NullableStringFieldUpdateOperationsInput | string | null
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    velocityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportedToAUSTRAC?: BoolFieldUpdateOperationsInput | boolean
    reportReference?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    falsePositive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AMLTransactionMonitoringCreateManyInput = {
    id?: string
    userId: string
    transactionId?: string | null
    monitoringType: $Enums.AMLMonitoringType
    riskScore: Decimal | DecimalJsLike | number | string
    riskFactors?: AMLTransactionMonitoringCreateriskFactorsInput | string[]
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    patternType?: string | null
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    velocityScore?: Decimal | DecimalJsLike | number | string | null
    requiresReview?: boolean
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reportedToAUSTRAC?: boolean
    reportReference?: string | null
    reportedAt?: Date | string | null
    falsePositive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AMLTransactionMonitoringUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    monitoringType?: EnumAMLMonitoringTypeFieldUpdateOperationsInput | $Enums.AMLMonitoringType
    riskScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskFactors?: AMLTransactionMonitoringUpdateriskFactorsInput | string[]
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    patternType?: NullableStringFieldUpdateOperationsInput | string | null
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    velocityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportedToAUSTRAC?: BoolFieldUpdateOperationsInput | boolean
    reportReference?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    falsePositive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AMLTransactionMonitoringUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    monitoringType?: EnumAMLMonitoringTypeFieldUpdateOperationsInput | $Enums.AMLMonitoringType
    riskScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskFactors?: AMLTransactionMonitoringUpdateriskFactorsInput | string[]
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    patternType?: NullableStringFieldUpdateOperationsInput | string | null
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    velocityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportedToAUSTRAC?: BoolFieldUpdateOperationsInput | boolean
    reportReference?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    falsePositive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivacyConsentCreateInput = {
    id?: string
    consentType: $Enums.ConsentType
    consentVersion: string
    consentStatus?: $Enums.ConsentStatus
    consentDate?: Date | string | null
    expiryDate?: Date | string | null
    purposes?: PrivacyConsentCreatepurposesInput | string[]
    dataCategories?: PrivacyConsentCreatedataCategoriesInput | string[]
    thirdParties?: PrivacyConsentCreatethirdPartiesInput | string[]
    withdrawnAt?: Date | string | null
    withdrawalReason?: string | null
    legalBasis: string
    jurisdiction?: string
    ipAddress: string
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPrivacyConsentsInput
  }

  export type PrivacyConsentUncheckedCreateInput = {
    id?: string
    userId: string
    consentType: $Enums.ConsentType
    consentVersion: string
    consentStatus?: $Enums.ConsentStatus
    consentDate?: Date | string | null
    expiryDate?: Date | string | null
    purposes?: PrivacyConsentCreatepurposesInput | string[]
    dataCategories?: PrivacyConsentCreatedataCategoriesInput | string[]
    thirdParties?: PrivacyConsentCreatethirdPartiesInput | string[]
    withdrawnAt?: Date | string | null
    withdrawalReason?: string | null
    legalBasis: string
    jurisdiction?: string
    ipAddress: string
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivacyConsentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentType?: EnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType
    consentVersion?: StringFieldUpdateOperationsInput | string
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purposes?: PrivacyConsentUpdatepurposesInput | string[]
    dataCategories?: PrivacyConsentUpdatedataCategoriesInput | string[]
    thirdParties?: PrivacyConsentUpdatethirdPartiesInput | string[]
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasis?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPrivacyConsentsNestedInput
  }

  export type PrivacyConsentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    consentType?: EnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType
    consentVersion?: StringFieldUpdateOperationsInput | string
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purposes?: PrivacyConsentUpdatepurposesInput | string[]
    dataCategories?: PrivacyConsentUpdatedataCategoriesInput | string[]
    thirdParties?: PrivacyConsentUpdatethirdPartiesInput | string[]
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasis?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivacyConsentCreateManyInput = {
    id?: string
    userId: string
    consentType: $Enums.ConsentType
    consentVersion: string
    consentStatus?: $Enums.ConsentStatus
    consentDate?: Date | string | null
    expiryDate?: Date | string | null
    purposes?: PrivacyConsentCreatepurposesInput | string[]
    dataCategories?: PrivacyConsentCreatedataCategoriesInput | string[]
    thirdParties?: PrivacyConsentCreatethirdPartiesInput | string[]
    withdrawnAt?: Date | string | null
    withdrawalReason?: string | null
    legalBasis: string
    jurisdiction?: string
    ipAddress: string
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivacyConsentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentType?: EnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType
    consentVersion?: StringFieldUpdateOperationsInput | string
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purposes?: PrivacyConsentUpdatepurposesInput | string[]
    dataCategories?: PrivacyConsentUpdatedataCategoriesInput | string[]
    thirdParties?: PrivacyConsentUpdatethirdPartiesInput | string[]
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasis?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivacyConsentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    consentType?: EnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType
    consentVersion?: StringFieldUpdateOperationsInput | string
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purposes?: PrivacyConsentUpdatepurposesInput | string[]
    dataCategories?: PrivacyConsentUpdatedataCategoriesInput | string[]
    thirdParties?: PrivacyConsentUpdatethirdPartiesInput | string[]
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasis?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataAccessRequestCreateInput = {
    id?: string
    requestType: $Enums.DataRequestType
    requestStatus?: $Enums.DataRequestStatus
    requestDate?: Date | string
    requestDetails?: NullableJsonNullValueInput | InputJsonValue
    verificationMethod?: string | null
    verifiedAt?: Date | string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    completedAt?: Date | string | null
    responseMethod?: string | null
    responseUrl?: string | null
    responseExpiryDate?: Date | string | null
    dueDate: Date | string
    extensionReason?: string | null
    extendedDueDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDataAccessRequestsInput
  }

  export type DataAccessRequestUncheckedCreateInput = {
    id?: string
    userId: string
    requestType: $Enums.DataRequestType
    requestStatus?: $Enums.DataRequestStatus
    requestDate?: Date | string
    requestDetails?: NullableJsonNullValueInput | InputJsonValue
    verificationMethod?: string | null
    verifiedAt?: Date | string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    completedAt?: Date | string | null
    responseMethod?: string | null
    responseUrl?: string | null
    responseExpiryDate?: Date | string | null
    dueDate: Date | string
    extensionReason?: string | null
    extendedDueDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataAccessRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumDataRequestTypeFieldUpdateOperationsInput | $Enums.DataRequestType
    requestStatus?: EnumDataRequestStatusFieldUpdateOperationsInput | $Enums.DataRequestStatus
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requestDetails?: NullableJsonNullValueInput | InputJsonValue
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseMethod?: NullableStringFieldUpdateOperationsInput | string | null
    responseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    responseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDataAccessRequestsNestedInput
  }

  export type DataAccessRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumDataRequestTypeFieldUpdateOperationsInput | $Enums.DataRequestType
    requestStatus?: EnumDataRequestStatusFieldUpdateOperationsInput | $Enums.DataRequestStatus
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requestDetails?: NullableJsonNullValueInput | InputJsonValue
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseMethod?: NullableStringFieldUpdateOperationsInput | string | null
    responseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    responseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataAccessRequestCreateManyInput = {
    id?: string
    userId: string
    requestType: $Enums.DataRequestType
    requestStatus?: $Enums.DataRequestStatus
    requestDate?: Date | string
    requestDetails?: NullableJsonNullValueInput | InputJsonValue
    verificationMethod?: string | null
    verifiedAt?: Date | string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    completedAt?: Date | string | null
    responseMethod?: string | null
    responseUrl?: string | null
    responseExpiryDate?: Date | string | null
    dueDate: Date | string
    extensionReason?: string | null
    extendedDueDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataAccessRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumDataRequestTypeFieldUpdateOperationsInput | $Enums.DataRequestType
    requestStatus?: EnumDataRequestStatusFieldUpdateOperationsInput | $Enums.DataRequestStatus
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requestDetails?: NullableJsonNullValueInput | InputJsonValue
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseMethod?: NullableStringFieldUpdateOperationsInput | string | null
    responseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    responseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataAccessRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumDataRequestTypeFieldUpdateOperationsInput | $Enums.DataRequestType
    requestStatus?: EnumDataRequestStatusFieldUpdateOperationsInput | $Enums.DataRequestStatus
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requestDetails?: NullableJsonNullValueInput | InputJsonValue
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseMethod?: NullableStringFieldUpdateOperationsInput | string | null
    responseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    responseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type APRAIncidentReportCreateInput = {
    id?: string
    incidentType: $Enums.IncidentType
    severity: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    title: string
    description: string
    detectedAt: Date | string
    reportedAt?: Date | string | null
    resolvedAt?: Date | string | null
    affectedUsers?: number
    affectedSystems?: APRAIncidentReportCreateaffectedSystemsInput | string[]
    dataCompromised?: boolean
    financialImpact?: Decimal | DecimalJsLike | number | string | null
    immediateActions?: NullableJsonNullValueInput | InputJsonValue
    rootCause?: string | null
    remediation?: NullableJsonNullValueInput | InputJsonValue
    preventiveMeasures?: NullableJsonNullValueInput | InputJsonValue
    reportedToAPRA?: boolean
    apraReference?: string | null
    reportedToOAIC?: boolean
    oaicReference?: string | null
    bcpActivated?: boolean
    serviceDowntime?: number | null
    dataRecoveryTime?: number | null
    reportedBy?: string | null
    responsibleTeam?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type APRAIncidentReportUncheckedCreateInput = {
    id?: string
    incidentType: $Enums.IncidentType
    severity: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    title: string
    description: string
    detectedAt: Date | string
    reportedAt?: Date | string | null
    resolvedAt?: Date | string | null
    affectedUsers?: number
    affectedSystems?: APRAIncidentReportCreateaffectedSystemsInput | string[]
    dataCompromised?: boolean
    financialImpact?: Decimal | DecimalJsLike | number | string | null
    immediateActions?: NullableJsonNullValueInput | InputJsonValue
    rootCause?: string | null
    remediation?: NullableJsonNullValueInput | InputJsonValue
    preventiveMeasures?: NullableJsonNullValueInput | InputJsonValue
    reportedToAPRA?: boolean
    apraReference?: string | null
    reportedToOAIC?: boolean
    oaicReference?: string | null
    bcpActivated?: boolean
    serviceDowntime?: number | null
    dataRecoveryTime?: number | null
    reportedBy?: string | null
    responsibleTeam?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type APRAIncidentReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentType?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affectedUsers?: IntFieldUpdateOperationsInput | number
    affectedSystems?: APRAIncidentReportUpdateaffectedSystemsInput | string[]
    dataCompromised?: BoolFieldUpdateOperationsInput | boolean
    financialImpact?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    immediateActions?: NullableJsonNullValueInput | InputJsonValue
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    remediation?: NullableJsonNullValueInput | InputJsonValue
    preventiveMeasures?: NullableJsonNullValueInput | InputJsonValue
    reportedToAPRA?: BoolFieldUpdateOperationsInput | boolean
    apraReference?: NullableStringFieldUpdateOperationsInput | string | null
    reportedToOAIC?: BoolFieldUpdateOperationsInput | boolean
    oaicReference?: NullableStringFieldUpdateOperationsInput | string | null
    bcpActivated?: BoolFieldUpdateOperationsInput | boolean
    serviceDowntime?: NullableIntFieldUpdateOperationsInput | number | null
    dataRecoveryTime?: NullableIntFieldUpdateOperationsInput | number | null
    reportedBy?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleTeam?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type APRAIncidentReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentType?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affectedUsers?: IntFieldUpdateOperationsInput | number
    affectedSystems?: APRAIncidentReportUpdateaffectedSystemsInput | string[]
    dataCompromised?: BoolFieldUpdateOperationsInput | boolean
    financialImpact?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    immediateActions?: NullableJsonNullValueInput | InputJsonValue
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    remediation?: NullableJsonNullValueInput | InputJsonValue
    preventiveMeasures?: NullableJsonNullValueInput | InputJsonValue
    reportedToAPRA?: BoolFieldUpdateOperationsInput | boolean
    apraReference?: NullableStringFieldUpdateOperationsInput | string | null
    reportedToOAIC?: BoolFieldUpdateOperationsInput | boolean
    oaicReference?: NullableStringFieldUpdateOperationsInput | string | null
    bcpActivated?: BoolFieldUpdateOperationsInput | boolean
    serviceDowntime?: NullableIntFieldUpdateOperationsInput | number | null
    dataRecoveryTime?: NullableIntFieldUpdateOperationsInput | number | null
    reportedBy?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleTeam?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type APRAIncidentReportCreateManyInput = {
    id?: string
    incidentType: $Enums.IncidentType
    severity: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    title: string
    description: string
    detectedAt: Date | string
    reportedAt?: Date | string | null
    resolvedAt?: Date | string | null
    affectedUsers?: number
    affectedSystems?: APRAIncidentReportCreateaffectedSystemsInput | string[]
    dataCompromised?: boolean
    financialImpact?: Decimal | DecimalJsLike | number | string | null
    immediateActions?: NullableJsonNullValueInput | InputJsonValue
    rootCause?: string | null
    remediation?: NullableJsonNullValueInput | InputJsonValue
    preventiveMeasures?: NullableJsonNullValueInput | InputJsonValue
    reportedToAPRA?: boolean
    apraReference?: string | null
    reportedToOAIC?: boolean
    oaicReference?: string | null
    bcpActivated?: boolean
    serviceDowntime?: number | null
    dataRecoveryTime?: number | null
    reportedBy?: string | null
    responsibleTeam?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type APRAIncidentReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentType?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affectedUsers?: IntFieldUpdateOperationsInput | number
    affectedSystems?: APRAIncidentReportUpdateaffectedSystemsInput | string[]
    dataCompromised?: BoolFieldUpdateOperationsInput | boolean
    financialImpact?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    immediateActions?: NullableJsonNullValueInput | InputJsonValue
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    remediation?: NullableJsonNullValueInput | InputJsonValue
    preventiveMeasures?: NullableJsonNullValueInput | InputJsonValue
    reportedToAPRA?: BoolFieldUpdateOperationsInput | boolean
    apraReference?: NullableStringFieldUpdateOperationsInput | string | null
    reportedToOAIC?: BoolFieldUpdateOperationsInput | boolean
    oaicReference?: NullableStringFieldUpdateOperationsInput | string | null
    bcpActivated?: BoolFieldUpdateOperationsInput | boolean
    serviceDowntime?: NullableIntFieldUpdateOperationsInput | number | null
    dataRecoveryTime?: NullableIntFieldUpdateOperationsInput | number | null
    reportedBy?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleTeam?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type APRAIncidentReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentType?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affectedUsers?: IntFieldUpdateOperationsInput | number
    affectedSystems?: APRAIncidentReportUpdateaffectedSystemsInput | string[]
    dataCompromised?: BoolFieldUpdateOperationsInput | boolean
    financialImpact?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    immediateActions?: NullableJsonNullValueInput | InputJsonValue
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    remediation?: NullableJsonNullValueInput | InputJsonValue
    preventiveMeasures?: NullableJsonNullValueInput | InputJsonValue
    reportedToAPRA?: BoolFieldUpdateOperationsInput | boolean
    apraReference?: NullableStringFieldUpdateOperationsInput | string | null
    reportedToOAIC?: BoolFieldUpdateOperationsInput | boolean
    oaicReference?: NullableStringFieldUpdateOperationsInput | string | null
    bcpActivated?: BoolFieldUpdateOperationsInput | boolean
    serviceDowntime?: NullableIntFieldUpdateOperationsInput | number | null
    dataRecoveryTime?: NullableIntFieldUpdateOperationsInput | number | null
    reportedBy?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleTeam?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GSTTransactionDetailCreateInput = {
    id?: string
    transactionId: string
    invoiceId?: string | null
    baseAmount: Decimal | DecimalJsLike | number | string
    gstRate?: Decimal | DecimalJsLike | number | string
    gstAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    taxCategory: string
    gstTreatment: $Enums.GSTTreatment
    inputTaxCredit?: boolean
    supplierABN?: string | null
    supplierName?: string | null
    isGSTRegistered?: boolean
    basReportingCode?: string | null
    taxPeriod: string
    reportedInBAS?: boolean
    basReference?: string | null
    validated?: boolean
    validationErrors?: GSTTransactionDetailCreatevalidationErrorsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GSTTransactionDetailUncheckedCreateInput = {
    id?: string
    transactionId: string
    invoiceId?: string | null
    baseAmount: Decimal | DecimalJsLike | number | string
    gstRate?: Decimal | DecimalJsLike | number | string
    gstAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    taxCategory: string
    gstTreatment: $Enums.GSTTreatment
    inputTaxCredit?: boolean
    supplierABN?: string | null
    supplierName?: string | null
    isGSTRegistered?: boolean
    basReportingCode?: string | null
    taxPeriod: string
    reportedInBAS?: boolean
    basReference?: string | null
    validated?: boolean
    validationErrors?: GSTTransactionDetailCreatevalidationErrorsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GSTTransactionDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    baseAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gstRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gstAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxCategory?: StringFieldUpdateOperationsInput | string
    gstTreatment?: EnumGSTTreatmentFieldUpdateOperationsInput | $Enums.GSTTreatment
    inputTaxCredit?: BoolFieldUpdateOperationsInput | boolean
    supplierABN?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    isGSTRegistered?: BoolFieldUpdateOperationsInput | boolean
    basReportingCode?: NullableStringFieldUpdateOperationsInput | string | null
    taxPeriod?: StringFieldUpdateOperationsInput | string
    reportedInBAS?: BoolFieldUpdateOperationsInput | boolean
    basReference?: NullableStringFieldUpdateOperationsInput | string | null
    validated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: GSTTransactionDetailUpdatevalidationErrorsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GSTTransactionDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    baseAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gstRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gstAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxCategory?: StringFieldUpdateOperationsInput | string
    gstTreatment?: EnumGSTTreatmentFieldUpdateOperationsInput | $Enums.GSTTreatment
    inputTaxCredit?: BoolFieldUpdateOperationsInput | boolean
    supplierABN?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    isGSTRegistered?: BoolFieldUpdateOperationsInput | boolean
    basReportingCode?: NullableStringFieldUpdateOperationsInput | string | null
    taxPeriod?: StringFieldUpdateOperationsInput | string
    reportedInBAS?: BoolFieldUpdateOperationsInput | boolean
    basReference?: NullableStringFieldUpdateOperationsInput | string | null
    validated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: GSTTransactionDetailUpdatevalidationErrorsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GSTTransactionDetailCreateManyInput = {
    id?: string
    transactionId: string
    invoiceId?: string | null
    baseAmount: Decimal | DecimalJsLike | number | string
    gstRate?: Decimal | DecimalJsLike | number | string
    gstAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    taxCategory: string
    gstTreatment: $Enums.GSTTreatment
    inputTaxCredit?: boolean
    supplierABN?: string | null
    supplierName?: string | null
    isGSTRegistered?: boolean
    basReportingCode?: string | null
    taxPeriod: string
    reportedInBAS?: boolean
    basReference?: string | null
    validated?: boolean
    validationErrors?: GSTTransactionDetailCreatevalidationErrorsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GSTTransactionDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    baseAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gstRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gstAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxCategory?: StringFieldUpdateOperationsInput | string
    gstTreatment?: EnumGSTTreatmentFieldUpdateOperationsInput | $Enums.GSTTreatment
    inputTaxCredit?: BoolFieldUpdateOperationsInput | boolean
    supplierABN?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    isGSTRegistered?: BoolFieldUpdateOperationsInput | boolean
    basReportingCode?: NullableStringFieldUpdateOperationsInput | string | null
    taxPeriod?: StringFieldUpdateOperationsInput | string
    reportedInBAS?: BoolFieldUpdateOperationsInput | boolean
    basReference?: NullableStringFieldUpdateOperationsInput | string | null
    validated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: GSTTransactionDetailUpdatevalidationErrorsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GSTTransactionDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    baseAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gstRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gstAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxCategory?: StringFieldUpdateOperationsInput | string
    gstTreatment?: EnumGSTTreatmentFieldUpdateOperationsInput | $Enums.GSTTreatment
    inputTaxCredit?: BoolFieldUpdateOperationsInput | boolean
    supplierABN?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    isGSTRegistered?: BoolFieldUpdateOperationsInput | boolean
    basReportingCode?: NullableStringFieldUpdateOperationsInput | string | null
    taxPeriod?: StringFieldUpdateOperationsInput | string
    reportedInBAS?: BoolFieldUpdateOperationsInput | boolean
    basReference?: NullableStringFieldUpdateOperationsInput | string | null
    validated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: GSTTransactionDetailUpdatevalidationErrorsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceConfigurationCreateInput = {
    id?: string
    configType: string
    configData: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    amlThresholds?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: number | null
    consentExpireDays?: number | null
    incidentReportHours?: number | null
    backupFrequency?: string | null
    gstRate?: Decimal | DecimalJsLike | number | string | null
    basReportingCodes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceConfigurationUncheckedCreateInput = {
    id?: string
    configType: string
    configData: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    amlThresholds?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: number | null
    consentExpireDays?: number | null
    incidentReportHours?: number | null
    backupFrequency?: string | null
    gstRate?: Decimal | DecimalJsLike | number | string | null
    basReportingCodes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceConfigurationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    configType?: StringFieldUpdateOperationsInput | string
    configData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    amlThresholds?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    consentExpireDays?: NullableIntFieldUpdateOperationsInput | number | null
    incidentReportHours?: NullableIntFieldUpdateOperationsInput | number | null
    backupFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    gstRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basReportingCodes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceConfigurationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    configType?: StringFieldUpdateOperationsInput | string
    configData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    amlThresholds?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    consentExpireDays?: NullableIntFieldUpdateOperationsInput | number | null
    incidentReportHours?: NullableIntFieldUpdateOperationsInput | number | null
    backupFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    gstRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basReportingCodes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceConfigurationCreateManyInput = {
    id?: string
    configType: string
    configData: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    amlThresholds?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: number | null
    consentExpireDays?: number | null
    incidentReportHours?: number | null
    backupFrequency?: string | null
    gstRate?: Decimal | DecimalJsLike | number | string | null
    basReportingCodes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceConfigurationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    configType?: StringFieldUpdateOperationsInput | string
    configData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    amlThresholds?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    consentExpireDays?: NullableIntFieldUpdateOperationsInput | number | null
    incidentReportHours?: NullableIntFieldUpdateOperationsInput | number | null
    backupFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    gstRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basReportingCodes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceConfigurationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    configType?: StringFieldUpdateOperationsInput | string
    configData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    amlThresholds?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    consentExpireDays?: NullableIntFieldUpdateOperationsInput | number | null
    incidentReportHours?: NullableIntFieldUpdateOperationsInput | number | null
    backupFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    gstRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basReportingCodes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumTaxResidencyFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxResidency | EnumTaxResidencyFieldRefInput<$PrismaModel>
    in?: $Enums.TaxResidency[] | ListEnumTaxResidencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxResidency[] | ListEnumTaxResidencyFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxResidencyFilter<$PrismaModel> | $Enums.TaxResidency
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type TaxReturnListRelationFilter = {
    every?: TaxReturnWhereInput
    some?: TaxReturnWhereInput
    none?: TaxReturnWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type AIConversationListRelationFilter = {
    every?: AIConversationWhereInput
    some?: AIConversationWhereInput
    none?: AIConversationWhereInput
  }

  export type AIInsightListRelationFilter = {
    every?: AIInsightWhereInput
    some?: AIInsightWhereInput
    none?: AIInsightWhereInput
  }

  export type AIUsageTrackingListRelationFilter = {
    every?: AIUsageTrackingWhereInput
    some?: AIUsageTrackingWhereInput
    none?: AIUsageTrackingWhereInput
  }

  export type Basiq_usersNullableScalarRelationFilter = {
    is?: basiq_usersWhereInput | null
    isNot?: basiq_usersWhereInput | null
  }

  export type Basiq_api_logsListRelationFilter = {
    every?: basiq_api_logsWhereInput
    some?: basiq_api_logsWhereInput
    none?: basiq_api_logsWhereInput
  }

  export type ReceiptListRelationFilter = {
    every?: ReceiptWhereInput
    some?: ReceiptWhereInput
    none?: ReceiptWhereInput
  }

  export type BudgetListRelationFilter = {
    every?: BudgetWhereInput
    some?: BudgetWhereInput
    none?: BudgetWhereInput
  }

  export type BudgetTrackingListRelationFilter = {
    every?: BudgetTrackingWhereInput
    some?: BudgetTrackingWhereInput
    none?: BudgetTrackingWhereInput
  }

  export type FinancialInsightListRelationFilter = {
    every?: FinancialInsightWhereInput
    some?: FinancialInsightWhereInput
    none?: FinancialInsightWhereInput
  }

  export type GoalListRelationFilter = {
    every?: GoalWhereInput
    some?: GoalWhereInput
    none?: GoalWhereInput
  }

  export type FinancialAuditLogListRelationFilter = {
    every?: FinancialAuditLogWhereInput
    some?: FinancialAuditLogWhereInput
    none?: FinancialAuditLogWhereInput
  }

  export type AMLTransactionMonitoringListRelationFilter = {
    every?: AMLTransactionMonitoringWhereInput
    some?: AMLTransactionMonitoringWhereInput
    none?: AMLTransactionMonitoringWhereInput
  }

  export type PrivacyConsentListRelationFilter = {
    every?: PrivacyConsentWhereInput
    some?: PrivacyConsentWhereInput
    none?: PrivacyConsentWhereInput
  }

  export type DataAccessRequestListRelationFilter = {
    every?: DataAccessRequestWhereInput
    some?: DataAccessRequestWhereInput
    none?: DataAccessRequestWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaxReturnOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIInsightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIUsageTrackingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type basiq_api_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReceiptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetTrackingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinancialInsightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GoalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinancialAuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AMLTransactionMonitoringOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrivacyConsentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DataAccessRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    image?: SortOrder
    role?: SortOrder
    abn?: SortOrder
    tfn?: SortOrder
    taxResidency?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerificationExpires?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    failedLoginAttempts?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    image?: SortOrder
    role?: SortOrder
    abn?: SortOrder
    tfn?: SortOrder
    taxResidency?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerificationExpires?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    image?: SortOrder
    role?: SortOrder
    abn?: SortOrder
    tfn?: SortOrder
    taxResidency?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerificationExpires?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    failedLoginAttempts?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumTaxResidencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxResidency | EnumTaxResidencyFieldRefInput<$PrismaModel>
    in?: $Enums.TaxResidency[] | ListEnumTaxResidencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxResidency[] | ListEnumTaxResidencyFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxResidencyWithAggregatesFilter<$PrismaModel> | $Enums.TaxResidency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaxResidencyFilter<$PrismaModel>
    _max?: NestedEnumTaxResidencyFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type EnumAuthEventFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthEvent | EnumAuthEventFieldRefInput<$PrismaModel>
    in?: $Enums.AuthEvent[] | ListEnumAuthEventFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthEvent[] | ListEnumAuthEventFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthEventFilter<$PrismaModel> | $Enums.AuthEvent
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    event?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    metadata?: SortOrder
    success?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    event?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    event?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuthEventWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthEvent | EnumAuthEventFieldRefInput<$PrismaModel>
    in?: $Enums.AuthEvent[] | ListEnumAuthEventFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthEvent[] | ListEnumAuthEventFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthEventWithAggregatesFilter<$PrismaModel> | $Enums.AuthEvent
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthEventFilter<$PrismaModel>
    _max?: NestedEnumAuthEventFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type EnumFinancialOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialOperation | EnumFinancialOperationFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialOperation[] | ListEnumFinancialOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialOperation[] | ListEnumFinancialOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialOperationFilter<$PrismaModel> | $Enums.FinancialOperation
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type FinancialAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    operationType?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    httpMethod?: SortOrder
    endpoint?: SortOrder
    previousData?: SortOrder
    currentData?: SortOrder
    changedFields?: SortOrder
    amount?: SortOrder
    gstAmount?: SortOrder
    currency?: SortOrder
    taxYear?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    hashChain?: SortOrder
    previousHash?: SortOrder
    createdAt?: SortOrder
    timezone?: SortOrder
  }

  export type FinancialAuditLogAvgOrderByAggregateInput = {
    amount?: SortOrder
    gstAmount?: SortOrder
  }

  export type FinancialAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    operationType?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    httpMethod?: SortOrder
    endpoint?: SortOrder
    amount?: SortOrder
    gstAmount?: SortOrder
    currency?: SortOrder
    taxYear?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    hashChain?: SortOrder
    previousHash?: SortOrder
    createdAt?: SortOrder
    timezone?: SortOrder
  }

  export type FinancialAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    operationType?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    httpMethod?: SortOrder
    endpoint?: SortOrder
    amount?: SortOrder
    gstAmount?: SortOrder
    currency?: SortOrder
    taxYear?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    hashChain?: SortOrder
    previousHash?: SortOrder
    createdAt?: SortOrder
    timezone?: SortOrder
  }

  export type FinancialAuditLogSumOrderByAggregateInput = {
    amount?: SortOrder
    gstAmount?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumFinancialOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialOperation | EnumFinancialOperationFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialOperation[] | ListEnumFinancialOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialOperation[] | ListEnumFinancialOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialOperationWithAggregatesFilter<$PrismaModel> | $Enums.FinancialOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFinancialOperationFilter<$PrismaModel>
    _max?: NestedEnumFinancialOperationFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel>
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanFilter<$PrismaModel> | $Enums.Plan
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    status?: SortOrder
    plan?: SortOrder
    interval?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    cancelledAt?: SortOrder
    trialEnd?: SortOrder
    defaultPaymentMethodId?: SortOrder
    lastPaymentAttempt?: SortOrder
    failedPaymentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    amount?: SortOrder
    failedPaymentCount?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    status?: SortOrder
    plan?: SortOrder
    interval?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    cancelledAt?: SortOrder
    trialEnd?: SortOrder
    defaultPaymentMethodId?: SortOrder
    lastPaymentAttempt?: SortOrder
    failedPaymentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    status?: SortOrder
    plan?: SortOrder
    interval?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    cancelledAt?: SortOrder
    trialEnd?: SortOrder
    defaultPaymentMethodId?: SortOrder
    lastPaymentAttempt?: SortOrder
    failedPaymentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    amount?: SortOrder
    failedPaymentCount?: SortOrder
  }

  export type EnumPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel>
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanWithAggregatesFilter<$PrismaModel> | $Enums.Plan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanFilter<$PrismaModel>
    _max?: NestedEnumPlanFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumTaxReturnStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxReturnStatus | EnumTaxReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaxReturnStatus[] | ListEnumTaxReturnStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxReturnStatus[] | ListEnumTaxReturnStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxReturnStatusFilter<$PrismaModel> | $Enums.TaxReturnStatus
  }

  export type TaxReturnUserIdYearCompoundUniqueInput = {
    userId: string
    year: string
  }

  export type TaxReturnCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    data?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxReturnMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxReturnMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumTaxReturnStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxReturnStatus | EnumTaxReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaxReturnStatus[] | ListEnumTaxReturnStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxReturnStatus[] | ListEnumTaxReturnStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxReturnStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaxReturnStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaxReturnStatusFilter<$PrismaModel>
    _max?: NestedEnumTaxReturnStatusFilter<$PrismaModel>
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripePaymentIntentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripePaymentIntentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripePaymentIntentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceLineItemListRelationFilter = {
    every?: InvoiceLineItemWhereInput
    some?: InvoiceLineItemWhereInput
    none?: InvoiceLineItemWhereInput
  }

  export type InvoiceLineItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    stripeInvoiceId?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerABN?: SortOrder
    subtotal?: SortOrder
    gstAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    invoiceDate?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    gstAmount?: SortOrder
    total?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    stripeInvoiceId?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerABN?: SortOrder
    subtotal?: SortOrder
    gstAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    invoiceDate?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    stripeInvoiceId?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerABN?: SortOrder
    subtotal?: SortOrder
    gstAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    invoiceDate?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    gstAmount?: SortOrder
    total?: SortOrder
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceLineItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceLineItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type InvoiceLineItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceLineItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceLineItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type AIConversationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    messages?: SortOrder
    context?: SortOrder
    tokensUsed?: SortOrder
    costUsd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIConversationAvgOrderByAggregateInput = {
    tokensUsed?: SortOrder
    costUsd?: SortOrder
  }

  export type AIConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    tokensUsed?: SortOrder
    costUsd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIConversationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    tokensUsed?: SortOrder
    costUsd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIConversationSumOrderByAggregateInput = {
    tokensUsed?: SortOrder
    costUsd?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type AIInsightCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    category?: SortOrder
    content?: SortOrder
    confidenceScore?: SortOrder
    sourceDataIds?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AIInsightAvgOrderByAggregateInput = {
    confidenceScore?: SortOrder
  }

  export type AIInsightMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    category?: SortOrder
    confidenceScore?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AIInsightMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    category?: SortOrder
    confidenceScore?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AIInsightSumOrderByAggregateInput = {
    confidenceScore?: SortOrder
  }

  export type AIUsageTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    operationType?: SortOrder
    tokensInput?: SortOrder
    tokensOutput?: SortOrder
    costUsd?: SortOrder
    responseTimeMs?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type AIUsageTrackingAvgOrderByAggregateInput = {
    tokensInput?: SortOrder
    tokensOutput?: SortOrder
    costUsd?: SortOrder
    responseTimeMs?: SortOrder
  }

  export type AIUsageTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    operationType?: SortOrder
    tokensInput?: SortOrder
    tokensOutput?: SortOrder
    costUsd?: SortOrder
    responseTimeMs?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type AIUsageTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    operationType?: SortOrder
    tokensInput?: SortOrder
    tokensOutput?: SortOrder
    costUsd?: SortOrder
    responseTimeMs?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type AIUsageTrackingSumOrderByAggregateInput = {
    tokensInput?: SortOrder
    tokensOutput?: SortOrder
    costUsd?: SortOrder
    responseTimeMs?: SortOrder
  }

  export type AICacheCountOrderByAggregateInput = {
    id?: SortOrder
    cacheKey?: SortOrder
    operationType?: SortOrder
    inputHash?: SortOrder
    response?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    hitCount?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AICacheAvgOrderByAggregateInput = {
    hitCount?: SortOrder
  }

  export type AICacheMaxOrderByAggregateInput = {
    id?: SortOrder
    cacheKey?: SortOrder
    operationType?: SortOrder
    inputHash?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    hitCount?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AICacheMinOrderByAggregateInput = {
    id?: SortOrder
    cacheKey?: SortOrder
    operationType?: SortOrder
    inputHash?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    hitCount?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AICacheSumOrderByAggregateInput = {
    hitCount?: SortOrder
  }

  export type AIProviderHealthCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    consecutiveFailures?: SortOrder
    lastFailureAt?: SortOrder
    lastSuccessAt?: SortOrder
    circuitOpenUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIProviderHealthAvgOrderByAggregateInput = {
    consecutiveFailures?: SortOrder
  }

  export type AIProviderHealthMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    consecutiveFailures?: SortOrder
    lastFailureAt?: SortOrder
    lastSuccessAt?: SortOrder
    circuitOpenUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIProviderHealthMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    consecutiveFailures?: SortOrder
    lastFailureAt?: SortOrder
    lastSuccessAt?: SortOrder
    circuitOpenUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIProviderHealthSumOrderByAggregateInput = {
    consecutiveFailures?: SortOrder
  }

  export type Bank_connectionsListRelationFilter = {
    every?: bank_connectionsWhereInput
    some?: bank_connectionsWhereInput
    none?: bank_connectionsWhereInput
  }

  export type Bank_accountsListRelationFilter = {
    every?: bank_accountsWhereInput
    some?: bank_accountsWhereInput
    none?: bank_accountsWhereInput
  }

  export type bank_connectionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bank_accountsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type basiq_usersCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    basiq_user_id?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    connection_status?: SortOrder
    consent_id?: SortOrder
    consent_status?: SortOrder
    consent_expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type basiq_usersMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    basiq_user_id?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    connection_status?: SortOrder
    consent_id?: SortOrder
    consent_status?: SortOrder
    consent_expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type basiq_usersMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    basiq_user_id?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    connection_status?: SortOrder
    consent_id?: SortOrder
    consent_status?: SortOrder
    consent_expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Basiq_usersScalarRelationFilter = {
    is?: basiq_usersWhereInput
    isNot?: basiq_usersWhereInput
  }

  export type bank_connectionsCountOrderByAggregateInput = {
    id?: SortOrder
    basiq_user_id?: SortOrder
    connection_id?: SortOrder
    institution_id?: SortOrder
    institution_name?: SortOrder
    institution_short_name?: SortOrder
    institution_logo_url?: SortOrder
    status?: SortOrder
    last_synced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bank_connectionsMaxOrderByAggregateInput = {
    id?: SortOrder
    basiq_user_id?: SortOrder
    connection_id?: SortOrder
    institution_id?: SortOrder
    institution_name?: SortOrder
    institution_short_name?: SortOrder
    institution_logo_url?: SortOrder
    status?: SortOrder
    last_synced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bank_connectionsMinOrderByAggregateInput = {
    id?: SortOrder
    basiq_user_id?: SortOrder
    connection_id?: SortOrder
    institution_id?: SortOrder
    institution_name?: SortOrder
    institution_short_name?: SortOrder
    institution_logo_url?: SortOrder
    status?: SortOrder
    last_synced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Bank_connectionsScalarRelationFilter = {
    is?: bank_connectionsWhereInput
    isNot?: bank_connectionsWhereInput
  }

  export type Bank_transactionsListRelationFilter = {
    every?: bank_transactionsWhereInput
    some?: bank_transactionsWhereInput
    none?: bank_transactionsWhereInput
  }

  export type bank_transactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bank_accountsCountOrderByAggregateInput = {
    id?: SortOrder
    basiq_user_id?: SortOrder
    connection_id?: SortOrder
    basiq_account_id?: SortOrder
    account_holder?: SortOrder
    account_number?: SortOrder
    bsb?: SortOrder
    institution_name?: SortOrder
    account_type?: SortOrder
    account_name?: SortOrder
    balance_available?: SortOrder
    balance_current?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    is_business_account?: SortOrder
    last_synced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bank_accountsAvgOrderByAggregateInput = {
    balance_available?: SortOrder
    balance_current?: SortOrder
  }

  export type bank_accountsMaxOrderByAggregateInput = {
    id?: SortOrder
    basiq_user_id?: SortOrder
    connection_id?: SortOrder
    basiq_account_id?: SortOrder
    account_holder?: SortOrder
    account_number?: SortOrder
    bsb?: SortOrder
    institution_name?: SortOrder
    account_type?: SortOrder
    account_name?: SortOrder
    balance_available?: SortOrder
    balance_current?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    is_business_account?: SortOrder
    last_synced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bank_accountsMinOrderByAggregateInput = {
    id?: SortOrder
    basiq_user_id?: SortOrder
    connection_id?: SortOrder
    basiq_account_id?: SortOrder
    account_holder?: SortOrder
    account_number?: SortOrder
    bsb?: SortOrder
    institution_name?: SortOrder
    account_type?: SortOrder
    account_name?: SortOrder
    balance_available?: SortOrder
    balance_current?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    is_business_account?: SortOrder
    last_synced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bank_accountsSumOrderByAggregateInput = {
    balance_available?: SortOrder
    balance_current?: SortOrder
  }

  export type Bank_accountsScalarRelationFilter = {
    is?: bank_accountsWhereInput
    isNot?: bank_accountsWhereInput
  }

  export type bank_transactionsCountOrderByAggregateInput = {
    id?: SortOrder
    bank_account_id?: SortOrder
    basiq_transaction_id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    transaction_date?: SortOrder
    post_date?: SortOrder
    balance?: SortOrder
    transaction_type?: SortOrder
    direction?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    merchant_name?: SortOrder
    status?: SortOrder
    is_business_expense?: SortOrder
    tax_category?: SortOrder
    gst_amount?: SortOrder
    receipt_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bank_transactionsAvgOrderByAggregateInput = {
    amount?: SortOrder
    balance?: SortOrder
    gst_amount?: SortOrder
  }

  export type bank_transactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    bank_account_id?: SortOrder
    basiq_transaction_id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    transaction_date?: SortOrder
    post_date?: SortOrder
    balance?: SortOrder
    transaction_type?: SortOrder
    direction?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    merchant_name?: SortOrder
    status?: SortOrder
    is_business_expense?: SortOrder
    tax_category?: SortOrder
    gst_amount?: SortOrder
    receipt_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bank_transactionsMinOrderByAggregateInput = {
    id?: SortOrder
    bank_account_id?: SortOrder
    basiq_transaction_id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    transaction_date?: SortOrder
    post_date?: SortOrder
    balance?: SortOrder
    transaction_type?: SortOrder
    direction?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    merchant_name?: SortOrder
    status?: SortOrder
    is_business_expense?: SortOrder
    tax_category?: SortOrder
    gst_amount?: SortOrder
    receipt_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bank_transactionsSumOrderByAggregateInput = {
    amount?: SortOrder
    balance?: SortOrder
    gst_amount?: SortOrder
  }

  export type basiq_webhooksCountOrderByAggregateInput = {
    id?: SortOrder
    webhook_id?: SortOrder
    event_type?: SortOrder
    resource_type?: SortOrder
    resource_id?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    processed_at?: SortOrder
    error_message?: SortOrder
    retry_count?: SortOrder
    created_at?: SortOrder
  }

  export type basiq_webhooksAvgOrderByAggregateInput = {
    retry_count?: SortOrder
  }

  export type basiq_webhooksMaxOrderByAggregateInput = {
    id?: SortOrder
    webhook_id?: SortOrder
    event_type?: SortOrder
    resource_type?: SortOrder
    resource_id?: SortOrder
    status?: SortOrder
    processed_at?: SortOrder
    error_message?: SortOrder
    retry_count?: SortOrder
    created_at?: SortOrder
  }

  export type basiq_webhooksMinOrderByAggregateInput = {
    id?: SortOrder
    webhook_id?: SortOrder
    event_type?: SortOrder
    resource_type?: SortOrder
    resource_id?: SortOrder
    status?: SortOrder
    processed_at?: SortOrder
    error_message?: SortOrder
    retry_count?: SortOrder
    created_at?: SortOrder
  }

  export type basiq_webhooksSumOrderByAggregateInput = {
    retry_count?: SortOrder
  }

  export type basiq_api_logsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    request_body?: SortOrder
    response_status?: SortOrder
    response_body?: SortOrder
    error_message?: SortOrder
    duration_ms?: SortOrder
    created_at?: SortOrder
  }

  export type basiq_api_logsAvgOrderByAggregateInput = {
    response_status?: SortOrder
    duration_ms?: SortOrder
  }

  export type basiq_api_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    response_status?: SortOrder
    error_message?: SortOrder
    duration_ms?: SortOrder
    created_at?: SortOrder
  }

  export type basiq_api_logsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    response_status?: SortOrder
    error_message?: SortOrder
    duration_ms?: SortOrder
    created_at?: SortOrder
  }

  export type basiq_api_logsSumOrderByAggregateInput = {
    response_status?: SortOrder
    duration_ms?: SortOrder
  }

  export type EnumReceiptStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReceiptStatus | EnumReceiptStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReceiptStatus[] | ListEnumReceiptStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReceiptStatus[] | ListEnumReceiptStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReceiptStatusFilter<$PrismaModel> | $Enums.ReceiptStatus
  }

  export type ReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    merchant?: SortOrder
    totalAmount?: SortOrder
    gstAmount?: SortOrder
    date?: SortOrder
    items?: SortOrder
    imageUrl?: SortOrder
    aiProcessed?: SortOrder
    aiConfidence?: SortOrder
    aiProvider?: SortOrder
    aiModel?: SortOrder
    processingStatus?: SortOrder
    abn?: SortOrder
    taxInvoiceNumber?: SortOrder
    taxCategory?: SortOrder
    isGstRegistered?: SortOrder
    matchedTransactionId?: SortOrder
    matchConfidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceiptAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    gstAmount?: SortOrder
    aiConfidence?: SortOrder
    matchConfidence?: SortOrder
  }

  export type ReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    merchant?: SortOrder
    totalAmount?: SortOrder
    gstAmount?: SortOrder
    date?: SortOrder
    imageUrl?: SortOrder
    aiProcessed?: SortOrder
    aiConfidence?: SortOrder
    aiProvider?: SortOrder
    aiModel?: SortOrder
    processingStatus?: SortOrder
    abn?: SortOrder
    taxInvoiceNumber?: SortOrder
    taxCategory?: SortOrder
    isGstRegistered?: SortOrder
    matchedTransactionId?: SortOrder
    matchConfidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    merchant?: SortOrder
    totalAmount?: SortOrder
    gstAmount?: SortOrder
    date?: SortOrder
    imageUrl?: SortOrder
    aiProcessed?: SortOrder
    aiConfidence?: SortOrder
    aiProvider?: SortOrder
    aiModel?: SortOrder
    processingStatus?: SortOrder
    abn?: SortOrder
    taxInvoiceNumber?: SortOrder
    taxCategory?: SortOrder
    isGstRegistered?: SortOrder
    matchedTransactionId?: SortOrder
    matchConfidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceiptSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    gstAmount?: SortOrder
    aiConfidence?: SortOrder
    matchConfidence?: SortOrder
  }

  export type EnumReceiptStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReceiptStatus | EnumReceiptStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReceiptStatus[] | ListEnumReceiptStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReceiptStatus[] | ListEnumReceiptStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReceiptStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReceiptStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReceiptStatusFilter<$PrismaModel>
    _max?: NestedEnumReceiptStatusFilter<$PrismaModel>
  }

  export type EnumBudgetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetStatus | EnumBudgetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetStatusFilter<$PrismaModel> | $Enums.BudgetStatus
  }

  export type BudgetCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    monthlyBudget?: SortOrder
    targetSavings?: SortOrder
    monthlyIncome?: SortOrder
    predictions?: SortOrder
    categoryLimits?: SortOrder
    confidenceScore?: SortOrder
    aiProvider?: SortOrder
    aiModel?: SortOrder
    analysisPeriod?: SortOrder
    predictionPeriod?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetAvgOrderByAggregateInput = {
    monthlyBudget?: SortOrder
    targetSavings?: SortOrder
    monthlyIncome?: SortOrder
    confidenceScore?: SortOrder
  }

  export type BudgetMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    monthlyBudget?: SortOrder
    targetSavings?: SortOrder
    monthlyIncome?: SortOrder
    confidenceScore?: SortOrder
    aiProvider?: SortOrder
    aiModel?: SortOrder
    analysisPeriod?: SortOrder
    predictionPeriod?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    monthlyBudget?: SortOrder
    targetSavings?: SortOrder
    monthlyIncome?: SortOrder
    confidenceScore?: SortOrder
    aiProvider?: SortOrder
    aiModel?: SortOrder
    analysisPeriod?: SortOrder
    predictionPeriod?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetSumOrderByAggregateInput = {
    monthlyBudget?: SortOrder
    targetSavings?: SortOrder
    monthlyIncome?: SortOrder
    confidenceScore?: SortOrder
  }

  export type EnumBudgetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetStatus | EnumBudgetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetStatusWithAggregatesFilter<$PrismaModel> | $Enums.BudgetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBudgetStatusFilter<$PrismaModel>
    _max?: NestedEnumBudgetStatusFilter<$PrismaModel>
  }

  export type BudgetScalarRelationFilter = {
    is?: BudgetWhereInput
    isNot?: BudgetWhereInput
  }

  export type BudgetTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    predictedAmount?: SortOrder
    actualAmount?: SortOrder
    variance?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetTrackingAvgOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
    predictedAmount?: SortOrder
    actualAmount?: SortOrder
    variance?: SortOrder
  }

  export type BudgetTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    predictedAmount?: SortOrder
    actualAmount?: SortOrder
    variance?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    predictedAmount?: SortOrder
    actualAmount?: SortOrder
    variance?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetTrackingSumOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
    predictedAmount?: SortOrder
    actualAmount?: SortOrder
    variance?: SortOrder
  }

  export type EnumInsightPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightPriority | EnumInsightPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.InsightPriority[] | ListEnumInsightPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightPriority[] | ListEnumInsightPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightPriorityFilter<$PrismaModel> | $Enums.InsightPriority
  }

  export type FinancialInsightCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    category?: SortOrder
    content?: SortOrder
    confidenceScore?: SortOrder
    sourceDataIds?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    title?: SortOrder
    description?: SortOrder
    recommendations?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type FinancialInsightAvgOrderByAggregateInput = {
    confidenceScore?: SortOrder
  }

  export type FinancialInsightMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    category?: SortOrder
    confidenceScore?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type FinancialInsightMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    category?: SortOrder
    confidenceScore?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type FinancialInsightSumOrderByAggregateInput = {
    confidenceScore?: SortOrder
  }

  export type EnumInsightPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightPriority | EnumInsightPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.InsightPriority[] | ListEnumInsightPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightPriority[] | ListEnumInsightPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightPriorityWithAggregatesFilter<$PrismaModel> | $Enums.InsightPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightPriorityFilter<$PrismaModel>
    _max?: NestedEnumInsightPriorityFilter<$PrismaModel>
  }

  export type EnumGoalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalStatus | EnumGoalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalStatusFilter<$PrismaModel> | $Enums.GoalStatus
  }

  export type GoalCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    targetAmount?: SortOrder
    currentAmount?: SortOrder
    targetDate?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalAvgOrderByAggregateInput = {
    targetAmount?: SortOrder
    currentAmount?: SortOrder
  }

  export type GoalMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    targetAmount?: SortOrder
    currentAmount?: SortOrder
    targetDate?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    targetAmount?: SortOrder
    currentAmount?: SortOrder
    targetDate?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalSumOrderByAggregateInput = {
    targetAmount?: SortOrder
    currentAmount?: SortOrder
  }

  export type EnumGoalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalStatus | EnumGoalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalStatusWithAggregatesFilter<$PrismaModel> | $Enums.GoalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGoalStatusFilter<$PrismaModel>
    _max?: NestedEnumGoalStatusFilter<$PrismaModel>
  }

  export type EnumAMLMonitoringTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AMLMonitoringType | EnumAMLMonitoringTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AMLMonitoringType[] | ListEnumAMLMonitoringTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AMLMonitoringType[] | ListEnumAMLMonitoringTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAMLMonitoringTypeFilter<$PrismaModel> | $Enums.AMLMonitoringType
  }

  export type AMLTransactionMonitoringCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    monitoringType?: SortOrder
    riskScore?: SortOrder
    riskFactors?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    patternType?: SortOrder
    patternDetails?: SortOrder
    velocityScore?: SortOrder
    requiresReview?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    reportedToAUSTRAC?: SortOrder
    reportReference?: SortOrder
    reportedAt?: SortOrder
    falsePositive?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AMLTransactionMonitoringAvgOrderByAggregateInput = {
    riskScore?: SortOrder
    amount?: SortOrder
    velocityScore?: SortOrder
  }

  export type AMLTransactionMonitoringMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    monitoringType?: SortOrder
    riskScore?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    patternType?: SortOrder
    velocityScore?: SortOrder
    requiresReview?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    reportedToAUSTRAC?: SortOrder
    reportReference?: SortOrder
    reportedAt?: SortOrder
    falsePositive?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AMLTransactionMonitoringMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    monitoringType?: SortOrder
    riskScore?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    patternType?: SortOrder
    velocityScore?: SortOrder
    requiresReview?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    reportedToAUSTRAC?: SortOrder
    reportReference?: SortOrder
    reportedAt?: SortOrder
    falsePositive?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AMLTransactionMonitoringSumOrderByAggregateInput = {
    riskScore?: SortOrder
    amount?: SortOrder
    velocityScore?: SortOrder
  }

  export type EnumAMLMonitoringTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AMLMonitoringType | EnumAMLMonitoringTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AMLMonitoringType[] | ListEnumAMLMonitoringTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AMLMonitoringType[] | ListEnumAMLMonitoringTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAMLMonitoringTypeWithAggregatesFilter<$PrismaModel> | $Enums.AMLMonitoringType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAMLMonitoringTypeFilter<$PrismaModel>
    _max?: NestedEnumAMLMonitoringTypeFilter<$PrismaModel>
  }

  export type EnumConsentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentType | EnumConsentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentTypeFilter<$PrismaModel> | $Enums.ConsentType
  }

  export type EnumConsentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatus | EnumConsentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentStatusFilter<$PrismaModel> | $Enums.ConsentStatus
  }

  export type PrivacyConsentUserIdConsentTypeConsentVersionCompoundUniqueInput = {
    userId: string
    consentType: $Enums.ConsentType
    consentVersion: string
  }

  export type PrivacyConsentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    consentVersion?: SortOrder
    consentStatus?: SortOrder
    consentDate?: SortOrder
    expiryDate?: SortOrder
    purposes?: SortOrder
    dataCategories?: SortOrder
    thirdParties?: SortOrder
    withdrawnAt?: SortOrder
    withdrawalReason?: SortOrder
    legalBasis?: SortOrder
    jurisdiction?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivacyConsentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    consentVersion?: SortOrder
    consentStatus?: SortOrder
    consentDate?: SortOrder
    expiryDate?: SortOrder
    withdrawnAt?: SortOrder
    withdrawalReason?: SortOrder
    legalBasis?: SortOrder
    jurisdiction?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivacyConsentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    consentVersion?: SortOrder
    consentStatus?: SortOrder
    consentDate?: SortOrder
    expiryDate?: SortOrder
    withdrawnAt?: SortOrder
    withdrawalReason?: SortOrder
    legalBasis?: SortOrder
    jurisdiction?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumConsentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentType | EnumConsentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConsentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsentTypeFilter<$PrismaModel>
    _max?: NestedEnumConsentTypeFilter<$PrismaModel>
  }

  export type EnumConsentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatus | EnumConsentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConsentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsentStatusFilter<$PrismaModel>
    _max?: NestedEnumConsentStatusFilter<$PrismaModel>
  }

  export type EnumDataRequestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRequestType | EnumDataRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DataRequestType[] | ListEnumDataRequestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataRequestType[] | ListEnumDataRequestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDataRequestTypeFilter<$PrismaModel> | $Enums.DataRequestType
  }

  export type EnumDataRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRequestStatus | EnumDataRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DataRequestStatus[] | ListEnumDataRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataRequestStatus[] | ListEnumDataRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDataRequestStatusFilter<$PrismaModel> | $Enums.DataRequestStatus
  }

  export type DataAccessRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    requestType?: SortOrder
    requestStatus?: SortOrder
    requestDate?: SortOrder
    requestDetails?: SortOrder
    verificationMethod?: SortOrder
    verifiedAt?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    completedAt?: SortOrder
    responseMethod?: SortOrder
    responseUrl?: SortOrder
    responseExpiryDate?: SortOrder
    dueDate?: SortOrder
    extensionReason?: SortOrder
    extendedDueDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataAccessRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    requestType?: SortOrder
    requestStatus?: SortOrder
    requestDate?: SortOrder
    verificationMethod?: SortOrder
    verifiedAt?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    completedAt?: SortOrder
    responseMethod?: SortOrder
    responseUrl?: SortOrder
    responseExpiryDate?: SortOrder
    dueDate?: SortOrder
    extensionReason?: SortOrder
    extendedDueDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataAccessRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    requestType?: SortOrder
    requestStatus?: SortOrder
    requestDate?: SortOrder
    verificationMethod?: SortOrder
    verifiedAt?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    completedAt?: SortOrder
    responseMethod?: SortOrder
    responseUrl?: SortOrder
    responseExpiryDate?: SortOrder
    dueDate?: SortOrder
    extensionReason?: SortOrder
    extendedDueDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDataRequestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRequestType | EnumDataRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DataRequestType[] | ListEnumDataRequestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataRequestType[] | ListEnumDataRequestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDataRequestTypeWithAggregatesFilter<$PrismaModel> | $Enums.DataRequestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataRequestTypeFilter<$PrismaModel>
    _max?: NestedEnumDataRequestTypeFilter<$PrismaModel>
  }

  export type EnumDataRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRequestStatus | EnumDataRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DataRequestStatus[] | ListEnumDataRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataRequestStatus[] | ListEnumDataRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDataRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.DataRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumDataRequestStatusFilter<$PrismaModel>
  }

  export type EnumIncidentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeFilter<$PrismaModel> | $Enums.IncidentType
  }

  export type EnumIncidentSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityFilter<$PrismaModel> | $Enums.IncidentSeverity
  }

  export type EnumIncidentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusFilter<$PrismaModel> | $Enums.IncidentStatus
  }

  export type APRAIncidentReportCountOrderByAggregateInput = {
    id?: SortOrder
    incidentType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    detectedAt?: SortOrder
    reportedAt?: SortOrder
    resolvedAt?: SortOrder
    affectedUsers?: SortOrder
    affectedSystems?: SortOrder
    dataCompromised?: SortOrder
    financialImpact?: SortOrder
    immediateActions?: SortOrder
    rootCause?: SortOrder
    remediation?: SortOrder
    preventiveMeasures?: SortOrder
    reportedToAPRA?: SortOrder
    apraReference?: SortOrder
    reportedToOAIC?: SortOrder
    oaicReference?: SortOrder
    bcpActivated?: SortOrder
    serviceDowntime?: SortOrder
    dataRecoveryTime?: SortOrder
    reportedBy?: SortOrder
    responsibleTeam?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type APRAIncidentReportAvgOrderByAggregateInput = {
    affectedUsers?: SortOrder
    financialImpact?: SortOrder
    serviceDowntime?: SortOrder
    dataRecoveryTime?: SortOrder
  }

  export type APRAIncidentReportMaxOrderByAggregateInput = {
    id?: SortOrder
    incidentType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    detectedAt?: SortOrder
    reportedAt?: SortOrder
    resolvedAt?: SortOrder
    affectedUsers?: SortOrder
    dataCompromised?: SortOrder
    financialImpact?: SortOrder
    rootCause?: SortOrder
    reportedToAPRA?: SortOrder
    apraReference?: SortOrder
    reportedToOAIC?: SortOrder
    oaicReference?: SortOrder
    bcpActivated?: SortOrder
    serviceDowntime?: SortOrder
    dataRecoveryTime?: SortOrder
    reportedBy?: SortOrder
    responsibleTeam?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type APRAIncidentReportMinOrderByAggregateInput = {
    id?: SortOrder
    incidentType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    detectedAt?: SortOrder
    reportedAt?: SortOrder
    resolvedAt?: SortOrder
    affectedUsers?: SortOrder
    dataCompromised?: SortOrder
    financialImpact?: SortOrder
    rootCause?: SortOrder
    reportedToAPRA?: SortOrder
    apraReference?: SortOrder
    reportedToOAIC?: SortOrder
    oaicReference?: SortOrder
    bcpActivated?: SortOrder
    serviceDowntime?: SortOrder
    dataRecoveryTime?: SortOrder
    reportedBy?: SortOrder
    responsibleTeam?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type APRAIncidentReportSumOrderByAggregateInput = {
    affectedUsers?: SortOrder
    financialImpact?: SortOrder
    serviceDowntime?: SortOrder
    dataRecoveryTime?: SortOrder
  }

  export type EnumIncidentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeWithAggregatesFilter<$PrismaModel> | $Enums.IncidentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentTypeFilter<$PrismaModel>
    _max?: NestedEnumIncidentTypeFilter<$PrismaModel>
  }

  export type EnumIncidentSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityWithAggregatesFilter<$PrismaModel> | $Enums.IncidentSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentSeverityFilter<$PrismaModel>
    _max?: NestedEnumIncidentSeverityFilter<$PrismaModel>
  }

  export type EnumIncidentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel> | $Enums.IncidentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentStatusFilter<$PrismaModel>
    _max?: NestedEnumIncidentStatusFilter<$PrismaModel>
  }

  export type EnumGSTTreatmentFilter<$PrismaModel = never> = {
    equals?: $Enums.GSTTreatment | EnumGSTTreatmentFieldRefInput<$PrismaModel>
    in?: $Enums.GSTTreatment[] | ListEnumGSTTreatmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.GSTTreatment[] | ListEnumGSTTreatmentFieldRefInput<$PrismaModel>
    not?: NestedEnumGSTTreatmentFilter<$PrismaModel> | $Enums.GSTTreatment
  }

  export type GSTTransactionDetailCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    invoiceId?: SortOrder
    baseAmount?: SortOrder
    gstRate?: SortOrder
    gstAmount?: SortOrder
    totalAmount?: SortOrder
    taxCategory?: SortOrder
    gstTreatment?: SortOrder
    inputTaxCredit?: SortOrder
    supplierABN?: SortOrder
    supplierName?: SortOrder
    isGSTRegistered?: SortOrder
    basReportingCode?: SortOrder
    taxPeriod?: SortOrder
    reportedInBAS?: SortOrder
    basReference?: SortOrder
    validated?: SortOrder
    validationErrors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GSTTransactionDetailAvgOrderByAggregateInput = {
    baseAmount?: SortOrder
    gstRate?: SortOrder
    gstAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type GSTTransactionDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    invoiceId?: SortOrder
    baseAmount?: SortOrder
    gstRate?: SortOrder
    gstAmount?: SortOrder
    totalAmount?: SortOrder
    taxCategory?: SortOrder
    gstTreatment?: SortOrder
    inputTaxCredit?: SortOrder
    supplierABN?: SortOrder
    supplierName?: SortOrder
    isGSTRegistered?: SortOrder
    basReportingCode?: SortOrder
    taxPeriod?: SortOrder
    reportedInBAS?: SortOrder
    basReference?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GSTTransactionDetailMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    invoiceId?: SortOrder
    baseAmount?: SortOrder
    gstRate?: SortOrder
    gstAmount?: SortOrder
    totalAmount?: SortOrder
    taxCategory?: SortOrder
    gstTreatment?: SortOrder
    inputTaxCredit?: SortOrder
    supplierABN?: SortOrder
    supplierName?: SortOrder
    isGSTRegistered?: SortOrder
    basReportingCode?: SortOrder
    taxPeriod?: SortOrder
    reportedInBAS?: SortOrder
    basReference?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GSTTransactionDetailSumOrderByAggregateInput = {
    baseAmount?: SortOrder
    gstRate?: SortOrder
    gstAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type EnumGSTTreatmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GSTTreatment | EnumGSTTreatmentFieldRefInput<$PrismaModel>
    in?: $Enums.GSTTreatment[] | ListEnumGSTTreatmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.GSTTreatment[] | ListEnumGSTTreatmentFieldRefInput<$PrismaModel>
    not?: NestedEnumGSTTreatmentWithAggregatesFilter<$PrismaModel> | $Enums.GSTTreatment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGSTTreatmentFilter<$PrismaModel>
    _max?: NestedEnumGSTTreatmentFilter<$PrismaModel>
  }

  export type ComplianceConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    configType?: SortOrder
    configData?: SortOrder
    isActive?: SortOrder
    amlThresholds?: SortOrder
    dataRetentionDays?: SortOrder
    consentExpireDays?: SortOrder
    incidentReportHours?: SortOrder
    backupFrequency?: SortOrder
    gstRate?: SortOrder
    basReportingCodes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceConfigurationAvgOrderByAggregateInput = {
    dataRetentionDays?: SortOrder
    consentExpireDays?: SortOrder
    incidentReportHours?: SortOrder
    gstRate?: SortOrder
  }

  export type ComplianceConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    configType?: SortOrder
    isActive?: SortOrder
    dataRetentionDays?: SortOrder
    consentExpireDays?: SortOrder
    incidentReportHours?: SortOrder
    backupFrequency?: SortOrder
    gstRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    configType?: SortOrder
    isActive?: SortOrder
    dataRetentionDays?: SortOrder
    consentExpireDays?: SortOrder
    incidentReportHours?: SortOrder
    backupFrequency?: SortOrder
    gstRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceConfigurationSumOrderByAggregateInput = {
    dataRetentionDays?: SortOrder
    consentExpireDays?: SortOrder
    incidentReportHours?: SortOrder
    gstRate?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type TaxReturnCreateNestedManyWithoutUserInput = {
    create?: XOR<TaxReturnCreateWithoutUserInput, TaxReturnUncheckedCreateWithoutUserInput> | TaxReturnCreateWithoutUserInput[] | TaxReturnUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaxReturnCreateOrConnectWithoutUserInput | TaxReturnCreateOrConnectWithoutUserInput[]
    createMany?: TaxReturnCreateManyUserInputEnvelope
    connect?: TaxReturnWhereUniqueInput | TaxReturnWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type AIConversationCreateNestedManyWithoutUserInput = {
    create?: XOR<AIConversationCreateWithoutUserInput, AIConversationUncheckedCreateWithoutUserInput> | AIConversationCreateWithoutUserInput[] | AIConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIConversationCreateOrConnectWithoutUserInput | AIConversationCreateOrConnectWithoutUserInput[]
    createMany?: AIConversationCreateManyUserInputEnvelope
    connect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
  }

  export type AIInsightCreateNestedManyWithoutUserInput = {
    create?: XOR<AIInsightCreateWithoutUserInput, AIInsightUncheckedCreateWithoutUserInput> | AIInsightCreateWithoutUserInput[] | AIInsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIInsightCreateOrConnectWithoutUserInput | AIInsightCreateOrConnectWithoutUserInput[]
    createMany?: AIInsightCreateManyUserInputEnvelope
    connect?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
  }

  export type AIUsageTrackingCreateNestedManyWithoutUserInput = {
    create?: XOR<AIUsageTrackingCreateWithoutUserInput, AIUsageTrackingUncheckedCreateWithoutUserInput> | AIUsageTrackingCreateWithoutUserInput[] | AIUsageTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIUsageTrackingCreateOrConnectWithoutUserInput | AIUsageTrackingCreateOrConnectWithoutUserInput[]
    createMany?: AIUsageTrackingCreateManyUserInputEnvelope
    connect?: AIUsageTrackingWhereUniqueInput | AIUsageTrackingWhereUniqueInput[]
  }

  export type basiq_usersCreateNestedOneWithoutUserInput = {
    create?: XOR<basiq_usersCreateWithoutUserInput, basiq_usersUncheckedCreateWithoutUserInput>
    connectOrCreate?: basiq_usersCreateOrConnectWithoutUserInput
    connect?: basiq_usersWhereUniqueInput
  }

  export type basiq_api_logsCreateNestedManyWithoutUserInput = {
    create?: XOR<basiq_api_logsCreateWithoutUserInput, basiq_api_logsUncheckedCreateWithoutUserInput> | basiq_api_logsCreateWithoutUserInput[] | basiq_api_logsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: basiq_api_logsCreateOrConnectWithoutUserInput | basiq_api_logsCreateOrConnectWithoutUserInput[]
    createMany?: basiq_api_logsCreateManyUserInputEnvelope
    connect?: basiq_api_logsWhereUniqueInput | basiq_api_logsWhereUniqueInput[]
  }

  export type ReceiptCreateNestedManyWithoutUserInput = {
    create?: XOR<ReceiptCreateWithoutUserInput, ReceiptUncheckedCreateWithoutUserInput> | ReceiptCreateWithoutUserInput[] | ReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutUserInput | ReceiptCreateOrConnectWithoutUserInput[]
    createMany?: ReceiptCreateManyUserInputEnvelope
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
  }

  export type BudgetCreateNestedManyWithoutUserInput = {
    create?: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput> | BudgetCreateWithoutUserInput[] | BudgetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutUserInput | BudgetCreateOrConnectWithoutUserInput[]
    createMany?: BudgetCreateManyUserInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type BudgetTrackingCreateNestedManyWithoutUserInput = {
    create?: XOR<BudgetTrackingCreateWithoutUserInput, BudgetTrackingUncheckedCreateWithoutUserInput> | BudgetTrackingCreateWithoutUserInput[] | BudgetTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetTrackingCreateOrConnectWithoutUserInput | BudgetTrackingCreateOrConnectWithoutUserInput[]
    createMany?: BudgetTrackingCreateManyUserInputEnvelope
    connect?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
  }

  export type FinancialInsightCreateNestedManyWithoutUserInput = {
    create?: XOR<FinancialInsightCreateWithoutUserInput, FinancialInsightUncheckedCreateWithoutUserInput> | FinancialInsightCreateWithoutUserInput[] | FinancialInsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinancialInsightCreateOrConnectWithoutUserInput | FinancialInsightCreateOrConnectWithoutUserInput[]
    createMany?: FinancialInsightCreateManyUserInputEnvelope
    connect?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
  }

  export type GoalCreateNestedManyWithoutUserInput = {
    create?: XOR<GoalCreateWithoutUserInput, GoalUncheckedCreateWithoutUserInput> | GoalCreateWithoutUserInput[] | GoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutUserInput | GoalCreateOrConnectWithoutUserInput[]
    createMany?: GoalCreateManyUserInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type FinancialAuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<FinancialAuditLogCreateWithoutUserInput, FinancialAuditLogUncheckedCreateWithoutUserInput> | FinancialAuditLogCreateWithoutUserInput[] | FinancialAuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinancialAuditLogCreateOrConnectWithoutUserInput | FinancialAuditLogCreateOrConnectWithoutUserInput[]
    createMany?: FinancialAuditLogCreateManyUserInputEnvelope
    connect?: FinancialAuditLogWhereUniqueInput | FinancialAuditLogWhereUniqueInput[]
  }

  export type AMLTransactionMonitoringCreateNestedManyWithoutUserInput = {
    create?: XOR<AMLTransactionMonitoringCreateWithoutUserInput, AMLTransactionMonitoringUncheckedCreateWithoutUserInput> | AMLTransactionMonitoringCreateWithoutUserInput[] | AMLTransactionMonitoringUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AMLTransactionMonitoringCreateOrConnectWithoutUserInput | AMLTransactionMonitoringCreateOrConnectWithoutUserInput[]
    createMany?: AMLTransactionMonitoringCreateManyUserInputEnvelope
    connect?: AMLTransactionMonitoringWhereUniqueInput | AMLTransactionMonitoringWhereUniqueInput[]
  }

  export type PrivacyConsentCreateNestedManyWithoutUserInput = {
    create?: XOR<PrivacyConsentCreateWithoutUserInput, PrivacyConsentUncheckedCreateWithoutUserInput> | PrivacyConsentCreateWithoutUserInput[] | PrivacyConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PrivacyConsentCreateOrConnectWithoutUserInput | PrivacyConsentCreateOrConnectWithoutUserInput[]
    createMany?: PrivacyConsentCreateManyUserInputEnvelope
    connect?: PrivacyConsentWhereUniqueInput | PrivacyConsentWhereUniqueInput[]
  }

  export type DataAccessRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<DataAccessRequestCreateWithoutUserInput, DataAccessRequestUncheckedCreateWithoutUserInput> | DataAccessRequestCreateWithoutUserInput[] | DataAccessRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataAccessRequestCreateOrConnectWithoutUserInput | DataAccessRequestCreateOrConnectWithoutUserInput[]
    createMany?: DataAccessRequestCreateManyUserInputEnvelope
    connect?: DataAccessRequestWhereUniqueInput | DataAccessRequestWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type TaxReturnUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaxReturnCreateWithoutUserInput, TaxReturnUncheckedCreateWithoutUserInput> | TaxReturnCreateWithoutUserInput[] | TaxReturnUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaxReturnCreateOrConnectWithoutUserInput | TaxReturnCreateOrConnectWithoutUserInput[]
    createMany?: TaxReturnCreateManyUserInputEnvelope
    connect?: TaxReturnWhereUniqueInput | TaxReturnWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type AIConversationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AIConversationCreateWithoutUserInput, AIConversationUncheckedCreateWithoutUserInput> | AIConversationCreateWithoutUserInput[] | AIConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIConversationCreateOrConnectWithoutUserInput | AIConversationCreateOrConnectWithoutUserInput[]
    createMany?: AIConversationCreateManyUserInputEnvelope
    connect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
  }

  export type AIInsightUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AIInsightCreateWithoutUserInput, AIInsightUncheckedCreateWithoutUserInput> | AIInsightCreateWithoutUserInput[] | AIInsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIInsightCreateOrConnectWithoutUserInput | AIInsightCreateOrConnectWithoutUserInput[]
    createMany?: AIInsightCreateManyUserInputEnvelope
    connect?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
  }

  export type AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AIUsageTrackingCreateWithoutUserInput, AIUsageTrackingUncheckedCreateWithoutUserInput> | AIUsageTrackingCreateWithoutUserInput[] | AIUsageTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIUsageTrackingCreateOrConnectWithoutUserInput | AIUsageTrackingCreateOrConnectWithoutUserInput[]
    createMany?: AIUsageTrackingCreateManyUserInputEnvelope
    connect?: AIUsageTrackingWhereUniqueInput | AIUsageTrackingWhereUniqueInput[]
  }

  export type basiq_usersUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<basiq_usersCreateWithoutUserInput, basiq_usersUncheckedCreateWithoutUserInput>
    connectOrCreate?: basiq_usersCreateOrConnectWithoutUserInput
    connect?: basiq_usersWhereUniqueInput
  }

  export type basiq_api_logsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<basiq_api_logsCreateWithoutUserInput, basiq_api_logsUncheckedCreateWithoutUserInput> | basiq_api_logsCreateWithoutUserInput[] | basiq_api_logsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: basiq_api_logsCreateOrConnectWithoutUserInput | basiq_api_logsCreateOrConnectWithoutUserInput[]
    createMany?: basiq_api_logsCreateManyUserInputEnvelope
    connect?: basiq_api_logsWhereUniqueInput | basiq_api_logsWhereUniqueInput[]
  }

  export type ReceiptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReceiptCreateWithoutUserInput, ReceiptUncheckedCreateWithoutUserInput> | ReceiptCreateWithoutUserInput[] | ReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutUserInput | ReceiptCreateOrConnectWithoutUserInput[]
    createMany?: ReceiptCreateManyUserInputEnvelope
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
  }

  export type BudgetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput> | BudgetCreateWithoutUserInput[] | BudgetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutUserInput | BudgetCreateOrConnectWithoutUserInput[]
    createMany?: BudgetCreateManyUserInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type BudgetTrackingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BudgetTrackingCreateWithoutUserInput, BudgetTrackingUncheckedCreateWithoutUserInput> | BudgetTrackingCreateWithoutUserInput[] | BudgetTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetTrackingCreateOrConnectWithoutUserInput | BudgetTrackingCreateOrConnectWithoutUserInput[]
    createMany?: BudgetTrackingCreateManyUserInputEnvelope
    connect?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
  }

  export type FinancialInsightUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FinancialInsightCreateWithoutUserInput, FinancialInsightUncheckedCreateWithoutUserInput> | FinancialInsightCreateWithoutUserInput[] | FinancialInsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinancialInsightCreateOrConnectWithoutUserInput | FinancialInsightCreateOrConnectWithoutUserInput[]
    createMany?: FinancialInsightCreateManyUserInputEnvelope
    connect?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
  }

  export type GoalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GoalCreateWithoutUserInput, GoalUncheckedCreateWithoutUserInput> | GoalCreateWithoutUserInput[] | GoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutUserInput | GoalCreateOrConnectWithoutUserInput[]
    createMany?: GoalCreateManyUserInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FinancialAuditLogCreateWithoutUserInput, FinancialAuditLogUncheckedCreateWithoutUserInput> | FinancialAuditLogCreateWithoutUserInput[] | FinancialAuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinancialAuditLogCreateOrConnectWithoutUserInput | FinancialAuditLogCreateOrConnectWithoutUserInput[]
    createMany?: FinancialAuditLogCreateManyUserInputEnvelope
    connect?: FinancialAuditLogWhereUniqueInput | FinancialAuditLogWhereUniqueInput[]
  }

  export type AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AMLTransactionMonitoringCreateWithoutUserInput, AMLTransactionMonitoringUncheckedCreateWithoutUserInput> | AMLTransactionMonitoringCreateWithoutUserInput[] | AMLTransactionMonitoringUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AMLTransactionMonitoringCreateOrConnectWithoutUserInput | AMLTransactionMonitoringCreateOrConnectWithoutUserInput[]
    createMany?: AMLTransactionMonitoringCreateManyUserInputEnvelope
    connect?: AMLTransactionMonitoringWhereUniqueInput | AMLTransactionMonitoringWhereUniqueInput[]
  }

  export type PrivacyConsentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PrivacyConsentCreateWithoutUserInput, PrivacyConsentUncheckedCreateWithoutUserInput> | PrivacyConsentCreateWithoutUserInput[] | PrivacyConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PrivacyConsentCreateOrConnectWithoutUserInput | PrivacyConsentCreateOrConnectWithoutUserInput[]
    createMany?: PrivacyConsentCreateManyUserInputEnvelope
    connect?: PrivacyConsentWhereUniqueInput | PrivacyConsentWhereUniqueInput[]
  }

  export type DataAccessRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DataAccessRequestCreateWithoutUserInput, DataAccessRequestUncheckedCreateWithoutUserInput> | DataAccessRequestCreateWithoutUserInput[] | DataAccessRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataAccessRequestCreateOrConnectWithoutUserInput | DataAccessRequestCreateOrConnectWithoutUserInput[]
    createMany?: DataAccessRequestCreateManyUserInputEnvelope
    connect?: DataAccessRequestWhereUniqueInput | DataAccessRequestWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EnumTaxResidencyFieldUpdateOperationsInput = {
    set?: $Enums.TaxResidency
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type TaxReturnUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaxReturnCreateWithoutUserInput, TaxReturnUncheckedCreateWithoutUserInput> | TaxReturnCreateWithoutUserInput[] | TaxReturnUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaxReturnCreateOrConnectWithoutUserInput | TaxReturnCreateOrConnectWithoutUserInput[]
    upsert?: TaxReturnUpsertWithWhereUniqueWithoutUserInput | TaxReturnUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaxReturnCreateManyUserInputEnvelope
    set?: TaxReturnWhereUniqueInput | TaxReturnWhereUniqueInput[]
    disconnect?: TaxReturnWhereUniqueInput | TaxReturnWhereUniqueInput[]
    delete?: TaxReturnWhereUniqueInput | TaxReturnWhereUniqueInput[]
    connect?: TaxReturnWhereUniqueInput | TaxReturnWhereUniqueInput[]
    update?: TaxReturnUpdateWithWhereUniqueWithoutUserInput | TaxReturnUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaxReturnUpdateManyWithWhereWithoutUserInput | TaxReturnUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaxReturnScalarWhereInput | TaxReturnScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type AIConversationUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIConversationCreateWithoutUserInput, AIConversationUncheckedCreateWithoutUserInput> | AIConversationCreateWithoutUserInput[] | AIConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIConversationCreateOrConnectWithoutUserInput | AIConversationCreateOrConnectWithoutUserInput[]
    upsert?: AIConversationUpsertWithWhereUniqueWithoutUserInput | AIConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIConversationCreateManyUserInputEnvelope
    set?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    disconnect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    delete?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    connect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    update?: AIConversationUpdateWithWhereUniqueWithoutUserInput | AIConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIConversationUpdateManyWithWhereWithoutUserInput | AIConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIConversationScalarWhereInput | AIConversationScalarWhereInput[]
  }

  export type AIInsightUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIInsightCreateWithoutUserInput, AIInsightUncheckedCreateWithoutUserInput> | AIInsightCreateWithoutUserInput[] | AIInsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIInsightCreateOrConnectWithoutUserInput | AIInsightCreateOrConnectWithoutUserInput[]
    upsert?: AIInsightUpsertWithWhereUniqueWithoutUserInput | AIInsightUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIInsightCreateManyUserInputEnvelope
    set?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    disconnect?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    delete?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    connect?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    update?: AIInsightUpdateWithWhereUniqueWithoutUserInput | AIInsightUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIInsightUpdateManyWithWhereWithoutUserInput | AIInsightUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIInsightScalarWhereInput | AIInsightScalarWhereInput[]
  }

  export type AIUsageTrackingUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIUsageTrackingCreateWithoutUserInput, AIUsageTrackingUncheckedCreateWithoutUserInput> | AIUsageTrackingCreateWithoutUserInput[] | AIUsageTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIUsageTrackingCreateOrConnectWithoutUserInput | AIUsageTrackingCreateOrConnectWithoutUserInput[]
    upsert?: AIUsageTrackingUpsertWithWhereUniqueWithoutUserInput | AIUsageTrackingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIUsageTrackingCreateManyUserInputEnvelope
    set?: AIUsageTrackingWhereUniqueInput | AIUsageTrackingWhereUniqueInput[]
    disconnect?: AIUsageTrackingWhereUniqueInput | AIUsageTrackingWhereUniqueInput[]
    delete?: AIUsageTrackingWhereUniqueInput | AIUsageTrackingWhereUniqueInput[]
    connect?: AIUsageTrackingWhereUniqueInput | AIUsageTrackingWhereUniqueInput[]
    update?: AIUsageTrackingUpdateWithWhereUniqueWithoutUserInput | AIUsageTrackingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIUsageTrackingUpdateManyWithWhereWithoutUserInput | AIUsageTrackingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIUsageTrackingScalarWhereInput | AIUsageTrackingScalarWhereInput[]
  }

  export type basiq_usersUpdateOneWithoutUserNestedInput = {
    create?: XOR<basiq_usersCreateWithoutUserInput, basiq_usersUncheckedCreateWithoutUserInput>
    connectOrCreate?: basiq_usersCreateOrConnectWithoutUserInput
    upsert?: basiq_usersUpsertWithoutUserInput
    disconnect?: basiq_usersWhereInput | boolean
    delete?: basiq_usersWhereInput | boolean
    connect?: basiq_usersWhereUniqueInput
    update?: XOR<XOR<basiq_usersUpdateToOneWithWhereWithoutUserInput, basiq_usersUpdateWithoutUserInput>, basiq_usersUncheckedUpdateWithoutUserInput>
  }

  export type basiq_api_logsUpdateManyWithoutUserNestedInput = {
    create?: XOR<basiq_api_logsCreateWithoutUserInput, basiq_api_logsUncheckedCreateWithoutUserInput> | basiq_api_logsCreateWithoutUserInput[] | basiq_api_logsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: basiq_api_logsCreateOrConnectWithoutUserInput | basiq_api_logsCreateOrConnectWithoutUserInput[]
    upsert?: basiq_api_logsUpsertWithWhereUniqueWithoutUserInput | basiq_api_logsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: basiq_api_logsCreateManyUserInputEnvelope
    set?: basiq_api_logsWhereUniqueInput | basiq_api_logsWhereUniqueInput[]
    disconnect?: basiq_api_logsWhereUniqueInput | basiq_api_logsWhereUniqueInput[]
    delete?: basiq_api_logsWhereUniqueInput | basiq_api_logsWhereUniqueInput[]
    connect?: basiq_api_logsWhereUniqueInput | basiq_api_logsWhereUniqueInput[]
    update?: basiq_api_logsUpdateWithWhereUniqueWithoutUserInput | basiq_api_logsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: basiq_api_logsUpdateManyWithWhereWithoutUserInput | basiq_api_logsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: basiq_api_logsScalarWhereInput | basiq_api_logsScalarWhereInput[]
  }

  export type ReceiptUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReceiptCreateWithoutUserInput, ReceiptUncheckedCreateWithoutUserInput> | ReceiptCreateWithoutUserInput[] | ReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutUserInput | ReceiptCreateOrConnectWithoutUserInput[]
    upsert?: ReceiptUpsertWithWhereUniqueWithoutUserInput | ReceiptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReceiptCreateManyUserInputEnvelope
    set?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    disconnect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    delete?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    update?: ReceiptUpdateWithWhereUniqueWithoutUserInput | ReceiptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReceiptUpdateManyWithWhereWithoutUserInput | ReceiptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
  }

  export type BudgetUpdateManyWithoutUserNestedInput = {
    create?: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput> | BudgetCreateWithoutUserInput[] | BudgetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutUserInput | BudgetCreateOrConnectWithoutUserInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutUserInput | BudgetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BudgetCreateManyUserInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutUserInput | BudgetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutUserInput | BudgetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type BudgetTrackingUpdateManyWithoutUserNestedInput = {
    create?: XOR<BudgetTrackingCreateWithoutUserInput, BudgetTrackingUncheckedCreateWithoutUserInput> | BudgetTrackingCreateWithoutUserInput[] | BudgetTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetTrackingCreateOrConnectWithoutUserInput | BudgetTrackingCreateOrConnectWithoutUserInput[]
    upsert?: BudgetTrackingUpsertWithWhereUniqueWithoutUserInput | BudgetTrackingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BudgetTrackingCreateManyUserInputEnvelope
    set?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
    disconnect?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
    delete?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
    connect?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
    update?: BudgetTrackingUpdateWithWhereUniqueWithoutUserInput | BudgetTrackingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BudgetTrackingUpdateManyWithWhereWithoutUserInput | BudgetTrackingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BudgetTrackingScalarWhereInput | BudgetTrackingScalarWhereInput[]
  }

  export type FinancialInsightUpdateManyWithoutUserNestedInput = {
    create?: XOR<FinancialInsightCreateWithoutUserInput, FinancialInsightUncheckedCreateWithoutUserInput> | FinancialInsightCreateWithoutUserInput[] | FinancialInsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinancialInsightCreateOrConnectWithoutUserInput | FinancialInsightCreateOrConnectWithoutUserInput[]
    upsert?: FinancialInsightUpsertWithWhereUniqueWithoutUserInput | FinancialInsightUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FinancialInsightCreateManyUserInputEnvelope
    set?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
    disconnect?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
    delete?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
    connect?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
    update?: FinancialInsightUpdateWithWhereUniqueWithoutUserInput | FinancialInsightUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FinancialInsightUpdateManyWithWhereWithoutUserInput | FinancialInsightUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FinancialInsightScalarWhereInput | FinancialInsightScalarWhereInput[]
  }

  export type GoalUpdateManyWithoutUserNestedInput = {
    create?: XOR<GoalCreateWithoutUserInput, GoalUncheckedCreateWithoutUserInput> | GoalCreateWithoutUserInput[] | GoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutUserInput | GoalCreateOrConnectWithoutUserInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutUserInput | GoalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GoalCreateManyUserInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutUserInput | GoalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutUserInput | GoalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type FinancialAuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<FinancialAuditLogCreateWithoutUserInput, FinancialAuditLogUncheckedCreateWithoutUserInput> | FinancialAuditLogCreateWithoutUserInput[] | FinancialAuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinancialAuditLogCreateOrConnectWithoutUserInput | FinancialAuditLogCreateOrConnectWithoutUserInput[]
    upsert?: FinancialAuditLogUpsertWithWhereUniqueWithoutUserInput | FinancialAuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FinancialAuditLogCreateManyUserInputEnvelope
    set?: FinancialAuditLogWhereUniqueInput | FinancialAuditLogWhereUniqueInput[]
    disconnect?: FinancialAuditLogWhereUniqueInput | FinancialAuditLogWhereUniqueInput[]
    delete?: FinancialAuditLogWhereUniqueInput | FinancialAuditLogWhereUniqueInput[]
    connect?: FinancialAuditLogWhereUniqueInput | FinancialAuditLogWhereUniqueInput[]
    update?: FinancialAuditLogUpdateWithWhereUniqueWithoutUserInput | FinancialAuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FinancialAuditLogUpdateManyWithWhereWithoutUserInput | FinancialAuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FinancialAuditLogScalarWhereInput | FinancialAuditLogScalarWhereInput[]
  }

  export type AMLTransactionMonitoringUpdateManyWithoutUserNestedInput = {
    create?: XOR<AMLTransactionMonitoringCreateWithoutUserInput, AMLTransactionMonitoringUncheckedCreateWithoutUserInput> | AMLTransactionMonitoringCreateWithoutUserInput[] | AMLTransactionMonitoringUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AMLTransactionMonitoringCreateOrConnectWithoutUserInput | AMLTransactionMonitoringCreateOrConnectWithoutUserInput[]
    upsert?: AMLTransactionMonitoringUpsertWithWhereUniqueWithoutUserInput | AMLTransactionMonitoringUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AMLTransactionMonitoringCreateManyUserInputEnvelope
    set?: AMLTransactionMonitoringWhereUniqueInput | AMLTransactionMonitoringWhereUniqueInput[]
    disconnect?: AMLTransactionMonitoringWhereUniqueInput | AMLTransactionMonitoringWhereUniqueInput[]
    delete?: AMLTransactionMonitoringWhereUniqueInput | AMLTransactionMonitoringWhereUniqueInput[]
    connect?: AMLTransactionMonitoringWhereUniqueInput | AMLTransactionMonitoringWhereUniqueInput[]
    update?: AMLTransactionMonitoringUpdateWithWhereUniqueWithoutUserInput | AMLTransactionMonitoringUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AMLTransactionMonitoringUpdateManyWithWhereWithoutUserInput | AMLTransactionMonitoringUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AMLTransactionMonitoringScalarWhereInput | AMLTransactionMonitoringScalarWhereInput[]
  }

  export type PrivacyConsentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PrivacyConsentCreateWithoutUserInput, PrivacyConsentUncheckedCreateWithoutUserInput> | PrivacyConsentCreateWithoutUserInput[] | PrivacyConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PrivacyConsentCreateOrConnectWithoutUserInput | PrivacyConsentCreateOrConnectWithoutUserInput[]
    upsert?: PrivacyConsentUpsertWithWhereUniqueWithoutUserInput | PrivacyConsentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PrivacyConsentCreateManyUserInputEnvelope
    set?: PrivacyConsentWhereUniqueInput | PrivacyConsentWhereUniqueInput[]
    disconnect?: PrivacyConsentWhereUniqueInput | PrivacyConsentWhereUniqueInput[]
    delete?: PrivacyConsentWhereUniqueInput | PrivacyConsentWhereUniqueInput[]
    connect?: PrivacyConsentWhereUniqueInput | PrivacyConsentWhereUniqueInput[]
    update?: PrivacyConsentUpdateWithWhereUniqueWithoutUserInput | PrivacyConsentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PrivacyConsentUpdateManyWithWhereWithoutUserInput | PrivacyConsentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PrivacyConsentScalarWhereInput | PrivacyConsentScalarWhereInput[]
  }

  export type DataAccessRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<DataAccessRequestCreateWithoutUserInput, DataAccessRequestUncheckedCreateWithoutUserInput> | DataAccessRequestCreateWithoutUserInput[] | DataAccessRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataAccessRequestCreateOrConnectWithoutUserInput | DataAccessRequestCreateOrConnectWithoutUserInput[]
    upsert?: DataAccessRequestUpsertWithWhereUniqueWithoutUserInput | DataAccessRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DataAccessRequestCreateManyUserInputEnvelope
    set?: DataAccessRequestWhereUniqueInput | DataAccessRequestWhereUniqueInput[]
    disconnect?: DataAccessRequestWhereUniqueInput | DataAccessRequestWhereUniqueInput[]
    delete?: DataAccessRequestWhereUniqueInput | DataAccessRequestWhereUniqueInput[]
    connect?: DataAccessRequestWhereUniqueInput | DataAccessRequestWhereUniqueInput[]
    update?: DataAccessRequestUpdateWithWhereUniqueWithoutUserInput | DataAccessRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DataAccessRequestUpdateManyWithWhereWithoutUserInput | DataAccessRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DataAccessRequestScalarWhereInput | DataAccessRequestScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type TaxReturnUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaxReturnCreateWithoutUserInput, TaxReturnUncheckedCreateWithoutUserInput> | TaxReturnCreateWithoutUserInput[] | TaxReturnUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaxReturnCreateOrConnectWithoutUserInput | TaxReturnCreateOrConnectWithoutUserInput[]
    upsert?: TaxReturnUpsertWithWhereUniqueWithoutUserInput | TaxReturnUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaxReturnCreateManyUserInputEnvelope
    set?: TaxReturnWhereUniqueInput | TaxReturnWhereUniqueInput[]
    disconnect?: TaxReturnWhereUniqueInput | TaxReturnWhereUniqueInput[]
    delete?: TaxReturnWhereUniqueInput | TaxReturnWhereUniqueInput[]
    connect?: TaxReturnWhereUniqueInput | TaxReturnWhereUniqueInput[]
    update?: TaxReturnUpdateWithWhereUniqueWithoutUserInput | TaxReturnUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaxReturnUpdateManyWithWhereWithoutUserInput | TaxReturnUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaxReturnScalarWhereInput | TaxReturnScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type AIConversationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIConversationCreateWithoutUserInput, AIConversationUncheckedCreateWithoutUserInput> | AIConversationCreateWithoutUserInput[] | AIConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIConversationCreateOrConnectWithoutUserInput | AIConversationCreateOrConnectWithoutUserInput[]
    upsert?: AIConversationUpsertWithWhereUniqueWithoutUserInput | AIConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIConversationCreateManyUserInputEnvelope
    set?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    disconnect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    delete?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    connect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    update?: AIConversationUpdateWithWhereUniqueWithoutUserInput | AIConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIConversationUpdateManyWithWhereWithoutUserInput | AIConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIConversationScalarWhereInput | AIConversationScalarWhereInput[]
  }

  export type AIInsightUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIInsightCreateWithoutUserInput, AIInsightUncheckedCreateWithoutUserInput> | AIInsightCreateWithoutUserInput[] | AIInsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIInsightCreateOrConnectWithoutUserInput | AIInsightCreateOrConnectWithoutUserInput[]
    upsert?: AIInsightUpsertWithWhereUniqueWithoutUserInput | AIInsightUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIInsightCreateManyUserInputEnvelope
    set?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    disconnect?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    delete?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    connect?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    update?: AIInsightUpdateWithWhereUniqueWithoutUserInput | AIInsightUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIInsightUpdateManyWithWhereWithoutUserInput | AIInsightUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIInsightScalarWhereInput | AIInsightScalarWhereInput[]
  }

  export type AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIUsageTrackingCreateWithoutUserInput, AIUsageTrackingUncheckedCreateWithoutUserInput> | AIUsageTrackingCreateWithoutUserInput[] | AIUsageTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIUsageTrackingCreateOrConnectWithoutUserInput | AIUsageTrackingCreateOrConnectWithoutUserInput[]
    upsert?: AIUsageTrackingUpsertWithWhereUniqueWithoutUserInput | AIUsageTrackingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIUsageTrackingCreateManyUserInputEnvelope
    set?: AIUsageTrackingWhereUniqueInput | AIUsageTrackingWhereUniqueInput[]
    disconnect?: AIUsageTrackingWhereUniqueInput | AIUsageTrackingWhereUniqueInput[]
    delete?: AIUsageTrackingWhereUniqueInput | AIUsageTrackingWhereUniqueInput[]
    connect?: AIUsageTrackingWhereUniqueInput | AIUsageTrackingWhereUniqueInput[]
    update?: AIUsageTrackingUpdateWithWhereUniqueWithoutUserInput | AIUsageTrackingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIUsageTrackingUpdateManyWithWhereWithoutUserInput | AIUsageTrackingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIUsageTrackingScalarWhereInput | AIUsageTrackingScalarWhereInput[]
  }

  export type basiq_usersUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<basiq_usersCreateWithoutUserInput, basiq_usersUncheckedCreateWithoutUserInput>
    connectOrCreate?: basiq_usersCreateOrConnectWithoutUserInput
    upsert?: basiq_usersUpsertWithoutUserInput
    disconnect?: basiq_usersWhereInput | boolean
    delete?: basiq_usersWhereInput | boolean
    connect?: basiq_usersWhereUniqueInput
    update?: XOR<XOR<basiq_usersUpdateToOneWithWhereWithoutUserInput, basiq_usersUpdateWithoutUserInput>, basiq_usersUncheckedUpdateWithoutUserInput>
  }

  export type basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<basiq_api_logsCreateWithoutUserInput, basiq_api_logsUncheckedCreateWithoutUserInput> | basiq_api_logsCreateWithoutUserInput[] | basiq_api_logsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: basiq_api_logsCreateOrConnectWithoutUserInput | basiq_api_logsCreateOrConnectWithoutUserInput[]
    upsert?: basiq_api_logsUpsertWithWhereUniqueWithoutUserInput | basiq_api_logsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: basiq_api_logsCreateManyUserInputEnvelope
    set?: basiq_api_logsWhereUniqueInput | basiq_api_logsWhereUniqueInput[]
    disconnect?: basiq_api_logsWhereUniqueInput | basiq_api_logsWhereUniqueInput[]
    delete?: basiq_api_logsWhereUniqueInput | basiq_api_logsWhereUniqueInput[]
    connect?: basiq_api_logsWhereUniqueInput | basiq_api_logsWhereUniqueInput[]
    update?: basiq_api_logsUpdateWithWhereUniqueWithoutUserInput | basiq_api_logsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: basiq_api_logsUpdateManyWithWhereWithoutUserInput | basiq_api_logsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: basiq_api_logsScalarWhereInput | basiq_api_logsScalarWhereInput[]
  }

  export type ReceiptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReceiptCreateWithoutUserInput, ReceiptUncheckedCreateWithoutUserInput> | ReceiptCreateWithoutUserInput[] | ReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutUserInput | ReceiptCreateOrConnectWithoutUserInput[]
    upsert?: ReceiptUpsertWithWhereUniqueWithoutUserInput | ReceiptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReceiptCreateManyUserInputEnvelope
    set?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    disconnect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    delete?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    update?: ReceiptUpdateWithWhereUniqueWithoutUserInput | ReceiptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReceiptUpdateManyWithWhereWithoutUserInput | ReceiptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
  }

  export type BudgetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput> | BudgetCreateWithoutUserInput[] | BudgetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutUserInput | BudgetCreateOrConnectWithoutUserInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutUserInput | BudgetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BudgetCreateManyUserInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutUserInput | BudgetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutUserInput | BudgetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BudgetTrackingCreateWithoutUserInput, BudgetTrackingUncheckedCreateWithoutUserInput> | BudgetTrackingCreateWithoutUserInput[] | BudgetTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetTrackingCreateOrConnectWithoutUserInput | BudgetTrackingCreateOrConnectWithoutUserInput[]
    upsert?: BudgetTrackingUpsertWithWhereUniqueWithoutUserInput | BudgetTrackingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BudgetTrackingCreateManyUserInputEnvelope
    set?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
    disconnect?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
    delete?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
    connect?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
    update?: BudgetTrackingUpdateWithWhereUniqueWithoutUserInput | BudgetTrackingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BudgetTrackingUpdateManyWithWhereWithoutUserInput | BudgetTrackingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BudgetTrackingScalarWhereInput | BudgetTrackingScalarWhereInput[]
  }

  export type FinancialInsightUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FinancialInsightCreateWithoutUserInput, FinancialInsightUncheckedCreateWithoutUserInput> | FinancialInsightCreateWithoutUserInput[] | FinancialInsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinancialInsightCreateOrConnectWithoutUserInput | FinancialInsightCreateOrConnectWithoutUserInput[]
    upsert?: FinancialInsightUpsertWithWhereUniqueWithoutUserInput | FinancialInsightUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FinancialInsightCreateManyUserInputEnvelope
    set?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
    disconnect?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
    delete?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
    connect?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
    update?: FinancialInsightUpdateWithWhereUniqueWithoutUserInput | FinancialInsightUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FinancialInsightUpdateManyWithWhereWithoutUserInput | FinancialInsightUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FinancialInsightScalarWhereInput | FinancialInsightScalarWhereInput[]
  }

  export type GoalUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GoalCreateWithoutUserInput, GoalUncheckedCreateWithoutUserInput> | GoalCreateWithoutUserInput[] | GoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutUserInput | GoalCreateOrConnectWithoutUserInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutUserInput | GoalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GoalCreateManyUserInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutUserInput | GoalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutUserInput | GoalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FinancialAuditLogCreateWithoutUserInput, FinancialAuditLogUncheckedCreateWithoutUserInput> | FinancialAuditLogCreateWithoutUserInput[] | FinancialAuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinancialAuditLogCreateOrConnectWithoutUserInput | FinancialAuditLogCreateOrConnectWithoutUserInput[]
    upsert?: FinancialAuditLogUpsertWithWhereUniqueWithoutUserInput | FinancialAuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FinancialAuditLogCreateManyUserInputEnvelope
    set?: FinancialAuditLogWhereUniqueInput | FinancialAuditLogWhereUniqueInput[]
    disconnect?: FinancialAuditLogWhereUniqueInput | FinancialAuditLogWhereUniqueInput[]
    delete?: FinancialAuditLogWhereUniqueInput | FinancialAuditLogWhereUniqueInput[]
    connect?: FinancialAuditLogWhereUniqueInput | FinancialAuditLogWhereUniqueInput[]
    update?: FinancialAuditLogUpdateWithWhereUniqueWithoutUserInput | FinancialAuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FinancialAuditLogUpdateManyWithWhereWithoutUserInput | FinancialAuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FinancialAuditLogScalarWhereInput | FinancialAuditLogScalarWhereInput[]
  }

  export type AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AMLTransactionMonitoringCreateWithoutUserInput, AMLTransactionMonitoringUncheckedCreateWithoutUserInput> | AMLTransactionMonitoringCreateWithoutUserInput[] | AMLTransactionMonitoringUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AMLTransactionMonitoringCreateOrConnectWithoutUserInput | AMLTransactionMonitoringCreateOrConnectWithoutUserInput[]
    upsert?: AMLTransactionMonitoringUpsertWithWhereUniqueWithoutUserInput | AMLTransactionMonitoringUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AMLTransactionMonitoringCreateManyUserInputEnvelope
    set?: AMLTransactionMonitoringWhereUniqueInput | AMLTransactionMonitoringWhereUniqueInput[]
    disconnect?: AMLTransactionMonitoringWhereUniqueInput | AMLTransactionMonitoringWhereUniqueInput[]
    delete?: AMLTransactionMonitoringWhereUniqueInput | AMLTransactionMonitoringWhereUniqueInput[]
    connect?: AMLTransactionMonitoringWhereUniqueInput | AMLTransactionMonitoringWhereUniqueInput[]
    update?: AMLTransactionMonitoringUpdateWithWhereUniqueWithoutUserInput | AMLTransactionMonitoringUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AMLTransactionMonitoringUpdateManyWithWhereWithoutUserInput | AMLTransactionMonitoringUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AMLTransactionMonitoringScalarWhereInput | AMLTransactionMonitoringScalarWhereInput[]
  }

  export type PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PrivacyConsentCreateWithoutUserInput, PrivacyConsentUncheckedCreateWithoutUserInput> | PrivacyConsentCreateWithoutUserInput[] | PrivacyConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PrivacyConsentCreateOrConnectWithoutUserInput | PrivacyConsentCreateOrConnectWithoutUserInput[]
    upsert?: PrivacyConsentUpsertWithWhereUniqueWithoutUserInput | PrivacyConsentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PrivacyConsentCreateManyUserInputEnvelope
    set?: PrivacyConsentWhereUniqueInput | PrivacyConsentWhereUniqueInput[]
    disconnect?: PrivacyConsentWhereUniqueInput | PrivacyConsentWhereUniqueInput[]
    delete?: PrivacyConsentWhereUniqueInput | PrivacyConsentWhereUniqueInput[]
    connect?: PrivacyConsentWhereUniqueInput | PrivacyConsentWhereUniqueInput[]
    update?: PrivacyConsentUpdateWithWhereUniqueWithoutUserInput | PrivacyConsentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PrivacyConsentUpdateManyWithWhereWithoutUserInput | PrivacyConsentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PrivacyConsentScalarWhereInput | PrivacyConsentScalarWhereInput[]
  }

  export type DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DataAccessRequestCreateWithoutUserInput, DataAccessRequestUncheckedCreateWithoutUserInput> | DataAccessRequestCreateWithoutUserInput[] | DataAccessRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataAccessRequestCreateOrConnectWithoutUserInput | DataAccessRequestCreateOrConnectWithoutUserInput[]
    upsert?: DataAccessRequestUpsertWithWhereUniqueWithoutUserInput | DataAccessRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DataAccessRequestCreateManyUserInputEnvelope
    set?: DataAccessRequestWhereUniqueInput | DataAccessRequestWhereUniqueInput[]
    disconnect?: DataAccessRequestWhereUniqueInput | DataAccessRequestWhereUniqueInput[]
    delete?: DataAccessRequestWhereUniqueInput | DataAccessRequestWhereUniqueInput[]
    connect?: DataAccessRequestWhereUniqueInput | DataAccessRequestWhereUniqueInput[]
    update?: DataAccessRequestUpdateWithWhereUniqueWithoutUserInput | DataAccessRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DataAccessRequestUpdateManyWithWhereWithoutUserInput | DataAccessRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DataAccessRequestScalarWhereInput | DataAccessRequestScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuthEventFieldUpdateOperationsInput = {
    set?: $Enums.AuthEvent
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type FinancialAuditLogCreatechangedFieldsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutFinancialAuditLogsInput = {
    create?: XOR<UserCreateWithoutFinancialAuditLogsInput, UserUncheckedCreateWithoutFinancialAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFinancialAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFinancialOperationFieldUpdateOperationsInput = {
    set?: $Enums.FinancialOperation
  }

  export type FinancialAuditLogUpdatechangedFieldsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutFinancialAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutFinancialAuditLogsInput, UserUncheckedCreateWithoutFinancialAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFinancialAuditLogsInput
    upsert?: UserUpsertWithoutFinancialAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFinancialAuditLogsInput, UserUpdateWithoutFinancialAuditLogsInput>, UserUncheckedUpdateWithoutFinancialAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPlanFieldUpdateOperationsInput = {
    set?: $Enums.Plan
  }

  export type UserUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionsInput, UserUpdateWithoutSubscriptionsInput>, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserCreateNestedOneWithoutTaxReturnsInput = {
    create?: XOR<UserCreateWithoutTaxReturnsInput, UserUncheckedCreateWithoutTaxReturnsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaxReturnsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTaxReturnStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaxReturnStatus
  }

  export type UserUpdateOneRequiredWithoutTaxReturnsNestedInput = {
    create?: XOR<UserCreateWithoutTaxReturnsInput, UserUncheckedCreateWithoutTaxReturnsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaxReturnsInput
    upsert?: UserUpsertWithoutTaxReturnsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaxReturnsInput, UserUpdateWithoutTaxReturnsInput>, UserUncheckedUpdateWithoutTaxReturnsInput>
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceLineItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceLineItemCreateWithoutInvoiceInput, InvoiceLineItemUncheckedCreateWithoutInvoiceInput> | InvoiceLineItemCreateWithoutInvoiceInput[] | InvoiceLineItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineItemCreateOrConnectWithoutInvoiceInput | InvoiceLineItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceLineItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
  }

  export type InvoiceLineItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceLineItemCreateWithoutInvoiceInput, InvoiceLineItemUncheckedCreateWithoutInvoiceInput> | InvoiceLineItemCreateWithoutInvoiceInput[] | InvoiceLineItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineItemCreateOrConnectWithoutInvoiceInput | InvoiceLineItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceLineItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
  }

  export type InvoiceLineItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceLineItemCreateWithoutInvoiceInput, InvoiceLineItemUncheckedCreateWithoutInvoiceInput> | InvoiceLineItemCreateWithoutInvoiceInput[] | InvoiceLineItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineItemCreateOrConnectWithoutInvoiceInput | InvoiceLineItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceLineItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceLineItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceLineItemCreateManyInvoiceInputEnvelope
    set?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    disconnect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    delete?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    connect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    update?: InvoiceLineItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceLineItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceLineItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceLineItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceLineItemScalarWhereInput | InvoiceLineItemScalarWhereInput[]
  }

  export type InvoiceLineItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceLineItemCreateWithoutInvoiceInput, InvoiceLineItemUncheckedCreateWithoutInvoiceInput> | InvoiceLineItemCreateWithoutInvoiceInput[] | InvoiceLineItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineItemCreateOrConnectWithoutInvoiceInput | InvoiceLineItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceLineItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceLineItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceLineItemCreateManyInvoiceInputEnvelope
    set?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    disconnect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    delete?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    connect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    update?: InvoiceLineItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceLineItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceLineItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceLineItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceLineItemScalarWhereInput | InvoiceLineItemScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutLineItemsInput = {
    create?: XOR<InvoiceCreateWithoutLineItemsInput, InvoiceUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLineItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutLineItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutLineItemsInput, InvoiceUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLineItemsInput
    upsert?: InvoiceUpsertWithoutLineItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutLineItemsInput, InvoiceUpdateWithoutLineItemsInput>, InvoiceUncheckedUpdateWithoutLineItemsInput>
  }

  export type UserCreateNestedOneWithoutAiConversationsInput = {
    create?: XOR<UserCreateWithoutAiConversationsInput, UserUncheckedCreateWithoutAiConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutAiConversationsNestedInput = {
    create?: XOR<UserCreateWithoutAiConversationsInput, UserUncheckedCreateWithoutAiConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiConversationsInput
    upsert?: UserUpsertWithoutAiConversationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAiConversationsInput, UserUpdateWithoutAiConversationsInput>, UserUncheckedUpdateWithoutAiConversationsInput>
  }

  export type AIInsightCreatesourceDataIdsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAiInsightsInput = {
    create?: XOR<UserCreateWithoutAiInsightsInput, UserUncheckedCreateWithoutAiInsightsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiInsightsInput
    connect?: UserWhereUniqueInput
  }

  export type AIInsightUpdatesourceDataIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutAiInsightsNestedInput = {
    create?: XOR<UserCreateWithoutAiInsightsInput, UserUncheckedCreateWithoutAiInsightsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiInsightsInput
    upsert?: UserUpsertWithoutAiInsightsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAiInsightsInput, UserUpdateWithoutAiInsightsInput>, UserUncheckedUpdateWithoutAiInsightsInput>
  }

  export type UserCreateNestedOneWithoutAiUsageTrackingInput = {
    create?: XOR<UserCreateWithoutAiUsageTrackingInput, UserUncheckedCreateWithoutAiUsageTrackingInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiUsageTrackingInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAiUsageTrackingNestedInput = {
    create?: XOR<UserCreateWithoutAiUsageTrackingInput, UserUncheckedCreateWithoutAiUsageTrackingInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiUsageTrackingInput
    upsert?: UserUpsertWithoutAiUsageTrackingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAiUsageTrackingInput, UserUpdateWithoutAiUsageTrackingInput>, UserUncheckedUpdateWithoutAiUsageTrackingInput>
  }

  export type UserCreateNestedOneWithoutBasiq_usersInput = {
    create?: XOR<UserCreateWithoutBasiq_usersInput, UserUncheckedCreateWithoutBasiq_usersInput>
    connectOrCreate?: UserCreateOrConnectWithoutBasiq_usersInput
    connect?: UserWhereUniqueInput
  }

  export type bank_connectionsCreateNestedManyWithoutBasiq_userInput = {
    create?: XOR<bank_connectionsCreateWithoutBasiq_userInput, bank_connectionsUncheckedCreateWithoutBasiq_userInput> | bank_connectionsCreateWithoutBasiq_userInput[] | bank_connectionsUncheckedCreateWithoutBasiq_userInput[]
    connectOrCreate?: bank_connectionsCreateOrConnectWithoutBasiq_userInput | bank_connectionsCreateOrConnectWithoutBasiq_userInput[]
    createMany?: bank_connectionsCreateManyBasiq_userInputEnvelope
    connect?: bank_connectionsWhereUniqueInput | bank_connectionsWhereUniqueInput[]
  }

  export type bank_accountsCreateNestedManyWithoutBasiq_userInput = {
    create?: XOR<bank_accountsCreateWithoutBasiq_userInput, bank_accountsUncheckedCreateWithoutBasiq_userInput> | bank_accountsCreateWithoutBasiq_userInput[] | bank_accountsUncheckedCreateWithoutBasiq_userInput[]
    connectOrCreate?: bank_accountsCreateOrConnectWithoutBasiq_userInput | bank_accountsCreateOrConnectWithoutBasiq_userInput[]
    createMany?: bank_accountsCreateManyBasiq_userInputEnvelope
    connect?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
  }

  export type bank_connectionsUncheckedCreateNestedManyWithoutBasiq_userInput = {
    create?: XOR<bank_connectionsCreateWithoutBasiq_userInput, bank_connectionsUncheckedCreateWithoutBasiq_userInput> | bank_connectionsCreateWithoutBasiq_userInput[] | bank_connectionsUncheckedCreateWithoutBasiq_userInput[]
    connectOrCreate?: bank_connectionsCreateOrConnectWithoutBasiq_userInput | bank_connectionsCreateOrConnectWithoutBasiq_userInput[]
    createMany?: bank_connectionsCreateManyBasiq_userInputEnvelope
    connect?: bank_connectionsWhereUniqueInput | bank_connectionsWhereUniqueInput[]
  }

  export type bank_accountsUncheckedCreateNestedManyWithoutBasiq_userInput = {
    create?: XOR<bank_accountsCreateWithoutBasiq_userInput, bank_accountsUncheckedCreateWithoutBasiq_userInput> | bank_accountsCreateWithoutBasiq_userInput[] | bank_accountsUncheckedCreateWithoutBasiq_userInput[]
    connectOrCreate?: bank_accountsCreateOrConnectWithoutBasiq_userInput | bank_accountsCreateOrConnectWithoutBasiq_userInput[]
    createMany?: bank_accountsCreateManyBasiq_userInputEnvelope
    connect?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutBasiq_usersNestedInput = {
    create?: XOR<UserCreateWithoutBasiq_usersInput, UserUncheckedCreateWithoutBasiq_usersInput>
    connectOrCreate?: UserCreateOrConnectWithoutBasiq_usersInput
    upsert?: UserUpsertWithoutBasiq_usersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBasiq_usersInput, UserUpdateWithoutBasiq_usersInput>, UserUncheckedUpdateWithoutBasiq_usersInput>
  }

  export type bank_connectionsUpdateManyWithoutBasiq_userNestedInput = {
    create?: XOR<bank_connectionsCreateWithoutBasiq_userInput, bank_connectionsUncheckedCreateWithoutBasiq_userInput> | bank_connectionsCreateWithoutBasiq_userInput[] | bank_connectionsUncheckedCreateWithoutBasiq_userInput[]
    connectOrCreate?: bank_connectionsCreateOrConnectWithoutBasiq_userInput | bank_connectionsCreateOrConnectWithoutBasiq_userInput[]
    upsert?: bank_connectionsUpsertWithWhereUniqueWithoutBasiq_userInput | bank_connectionsUpsertWithWhereUniqueWithoutBasiq_userInput[]
    createMany?: bank_connectionsCreateManyBasiq_userInputEnvelope
    set?: bank_connectionsWhereUniqueInput | bank_connectionsWhereUniqueInput[]
    disconnect?: bank_connectionsWhereUniqueInput | bank_connectionsWhereUniqueInput[]
    delete?: bank_connectionsWhereUniqueInput | bank_connectionsWhereUniqueInput[]
    connect?: bank_connectionsWhereUniqueInput | bank_connectionsWhereUniqueInput[]
    update?: bank_connectionsUpdateWithWhereUniqueWithoutBasiq_userInput | bank_connectionsUpdateWithWhereUniqueWithoutBasiq_userInput[]
    updateMany?: bank_connectionsUpdateManyWithWhereWithoutBasiq_userInput | bank_connectionsUpdateManyWithWhereWithoutBasiq_userInput[]
    deleteMany?: bank_connectionsScalarWhereInput | bank_connectionsScalarWhereInput[]
  }

  export type bank_accountsUpdateManyWithoutBasiq_userNestedInput = {
    create?: XOR<bank_accountsCreateWithoutBasiq_userInput, bank_accountsUncheckedCreateWithoutBasiq_userInput> | bank_accountsCreateWithoutBasiq_userInput[] | bank_accountsUncheckedCreateWithoutBasiq_userInput[]
    connectOrCreate?: bank_accountsCreateOrConnectWithoutBasiq_userInput | bank_accountsCreateOrConnectWithoutBasiq_userInput[]
    upsert?: bank_accountsUpsertWithWhereUniqueWithoutBasiq_userInput | bank_accountsUpsertWithWhereUniqueWithoutBasiq_userInput[]
    createMany?: bank_accountsCreateManyBasiq_userInputEnvelope
    set?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    disconnect?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    delete?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    connect?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    update?: bank_accountsUpdateWithWhereUniqueWithoutBasiq_userInput | bank_accountsUpdateWithWhereUniqueWithoutBasiq_userInput[]
    updateMany?: bank_accountsUpdateManyWithWhereWithoutBasiq_userInput | bank_accountsUpdateManyWithWhereWithoutBasiq_userInput[]
    deleteMany?: bank_accountsScalarWhereInput | bank_accountsScalarWhereInput[]
  }

  export type bank_connectionsUncheckedUpdateManyWithoutBasiq_userNestedInput = {
    create?: XOR<bank_connectionsCreateWithoutBasiq_userInput, bank_connectionsUncheckedCreateWithoutBasiq_userInput> | bank_connectionsCreateWithoutBasiq_userInput[] | bank_connectionsUncheckedCreateWithoutBasiq_userInput[]
    connectOrCreate?: bank_connectionsCreateOrConnectWithoutBasiq_userInput | bank_connectionsCreateOrConnectWithoutBasiq_userInput[]
    upsert?: bank_connectionsUpsertWithWhereUniqueWithoutBasiq_userInput | bank_connectionsUpsertWithWhereUniqueWithoutBasiq_userInput[]
    createMany?: bank_connectionsCreateManyBasiq_userInputEnvelope
    set?: bank_connectionsWhereUniqueInput | bank_connectionsWhereUniqueInput[]
    disconnect?: bank_connectionsWhereUniqueInput | bank_connectionsWhereUniqueInput[]
    delete?: bank_connectionsWhereUniqueInput | bank_connectionsWhereUniqueInput[]
    connect?: bank_connectionsWhereUniqueInput | bank_connectionsWhereUniqueInput[]
    update?: bank_connectionsUpdateWithWhereUniqueWithoutBasiq_userInput | bank_connectionsUpdateWithWhereUniqueWithoutBasiq_userInput[]
    updateMany?: bank_connectionsUpdateManyWithWhereWithoutBasiq_userInput | bank_connectionsUpdateManyWithWhereWithoutBasiq_userInput[]
    deleteMany?: bank_connectionsScalarWhereInput | bank_connectionsScalarWhereInput[]
  }

  export type bank_accountsUncheckedUpdateManyWithoutBasiq_userNestedInput = {
    create?: XOR<bank_accountsCreateWithoutBasiq_userInput, bank_accountsUncheckedCreateWithoutBasiq_userInput> | bank_accountsCreateWithoutBasiq_userInput[] | bank_accountsUncheckedCreateWithoutBasiq_userInput[]
    connectOrCreate?: bank_accountsCreateOrConnectWithoutBasiq_userInput | bank_accountsCreateOrConnectWithoutBasiq_userInput[]
    upsert?: bank_accountsUpsertWithWhereUniqueWithoutBasiq_userInput | bank_accountsUpsertWithWhereUniqueWithoutBasiq_userInput[]
    createMany?: bank_accountsCreateManyBasiq_userInputEnvelope
    set?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    disconnect?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    delete?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    connect?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    update?: bank_accountsUpdateWithWhereUniqueWithoutBasiq_userInput | bank_accountsUpdateWithWhereUniqueWithoutBasiq_userInput[]
    updateMany?: bank_accountsUpdateManyWithWhereWithoutBasiq_userInput | bank_accountsUpdateManyWithWhereWithoutBasiq_userInput[]
    deleteMany?: bank_accountsScalarWhereInput | bank_accountsScalarWhereInput[]
  }

  export type basiq_usersCreateNestedOneWithoutBank_connectionsInput = {
    create?: XOR<basiq_usersCreateWithoutBank_connectionsInput, basiq_usersUncheckedCreateWithoutBank_connectionsInput>
    connectOrCreate?: basiq_usersCreateOrConnectWithoutBank_connectionsInput
    connect?: basiq_usersWhereUniqueInput
  }

  export type bank_accountsCreateNestedManyWithoutConnectionInput = {
    create?: XOR<bank_accountsCreateWithoutConnectionInput, bank_accountsUncheckedCreateWithoutConnectionInput> | bank_accountsCreateWithoutConnectionInput[] | bank_accountsUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: bank_accountsCreateOrConnectWithoutConnectionInput | bank_accountsCreateOrConnectWithoutConnectionInput[]
    createMany?: bank_accountsCreateManyConnectionInputEnvelope
    connect?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
  }

  export type bank_accountsUncheckedCreateNestedManyWithoutConnectionInput = {
    create?: XOR<bank_accountsCreateWithoutConnectionInput, bank_accountsUncheckedCreateWithoutConnectionInput> | bank_accountsCreateWithoutConnectionInput[] | bank_accountsUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: bank_accountsCreateOrConnectWithoutConnectionInput | bank_accountsCreateOrConnectWithoutConnectionInput[]
    createMany?: bank_accountsCreateManyConnectionInputEnvelope
    connect?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
  }

  export type basiq_usersUpdateOneRequiredWithoutBank_connectionsNestedInput = {
    create?: XOR<basiq_usersCreateWithoutBank_connectionsInput, basiq_usersUncheckedCreateWithoutBank_connectionsInput>
    connectOrCreate?: basiq_usersCreateOrConnectWithoutBank_connectionsInput
    upsert?: basiq_usersUpsertWithoutBank_connectionsInput
    connect?: basiq_usersWhereUniqueInput
    update?: XOR<XOR<basiq_usersUpdateToOneWithWhereWithoutBank_connectionsInput, basiq_usersUpdateWithoutBank_connectionsInput>, basiq_usersUncheckedUpdateWithoutBank_connectionsInput>
  }

  export type bank_accountsUpdateManyWithoutConnectionNestedInput = {
    create?: XOR<bank_accountsCreateWithoutConnectionInput, bank_accountsUncheckedCreateWithoutConnectionInput> | bank_accountsCreateWithoutConnectionInput[] | bank_accountsUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: bank_accountsCreateOrConnectWithoutConnectionInput | bank_accountsCreateOrConnectWithoutConnectionInput[]
    upsert?: bank_accountsUpsertWithWhereUniqueWithoutConnectionInput | bank_accountsUpsertWithWhereUniqueWithoutConnectionInput[]
    createMany?: bank_accountsCreateManyConnectionInputEnvelope
    set?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    disconnect?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    delete?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    connect?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    update?: bank_accountsUpdateWithWhereUniqueWithoutConnectionInput | bank_accountsUpdateWithWhereUniqueWithoutConnectionInput[]
    updateMany?: bank_accountsUpdateManyWithWhereWithoutConnectionInput | bank_accountsUpdateManyWithWhereWithoutConnectionInput[]
    deleteMany?: bank_accountsScalarWhereInput | bank_accountsScalarWhereInput[]
  }

  export type bank_accountsUncheckedUpdateManyWithoutConnectionNestedInput = {
    create?: XOR<bank_accountsCreateWithoutConnectionInput, bank_accountsUncheckedCreateWithoutConnectionInput> | bank_accountsCreateWithoutConnectionInput[] | bank_accountsUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: bank_accountsCreateOrConnectWithoutConnectionInput | bank_accountsCreateOrConnectWithoutConnectionInput[]
    upsert?: bank_accountsUpsertWithWhereUniqueWithoutConnectionInput | bank_accountsUpsertWithWhereUniqueWithoutConnectionInput[]
    createMany?: bank_accountsCreateManyConnectionInputEnvelope
    set?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    disconnect?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    delete?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    connect?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    update?: bank_accountsUpdateWithWhereUniqueWithoutConnectionInput | bank_accountsUpdateWithWhereUniqueWithoutConnectionInput[]
    updateMany?: bank_accountsUpdateManyWithWhereWithoutConnectionInput | bank_accountsUpdateManyWithWhereWithoutConnectionInput[]
    deleteMany?: bank_accountsScalarWhereInput | bank_accountsScalarWhereInput[]
  }

  export type basiq_usersCreateNestedOneWithoutBank_accountsInput = {
    create?: XOR<basiq_usersCreateWithoutBank_accountsInput, basiq_usersUncheckedCreateWithoutBank_accountsInput>
    connectOrCreate?: basiq_usersCreateOrConnectWithoutBank_accountsInput
    connect?: basiq_usersWhereUniqueInput
  }

  export type bank_connectionsCreateNestedOneWithoutBank_accountsInput = {
    create?: XOR<bank_connectionsCreateWithoutBank_accountsInput, bank_connectionsUncheckedCreateWithoutBank_accountsInput>
    connectOrCreate?: bank_connectionsCreateOrConnectWithoutBank_accountsInput
    connect?: bank_connectionsWhereUniqueInput
  }

  export type bank_transactionsCreateNestedManyWithoutBank_accountInput = {
    create?: XOR<bank_transactionsCreateWithoutBank_accountInput, bank_transactionsUncheckedCreateWithoutBank_accountInput> | bank_transactionsCreateWithoutBank_accountInput[] | bank_transactionsUncheckedCreateWithoutBank_accountInput[]
    connectOrCreate?: bank_transactionsCreateOrConnectWithoutBank_accountInput | bank_transactionsCreateOrConnectWithoutBank_accountInput[]
    createMany?: bank_transactionsCreateManyBank_accountInputEnvelope
    connect?: bank_transactionsWhereUniqueInput | bank_transactionsWhereUniqueInput[]
  }

  export type bank_transactionsUncheckedCreateNestedManyWithoutBank_accountInput = {
    create?: XOR<bank_transactionsCreateWithoutBank_accountInput, bank_transactionsUncheckedCreateWithoutBank_accountInput> | bank_transactionsCreateWithoutBank_accountInput[] | bank_transactionsUncheckedCreateWithoutBank_accountInput[]
    connectOrCreate?: bank_transactionsCreateOrConnectWithoutBank_accountInput | bank_transactionsCreateOrConnectWithoutBank_accountInput[]
    createMany?: bank_transactionsCreateManyBank_accountInputEnvelope
    connect?: bank_transactionsWhereUniqueInput | bank_transactionsWhereUniqueInput[]
  }

  export type basiq_usersUpdateOneRequiredWithoutBank_accountsNestedInput = {
    create?: XOR<basiq_usersCreateWithoutBank_accountsInput, basiq_usersUncheckedCreateWithoutBank_accountsInput>
    connectOrCreate?: basiq_usersCreateOrConnectWithoutBank_accountsInput
    upsert?: basiq_usersUpsertWithoutBank_accountsInput
    connect?: basiq_usersWhereUniqueInput
    update?: XOR<XOR<basiq_usersUpdateToOneWithWhereWithoutBank_accountsInput, basiq_usersUpdateWithoutBank_accountsInput>, basiq_usersUncheckedUpdateWithoutBank_accountsInput>
  }

  export type bank_connectionsUpdateOneRequiredWithoutBank_accountsNestedInput = {
    create?: XOR<bank_connectionsCreateWithoutBank_accountsInput, bank_connectionsUncheckedCreateWithoutBank_accountsInput>
    connectOrCreate?: bank_connectionsCreateOrConnectWithoutBank_accountsInput
    upsert?: bank_connectionsUpsertWithoutBank_accountsInput
    connect?: bank_connectionsWhereUniqueInput
    update?: XOR<XOR<bank_connectionsUpdateToOneWithWhereWithoutBank_accountsInput, bank_connectionsUpdateWithoutBank_accountsInput>, bank_connectionsUncheckedUpdateWithoutBank_accountsInput>
  }

  export type bank_transactionsUpdateManyWithoutBank_accountNestedInput = {
    create?: XOR<bank_transactionsCreateWithoutBank_accountInput, bank_transactionsUncheckedCreateWithoutBank_accountInput> | bank_transactionsCreateWithoutBank_accountInput[] | bank_transactionsUncheckedCreateWithoutBank_accountInput[]
    connectOrCreate?: bank_transactionsCreateOrConnectWithoutBank_accountInput | bank_transactionsCreateOrConnectWithoutBank_accountInput[]
    upsert?: bank_transactionsUpsertWithWhereUniqueWithoutBank_accountInput | bank_transactionsUpsertWithWhereUniqueWithoutBank_accountInput[]
    createMany?: bank_transactionsCreateManyBank_accountInputEnvelope
    set?: bank_transactionsWhereUniqueInput | bank_transactionsWhereUniqueInput[]
    disconnect?: bank_transactionsWhereUniqueInput | bank_transactionsWhereUniqueInput[]
    delete?: bank_transactionsWhereUniqueInput | bank_transactionsWhereUniqueInput[]
    connect?: bank_transactionsWhereUniqueInput | bank_transactionsWhereUniqueInput[]
    update?: bank_transactionsUpdateWithWhereUniqueWithoutBank_accountInput | bank_transactionsUpdateWithWhereUniqueWithoutBank_accountInput[]
    updateMany?: bank_transactionsUpdateManyWithWhereWithoutBank_accountInput | bank_transactionsUpdateManyWithWhereWithoutBank_accountInput[]
    deleteMany?: bank_transactionsScalarWhereInput | bank_transactionsScalarWhereInput[]
  }

  export type bank_transactionsUncheckedUpdateManyWithoutBank_accountNestedInput = {
    create?: XOR<bank_transactionsCreateWithoutBank_accountInput, bank_transactionsUncheckedCreateWithoutBank_accountInput> | bank_transactionsCreateWithoutBank_accountInput[] | bank_transactionsUncheckedCreateWithoutBank_accountInput[]
    connectOrCreate?: bank_transactionsCreateOrConnectWithoutBank_accountInput | bank_transactionsCreateOrConnectWithoutBank_accountInput[]
    upsert?: bank_transactionsUpsertWithWhereUniqueWithoutBank_accountInput | bank_transactionsUpsertWithWhereUniqueWithoutBank_accountInput[]
    createMany?: bank_transactionsCreateManyBank_accountInputEnvelope
    set?: bank_transactionsWhereUniqueInput | bank_transactionsWhereUniqueInput[]
    disconnect?: bank_transactionsWhereUniqueInput | bank_transactionsWhereUniqueInput[]
    delete?: bank_transactionsWhereUniqueInput | bank_transactionsWhereUniqueInput[]
    connect?: bank_transactionsWhereUniqueInput | bank_transactionsWhereUniqueInput[]
    update?: bank_transactionsUpdateWithWhereUniqueWithoutBank_accountInput | bank_transactionsUpdateWithWhereUniqueWithoutBank_accountInput[]
    updateMany?: bank_transactionsUpdateManyWithWhereWithoutBank_accountInput | bank_transactionsUpdateManyWithWhereWithoutBank_accountInput[]
    deleteMany?: bank_transactionsScalarWhereInput | bank_transactionsScalarWhereInput[]
  }

  export type bank_accountsCreateNestedOneWithoutBank_transactionsInput = {
    create?: XOR<bank_accountsCreateWithoutBank_transactionsInput, bank_accountsUncheckedCreateWithoutBank_transactionsInput>
    connectOrCreate?: bank_accountsCreateOrConnectWithoutBank_transactionsInput
    connect?: bank_accountsWhereUniqueInput
  }

  export type bank_accountsUpdateOneRequiredWithoutBank_transactionsNestedInput = {
    create?: XOR<bank_accountsCreateWithoutBank_transactionsInput, bank_accountsUncheckedCreateWithoutBank_transactionsInput>
    connectOrCreate?: bank_accountsCreateOrConnectWithoutBank_transactionsInput
    upsert?: bank_accountsUpsertWithoutBank_transactionsInput
    connect?: bank_accountsWhereUniqueInput
    update?: XOR<XOR<bank_accountsUpdateToOneWithWhereWithoutBank_transactionsInput, bank_accountsUpdateWithoutBank_transactionsInput>, bank_accountsUncheckedUpdateWithoutBank_transactionsInput>
  }

  export type UserCreateNestedOneWithoutBasiq_api_logsInput = {
    create?: XOR<UserCreateWithoutBasiq_api_logsInput, UserUncheckedCreateWithoutBasiq_api_logsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBasiq_api_logsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutBasiq_api_logsNestedInput = {
    create?: XOR<UserCreateWithoutBasiq_api_logsInput, UserUncheckedCreateWithoutBasiq_api_logsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBasiq_api_logsInput
    upsert?: UserUpsertWithoutBasiq_api_logsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBasiq_api_logsInput, UserUpdateWithoutBasiq_api_logsInput>, UserUncheckedUpdateWithoutBasiq_api_logsInput>
  }

  export type UserCreateNestedOneWithoutReceiptsInput = {
    create?: XOR<UserCreateWithoutReceiptsInput, UserUncheckedCreateWithoutReceiptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceiptsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReceiptStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReceiptStatus
  }

  export type UserUpdateOneRequiredWithoutReceiptsNestedInput = {
    create?: XOR<UserCreateWithoutReceiptsInput, UserUncheckedCreateWithoutReceiptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceiptsInput
    upsert?: UserUpsertWithoutReceiptsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceiptsInput, UserUpdateWithoutReceiptsInput>, UserUncheckedUpdateWithoutReceiptsInput>
  }

  export type UserCreateNestedOneWithoutBudgetsInput = {
    create?: XOR<UserCreateWithoutBudgetsInput, UserUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBudgetsInput
    connect?: UserWhereUniqueInput
  }

  export type BudgetTrackingCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetTrackingCreateWithoutBudgetInput, BudgetTrackingUncheckedCreateWithoutBudgetInput> | BudgetTrackingCreateWithoutBudgetInput[] | BudgetTrackingUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetTrackingCreateOrConnectWithoutBudgetInput | BudgetTrackingCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetTrackingCreateManyBudgetInputEnvelope
    connect?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
  }

  export type BudgetTrackingUncheckedCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetTrackingCreateWithoutBudgetInput, BudgetTrackingUncheckedCreateWithoutBudgetInput> | BudgetTrackingCreateWithoutBudgetInput[] | BudgetTrackingUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetTrackingCreateOrConnectWithoutBudgetInput | BudgetTrackingCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetTrackingCreateManyBudgetInputEnvelope
    connect?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
  }

  export type EnumBudgetStatusFieldUpdateOperationsInput = {
    set?: $Enums.BudgetStatus
  }

  export type UserUpdateOneRequiredWithoutBudgetsNestedInput = {
    create?: XOR<UserCreateWithoutBudgetsInput, UserUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBudgetsInput
    upsert?: UserUpsertWithoutBudgetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBudgetsInput, UserUpdateWithoutBudgetsInput>, UserUncheckedUpdateWithoutBudgetsInput>
  }

  export type BudgetTrackingUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetTrackingCreateWithoutBudgetInput, BudgetTrackingUncheckedCreateWithoutBudgetInput> | BudgetTrackingCreateWithoutBudgetInput[] | BudgetTrackingUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetTrackingCreateOrConnectWithoutBudgetInput | BudgetTrackingCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetTrackingUpsertWithWhereUniqueWithoutBudgetInput | BudgetTrackingUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetTrackingCreateManyBudgetInputEnvelope
    set?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
    disconnect?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
    delete?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
    connect?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
    update?: BudgetTrackingUpdateWithWhereUniqueWithoutBudgetInput | BudgetTrackingUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetTrackingUpdateManyWithWhereWithoutBudgetInput | BudgetTrackingUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetTrackingScalarWhereInput | BudgetTrackingScalarWhereInput[]
  }

  export type BudgetTrackingUncheckedUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetTrackingCreateWithoutBudgetInput, BudgetTrackingUncheckedCreateWithoutBudgetInput> | BudgetTrackingCreateWithoutBudgetInput[] | BudgetTrackingUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetTrackingCreateOrConnectWithoutBudgetInput | BudgetTrackingCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetTrackingUpsertWithWhereUniqueWithoutBudgetInput | BudgetTrackingUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetTrackingCreateManyBudgetInputEnvelope
    set?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
    disconnect?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
    delete?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
    connect?: BudgetTrackingWhereUniqueInput | BudgetTrackingWhereUniqueInput[]
    update?: BudgetTrackingUpdateWithWhereUniqueWithoutBudgetInput | BudgetTrackingUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetTrackingUpdateManyWithWhereWithoutBudgetInput | BudgetTrackingUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetTrackingScalarWhereInput | BudgetTrackingScalarWhereInput[]
  }

  export type BudgetCreateNestedOneWithoutBudgetTrackingInput = {
    create?: XOR<BudgetCreateWithoutBudgetTrackingInput, BudgetUncheckedCreateWithoutBudgetTrackingInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutBudgetTrackingInput
    connect?: BudgetWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBudgetTrackingInput = {
    create?: XOR<UserCreateWithoutBudgetTrackingInput, UserUncheckedCreateWithoutBudgetTrackingInput>
    connectOrCreate?: UserCreateOrConnectWithoutBudgetTrackingInput
    connect?: UserWhereUniqueInput
  }

  export type BudgetUpdateOneRequiredWithoutBudgetTrackingNestedInput = {
    create?: XOR<BudgetCreateWithoutBudgetTrackingInput, BudgetUncheckedCreateWithoutBudgetTrackingInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutBudgetTrackingInput
    upsert?: BudgetUpsertWithoutBudgetTrackingInput
    connect?: BudgetWhereUniqueInput
    update?: XOR<XOR<BudgetUpdateToOneWithWhereWithoutBudgetTrackingInput, BudgetUpdateWithoutBudgetTrackingInput>, BudgetUncheckedUpdateWithoutBudgetTrackingInput>
  }

  export type UserUpdateOneRequiredWithoutBudgetTrackingNestedInput = {
    create?: XOR<UserCreateWithoutBudgetTrackingInput, UserUncheckedCreateWithoutBudgetTrackingInput>
    connectOrCreate?: UserCreateOrConnectWithoutBudgetTrackingInput
    upsert?: UserUpsertWithoutBudgetTrackingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBudgetTrackingInput, UserUpdateWithoutBudgetTrackingInput>, UserUncheckedUpdateWithoutBudgetTrackingInput>
  }

  export type FinancialInsightCreatesourceDataIdsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutFinancialInsightsInput = {
    create?: XOR<UserCreateWithoutFinancialInsightsInput, UserUncheckedCreateWithoutFinancialInsightsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFinancialInsightsInput
    connect?: UserWhereUniqueInput
  }

  export type FinancialInsightUpdatesourceDataIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumInsightPriorityFieldUpdateOperationsInput = {
    set?: $Enums.InsightPriority
  }

  export type UserUpdateOneRequiredWithoutFinancialInsightsNestedInput = {
    create?: XOR<UserCreateWithoutFinancialInsightsInput, UserUncheckedCreateWithoutFinancialInsightsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFinancialInsightsInput
    upsert?: UserUpsertWithoutFinancialInsightsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFinancialInsightsInput, UserUpdateWithoutFinancialInsightsInput>, UserUncheckedUpdateWithoutFinancialInsightsInput>
  }

  export type UserCreateNestedOneWithoutGoalsInput = {
    create?: XOR<UserCreateWithoutGoalsInput, UserUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGoalsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumGoalStatusFieldUpdateOperationsInput = {
    set?: $Enums.GoalStatus
  }

  export type UserUpdateOneRequiredWithoutGoalsNestedInput = {
    create?: XOR<UserCreateWithoutGoalsInput, UserUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGoalsInput
    upsert?: UserUpsertWithoutGoalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGoalsInput, UserUpdateWithoutGoalsInput>, UserUncheckedUpdateWithoutGoalsInput>
  }

  export type AMLTransactionMonitoringCreateriskFactorsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAmlMonitoringInput = {
    create?: XOR<UserCreateWithoutAmlMonitoringInput, UserUncheckedCreateWithoutAmlMonitoringInput>
    connectOrCreate?: UserCreateOrConnectWithoutAmlMonitoringInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAMLMonitoringTypeFieldUpdateOperationsInput = {
    set?: $Enums.AMLMonitoringType
  }

  export type AMLTransactionMonitoringUpdateriskFactorsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutAmlMonitoringNestedInput = {
    create?: XOR<UserCreateWithoutAmlMonitoringInput, UserUncheckedCreateWithoutAmlMonitoringInput>
    connectOrCreate?: UserCreateOrConnectWithoutAmlMonitoringInput
    upsert?: UserUpsertWithoutAmlMonitoringInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAmlMonitoringInput, UserUpdateWithoutAmlMonitoringInput>, UserUncheckedUpdateWithoutAmlMonitoringInput>
  }

  export type PrivacyConsentCreatepurposesInput = {
    set: string[]
  }

  export type PrivacyConsentCreatedataCategoriesInput = {
    set: string[]
  }

  export type PrivacyConsentCreatethirdPartiesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutPrivacyConsentsInput = {
    create?: XOR<UserCreateWithoutPrivacyConsentsInput, UserUncheckedCreateWithoutPrivacyConsentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrivacyConsentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumConsentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ConsentType
  }

  export type EnumConsentStatusFieldUpdateOperationsInput = {
    set?: $Enums.ConsentStatus
  }

  export type PrivacyConsentUpdatepurposesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PrivacyConsentUpdatedataCategoriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PrivacyConsentUpdatethirdPartiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutPrivacyConsentsNestedInput = {
    create?: XOR<UserCreateWithoutPrivacyConsentsInput, UserUncheckedCreateWithoutPrivacyConsentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrivacyConsentsInput
    upsert?: UserUpsertWithoutPrivacyConsentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPrivacyConsentsInput, UserUpdateWithoutPrivacyConsentsInput>, UserUncheckedUpdateWithoutPrivacyConsentsInput>
  }

  export type UserCreateNestedOneWithoutDataAccessRequestsInput = {
    create?: XOR<UserCreateWithoutDataAccessRequestsInput, UserUncheckedCreateWithoutDataAccessRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDataAccessRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDataRequestTypeFieldUpdateOperationsInput = {
    set?: $Enums.DataRequestType
  }

  export type EnumDataRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.DataRequestStatus
  }

  export type UserUpdateOneRequiredWithoutDataAccessRequestsNestedInput = {
    create?: XOR<UserCreateWithoutDataAccessRequestsInput, UserUncheckedCreateWithoutDataAccessRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDataAccessRequestsInput
    upsert?: UserUpsertWithoutDataAccessRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDataAccessRequestsInput, UserUpdateWithoutDataAccessRequestsInput>, UserUncheckedUpdateWithoutDataAccessRequestsInput>
  }

  export type APRAIncidentReportCreateaffectedSystemsInput = {
    set: string[]
  }

  export type EnumIncidentTypeFieldUpdateOperationsInput = {
    set?: $Enums.IncidentType
  }

  export type EnumIncidentSeverityFieldUpdateOperationsInput = {
    set?: $Enums.IncidentSeverity
  }

  export type EnumIncidentStatusFieldUpdateOperationsInput = {
    set?: $Enums.IncidentStatus
  }

  export type APRAIncidentReportUpdateaffectedSystemsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GSTTransactionDetailCreatevalidationErrorsInput = {
    set: string[]
  }

  export type EnumGSTTreatmentFieldUpdateOperationsInput = {
    set?: $Enums.GSTTreatment
  }

  export type GSTTransactionDetailUpdatevalidationErrorsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumTaxResidencyFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxResidency | EnumTaxResidencyFieldRefInput<$PrismaModel>
    in?: $Enums.TaxResidency[] | ListEnumTaxResidencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxResidency[] | ListEnumTaxResidencyFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxResidencyFilter<$PrismaModel> | $Enums.TaxResidency
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumTaxResidencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxResidency | EnumTaxResidencyFieldRefInput<$PrismaModel>
    in?: $Enums.TaxResidency[] | ListEnumTaxResidencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxResidency[] | ListEnumTaxResidencyFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxResidencyWithAggregatesFilter<$PrismaModel> | $Enums.TaxResidency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaxResidencyFilter<$PrismaModel>
    _max?: NestedEnumTaxResidencyFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAuthEventFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthEvent | EnumAuthEventFieldRefInput<$PrismaModel>
    in?: $Enums.AuthEvent[] | ListEnumAuthEventFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthEvent[] | ListEnumAuthEventFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthEventFilter<$PrismaModel> | $Enums.AuthEvent
  }

  export type NestedEnumAuthEventWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthEvent | EnumAuthEventFieldRefInput<$PrismaModel>
    in?: $Enums.AuthEvent[] | ListEnumAuthEventFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthEvent[] | ListEnumAuthEventFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthEventWithAggregatesFilter<$PrismaModel> | $Enums.AuthEvent
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthEventFilter<$PrismaModel>
    _max?: NestedEnumAuthEventFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumFinancialOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialOperation | EnumFinancialOperationFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialOperation[] | ListEnumFinancialOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialOperation[] | ListEnumFinancialOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialOperationFilter<$PrismaModel> | $Enums.FinancialOperation
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumFinancialOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialOperation | EnumFinancialOperationFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialOperation[] | ListEnumFinancialOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialOperation[] | ListEnumFinancialOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialOperationWithAggregatesFilter<$PrismaModel> | $Enums.FinancialOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFinancialOperationFilter<$PrismaModel>
    _max?: NestedEnumFinancialOperationFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel>
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanFilter<$PrismaModel> | $Enums.Plan
  }

  export type NestedEnumPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel>
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanWithAggregatesFilter<$PrismaModel> | $Enums.Plan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanFilter<$PrismaModel>
    _max?: NestedEnumPlanFilter<$PrismaModel>
  }

  export type NestedEnumTaxReturnStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxReturnStatus | EnumTaxReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaxReturnStatus[] | ListEnumTaxReturnStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxReturnStatus[] | ListEnumTaxReturnStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxReturnStatusFilter<$PrismaModel> | $Enums.TaxReturnStatus
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTaxReturnStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxReturnStatus | EnumTaxReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaxReturnStatus[] | ListEnumTaxReturnStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxReturnStatus[] | ListEnumTaxReturnStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxReturnStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaxReturnStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaxReturnStatusFilter<$PrismaModel>
    _max?: NestedEnumTaxReturnStatusFilter<$PrismaModel>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumReceiptStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReceiptStatus | EnumReceiptStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReceiptStatus[] | ListEnumReceiptStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReceiptStatus[] | ListEnumReceiptStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReceiptStatusFilter<$PrismaModel> | $Enums.ReceiptStatus
  }

  export type NestedEnumReceiptStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReceiptStatus | EnumReceiptStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReceiptStatus[] | ListEnumReceiptStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReceiptStatus[] | ListEnumReceiptStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReceiptStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReceiptStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReceiptStatusFilter<$PrismaModel>
    _max?: NestedEnumReceiptStatusFilter<$PrismaModel>
  }

  export type NestedEnumBudgetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetStatus | EnumBudgetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetStatusFilter<$PrismaModel> | $Enums.BudgetStatus
  }

  export type NestedEnumBudgetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetStatus | EnumBudgetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetStatusWithAggregatesFilter<$PrismaModel> | $Enums.BudgetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBudgetStatusFilter<$PrismaModel>
    _max?: NestedEnumBudgetStatusFilter<$PrismaModel>
  }

  export type NestedEnumInsightPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightPriority | EnumInsightPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.InsightPriority[] | ListEnumInsightPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightPriority[] | ListEnumInsightPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightPriorityFilter<$PrismaModel> | $Enums.InsightPriority
  }

  export type NestedEnumInsightPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightPriority | EnumInsightPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.InsightPriority[] | ListEnumInsightPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightPriority[] | ListEnumInsightPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightPriorityWithAggregatesFilter<$PrismaModel> | $Enums.InsightPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightPriorityFilter<$PrismaModel>
    _max?: NestedEnumInsightPriorityFilter<$PrismaModel>
  }

  export type NestedEnumGoalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalStatus | EnumGoalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalStatusFilter<$PrismaModel> | $Enums.GoalStatus
  }

  export type NestedEnumGoalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalStatus | EnumGoalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalStatusWithAggregatesFilter<$PrismaModel> | $Enums.GoalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGoalStatusFilter<$PrismaModel>
    _max?: NestedEnumGoalStatusFilter<$PrismaModel>
  }

  export type NestedEnumAMLMonitoringTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AMLMonitoringType | EnumAMLMonitoringTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AMLMonitoringType[] | ListEnumAMLMonitoringTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AMLMonitoringType[] | ListEnumAMLMonitoringTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAMLMonitoringTypeFilter<$PrismaModel> | $Enums.AMLMonitoringType
  }

  export type NestedEnumAMLMonitoringTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AMLMonitoringType | EnumAMLMonitoringTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AMLMonitoringType[] | ListEnumAMLMonitoringTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AMLMonitoringType[] | ListEnumAMLMonitoringTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAMLMonitoringTypeWithAggregatesFilter<$PrismaModel> | $Enums.AMLMonitoringType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAMLMonitoringTypeFilter<$PrismaModel>
    _max?: NestedEnumAMLMonitoringTypeFilter<$PrismaModel>
  }

  export type NestedEnumConsentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentType | EnumConsentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentTypeFilter<$PrismaModel> | $Enums.ConsentType
  }

  export type NestedEnumConsentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatus | EnumConsentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentStatusFilter<$PrismaModel> | $Enums.ConsentStatus
  }

  export type NestedEnumConsentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentType | EnumConsentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConsentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsentTypeFilter<$PrismaModel>
    _max?: NestedEnumConsentTypeFilter<$PrismaModel>
  }

  export type NestedEnumConsentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatus | EnumConsentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConsentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsentStatusFilter<$PrismaModel>
    _max?: NestedEnumConsentStatusFilter<$PrismaModel>
  }

  export type NestedEnumDataRequestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRequestType | EnumDataRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DataRequestType[] | ListEnumDataRequestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataRequestType[] | ListEnumDataRequestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDataRequestTypeFilter<$PrismaModel> | $Enums.DataRequestType
  }

  export type NestedEnumDataRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRequestStatus | EnumDataRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DataRequestStatus[] | ListEnumDataRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataRequestStatus[] | ListEnumDataRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDataRequestStatusFilter<$PrismaModel> | $Enums.DataRequestStatus
  }

  export type NestedEnumDataRequestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRequestType | EnumDataRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DataRequestType[] | ListEnumDataRequestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataRequestType[] | ListEnumDataRequestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDataRequestTypeWithAggregatesFilter<$PrismaModel> | $Enums.DataRequestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataRequestTypeFilter<$PrismaModel>
    _max?: NestedEnumDataRequestTypeFilter<$PrismaModel>
  }

  export type NestedEnumDataRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRequestStatus | EnumDataRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DataRequestStatus[] | ListEnumDataRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataRequestStatus[] | ListEnumDataRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDataRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.DataRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumDataRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumIncidentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeFilter<$PrismaModel> | $Enums.IncidentType
  }

  export type NestedEnumIncidentSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityFilter<$PrismaModel> | $Enums.IncidentSeverity
  }

  export type NestedEnumIncidentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusFilter<$PrismaModel> | $Enums.IncidentStatus
  }

  export type NestedEnumIncidentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeWithAggregatesFilter<$PrismaModel> | $Enums.IncidentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentTypeFilter<$PrismaModel>
    _max?: NestedEnumIncidentTypeFilter<$PrismaModel>
  }

  export type NestedEnumIncidentSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityWithAggregatesFilter<$PrismaModel> | $Enums.IncidentSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentSeverityFilter<$PrismaModel>
    _max?: NestedEnumIncidentSeverityFilter<$PrismaModel>
  }

  export type NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel> | $Enums.IncidentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentStatusFilter<$PrismaModel>
    _max?: NestedEnumIncidentStatusFilter<$PrismaModel>
  }

  export type NestedEnumGSTTreatmentFilter<$PrismaModel = never> = {
    equals?: $Enums.GSTTreatment | EnumGSTTreatmentFieldRefInput<$PrismaModel>
    in?: $Enums.GSTTreatment[] | ListEnumGSTTreatmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.GSTTreatment[] | ListEnumGSTTreatmentFieldRefInput<$PrismaModel>
    not?: NestedEnumGSTTreatmentFilter<$PrismaModel> | $Enums.GSTTreatment
  }

  export type NestedEnumGSTTreatmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GSTTreatment | EnumGSTTreatmentFieldRefInput<$PrismaModel>
    in?: $Enums.GSTTreatment[] | ListEnumGSTTreatmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.GSTTreatment[] | ListEnumGSTTreatmentFieldRefInput<$PrismaModel>
    not?: NestedEnumGSTTreatmentWithAggregatesFilter<$PrismaModel> | $Enums.GSTTreatment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGSTTreatmentFilter<$PrismaModel>
    _max?: NestedEnumGSTTreatmentFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    event: $Enums.AuthEvent
    ipAddress: string
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    success?: boolean
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    event: $Enums.AuthEvent
    ipAddress: string
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    success?: boolean
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    stripePriceId: string
    status: string
    plan: $Enums.Plan
    interval?: string
    amount: number
    currency?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    trialEnd?: Date | string | null
    defaultPaymentMethodId?: string | null
    lastPaymentAttempt?: Date | string | null
    failedPaymentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    stripePriceId: string
    status: string
    plan: $Enums.Plan
    interval?: string
    amount: number
    currency?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    trialEnd?: Date | string | null
    defaultPaymentMethodId?: string | null
    lastPaymentAttempt?: Date | string | null
    failedPaymentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionCreateManyUserInputEnvelope = {
    data: SubscriptionCreateManyUserInput | SubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaxReturnCreateWithoutUserInput = {
    id?: string
    year: string
    data: JsonNullValueInput | InputJsonValue
    status?: $Enums.TaxReturnStatus
    submittedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxReturnUncheckedCreateWithoutUserInput = {
    id?: string
    year: string
    data: JsonNullValueInput | InputJsonValue
    status?: $Enums.TaxReturnStatus
    submittedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxReturnCreateOrConnectWithoutUserInput = {
    where: TaxReturnWhereUniqueInput
    create: XOR<TaxReturnCreateWithoutUserInput, TaxReturnUncheckedCreateWithoutUserInput>
  }

  export type TaxReturnCreateManyUserInputEnvelope = {
    data: TaxReturnCreateManyUserInput | TaxReturnCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    stripePaymentIntentId: string
    amount: number
    currency: string
    status: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    stripePaymentIntentId: string
    amount: number
    currency: string
    status: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AIConversationCreateWithoutUserInput = {
    id?: string
    sessionId: string
    provider: string
    model: string
    messages: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: number
    costUsd?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIConversationUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId: string
    provider: string
    model: string
    messages: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: number
    costUsd?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIConversationCreateOrConnectWithoutUserInput = {
    where: AIConversationWhereUniqueInput
    create: XOR<AIConversationCreateWithoutUserInput, AIConversationUncheckedCreateWithoutUserInput>
  }

  export type AIConversationCreateManyUserInputEnvelope = {
    data: AIConversationCreateManyUserInput | AIConversationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AIInsightCreateWithoutUserInput = {
    id?: string
    insightType: string
    category: string
    content: JsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: AIInsightCreatesourceDataIdsInput | string[]
    provider: string
    model: string
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AIInsightUncheckedCreateWithoutUserInput = {
    id?: string
    insightType: string
    category: string
    content: JsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: AIInsightCreatesourceDataIdsInput | string[]
    provider: string
    model: string
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AIInsightCreateOrConnectWithoutUserInput = {
    where: AIInsightWhereUniqueInput
    create: XOR<AIInsightCreateWithoutUserInput, AIInsightUncheckedCreateWithoutUserInput>
  }

  export type AIInsightCreateManyUserInputEnvelope = {
    data: AIInsightCreateManyUserInput | AIInsightCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AIUsageTrackingCreateWithoutUserInput = {
    id?: string
    provider: string
    model: string
    operationType: string
    tokensInput?: number
    tokensOutput?: number
    costUsd?: Decimal | DecimalJsLike | number | string
    responseTimeMs?: number | null
    success?: boolean
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type AIUsageTrackingUncheckedCreateWithoutUserInput = {
    id?: string
    provider: string
    model: string
    operationType: string
    tokensInput?: number
    tokensOutput?: number
    costUsd?: Decimal | DecimalJsLike | number | string
    responseTimeMs?: number | null
    success?: boolean
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type AIUsageTrackingCreateOrConnectWithoutUserInput = {
    where: AIUsageTrackingWhereUniqueInput
    create: XOR<AIUsageTrackingCreateWithoutUserInput, AIUsageTrackingUncheckedCreateWithoutUserInput>
  }

  export type AIUsageTrackingCreateManyUserInputEnvelope = {
    data: AIUsageTrackingCreateManyUserInput | AIUsageTrackingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type basiq_usersCreateWithoutUserInput = {
    id?: string
    basiq_user_id: string
    email: string
    mobile?: string | null
    connection_status?: string | null
    consent_id?: string | null
    consent_status?: string | null
    consent_expires_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    bank_connections?: bank_connectionsCreateNestedManyWithoutBasiq_userInput
    bank_accounts?: bank_accountsCreateNestedManyWithoutBasiq_userInput
  }

  export type basiq_usersUncheckedCreateWithoutUserInput = {
    id?: string
    basiq_user_id: string
    email: string
    mobile?: string | null
    connection_status?: string | null
    consent_id?: string | null
    consent_status?: string | null
    consent_expires_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    bank_connections?: bank_connectionsUncheckedCreateNestedManyWithoutBasiq_userInput
    bank_accounts?: bank_accountsUncheckedCreateNestedManyWithoutBasiq_userInput
  }

  export type basiq_usersCreateOrConnectWithoutUserInput = {
    where: basiq_usersWhereUniqueInput
    create: XOR<basiq_usersCreateWithoutUserInput, basiq_usersUncheckedCreateWithoutUserInput>
  }

  export type basiq_api_logsCreateWithoutUserInput = {
    id?: string
    endpoint: string
    method: string
    request_body?: NullableJsonNullValueInput | InputJsonValue
    response_status?: number | null
    response_body?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    duration_ms?: number | null
    created_at?: Date | string
  }

  export type basiq_api_logsUncheckedCreateWithoutUserInput = {
    id?: string
    endpoint: string
    method: string
    request_body?: NullableJsonNullValueInput | InputJsonValue
    response_status?: number | null
    response_body?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    duration_ms?: number | null
    created_at?: Date | string
  }

  export type basiq_api_logsCreateOrConnectWithoutUserInput = {
    where: basiq_api_logsWhereUniqueInput
    create: XOR<basiq_api_logsCreateWithoutUserInput, basiq_api_logsUncheckedCreateWithoutUserInput>
  }

  export type basiq_api_logsCreateManyUserInputEnvelope = {
    data: basiq_api_logsCreateManyUserInput | basiq_api_logsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReceiptCreateWithoutUserInput = {
    id?: string
    merchant?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    gstAmount?: Decimal | DecimalJsLike | number | string | null
    date: Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    aiProcessed?: boolean
    aiConfidence?: Decimal | DecimalJsLike | number | string | null
    aiProvider?: string | null
    aiModel?: string | null
    processingStatus?: $Enums.ReceiptStatus
    abn?: string | null
    taxInvoiceNumber?: string | null
    taxCategory?: string | null
    isGstRegistered?: boolean
    matchedTransactionId?: string | null
    matchConfidence?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceiptUncheckedCreateWithoutUserInput = {
    id?: string
    merchant?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    gstAmount?: Decimal | DecimalJsLike | number | string | null
    date: Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    aiProcessed?: boolean
    aiConfidence?: Decimal | DecimalJsLike | number | string | null
    aiProvider?: string | null
    aiModel?: string | null
    processingStatus?: $Enums.ReceiptStatus
    abn?: string | null
    taxInvoiceNumber?: string | null
    taxCategory?: string | null
    isGstRegistered?: boolean
    matchedTransactionId?: string | null
    matchConfidence?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceiptCreateOrConnectWithoutUserInput = {
    where: ReceiptWhereUniqueInput
    create: XOR<ReceiptCreateWithoutUserInput, ReceiptUncheckedCreateWithoutUserInput>
  }

  export type ReceiptCreateManyUserInputEnvelope = {
    data: ReceiptCreateManyUserInput | ReceiptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BudgetCreateWithoutUserInput = {
    id?: string
    name?: string | null
    monthlyBudget: Decimal | DecimalJsLike | number | string
    targetSavings?: Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: Decimal | DecimalJsLike | number | string | null
    predictions?: NullableJsonNullValueInput | InputJsonValue
    categoryLimits?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    aiProvider?: string | null
    aiModel?: string | null
    analysisPeriod?: string | null
    predictionPeriod?: string | null
    status?: $Enums.BudgetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateWithoutUserInput = {
    id?: string
    name?: string | null
    monthlyBudget: Decimal | DecimalJsLike | number | string
    targetSavings?: Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: Decimal | DecimalJsLike | number | string | null
    predictions?: NullableJsonNullValueInput | InputJsonValue
    categoryLimits?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    aiProvider?: string | null
    aiModel?: string | null
    analysisPeriod?: string | null
    predictionPeriod?: string | null
    status?: $Enums.BudgetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetCreateOrConnectWithoutUserInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput>
  }

  export type BudgetCreateManyUserInputEnvelope = {
    data: BudgetCreateManyUserInput | BudgetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BudgetTrackingCreateWithoutUserInput = {
    id?: string
    month: number
    year: number
    predictedAmount: Decimal | DecimalJsLike | number | string
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    category?: string | null
    createdAt?: Date | string
    budget: BudgetCreateNestedOneWithoutBudgetTrackingInput
  }

  export type BudgetTrackingUncheckedCreateWithoutUserInput = {
    id?: string
    budgetId: string
    month: number
    year: number
    predictedAmount: Decimal | DecimalJsLike | number | string
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    category?: string | null
    createdAt?: Date | string
  }

  export type BudgetTrackingCreateOrConnectWithoutUserInput = {
    where: BudgetTrackingWhereUniqueInput
    create: XOR<BudgetTrackingCreateWithoutUserInput, BudgetTrackingUncheckedCreateWithoutUserInput>
  }

  export type BudgetTrackingCreateManyUserInputEnvelope = {
    data: BudgetTrackingCreateManyUserInput | BudgetTrackingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FinancialInsightCreateWithoutUserInput = {
    id?: string
    insightType: string
    category?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: FinancialInsightCreatesourceDataIdsInput | string[]
    provider?: string | null
    model?: string | null
    title?: string | null
    description?: string | null
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    priority?: $Enums.InsightPriority
    isActive?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type FinancialInsightUncheckedCreateWithoutUserInput = {
    id?: string
    insightType: string
    category?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: FinancialInsightCreatesourceDataIdsInput | string[]
    provider?: string | null
    model?: string | null
    title?: string | null
    description?: string | null
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    priority?: $Enums.InsightPriority
    isActive?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type FinancialInsightCreateOrConnectWithoutUserInput = {
    where: FinancialInsightWhereUniqueInput
    create: XOR<FinancialInsightCreateWithoutUserInput, FinancialInsightUncheckedCreateWithoutUserInput>
  }

  export type FinancialInsightCreateManyUserInputEnvelope = {
    data: FinancialInsightCreateManyUserInput | FinancialInsightCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GoalCreateWithoutUserInput = {
    id?: string
    title: string
    targetAmount: Decimal | DecimalJsLike | number | string
    currentAmount?: Decimal | DecimalJsLike | number | string
    targetDate: Date | string
    category?: string | null
    status?: $Enums.GoalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    targetAmount: Decimal | DecimalJsLike | number | string
    currentAmount?: Decimal | DecimalJsLike | number | string
    targetDate: Date | string
    category?: string | null
    status?: $Enums.GoalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalCreateOrConnectWithoutUserInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutUserInput, GoalUncheckedCreateWithoutUserInput>
  }

  export type GoalCreateManyUserInputEnvelope = {
    data: GoalCreateManyUserInput | GoalCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FinancialAuditLogCreateWithoutUserInput = {
    id?: string
    sessionId?: string | null
    operationType: $Enums.FinancialOperation
    resourceType: string
    resourceId?: string | null
    ipAddress: string
    userAgent?: string | null
    httpMethod?: string | null
    endpoint?: string | null
    previousData?: NullableJsonNullValueInput | InputJsonValue
    currentData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: FinancialAuditLogCreatechangedFieldsInput | string[]
    amount?: Decimal | DecimalJsLike | number | string | null
    gstAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    taxYear?: string | null
    success?: boolean
    errorMessage?: string | null
    hashChain?: string | null
    previousHash?: string | null
    createdAt?: Date | string
    timezone?: string
  }

  export type FinancialAuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId?: string | null
    operationType: $Enums.FinancialOperation
    resourceType: string
    resourceId?: string | null
    ipAddress: string
    userAgent?: string | null
    httpMethod?: string | null
    endpoint?: string | null
    previousData?: NullableJsonNullValueInput | InputJsonValue
    currentData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: FinancialAuditLogCreatechangedFieldsInput | string[]
    amount?: Decimal | DecimalJsLike | number | string | null
    gstAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    taxYear?: string | null
    success?: boolean
    errorMessage?: string | null
    hashChain?: string | null
    previousHash?: string | null
    createdAt?: Date | string
    timezone?: string
  }

  export type FinancialAuditLogCreateOrConnectWithoutUserInput = {
    where: FinancialAuditLogWhereUniqueInput
    create: XOR<FinancialAuditLogCreateWithoutUserInput, FinancialAuditLogUncheckedCreateWithoutUserInput>
  }

  export type FinancialAuditLogCreateManyUserInputEnvelope = {
    data: FinancialAuditLogCreateManyUserInput | FinancialAuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AMLTransactionMonitoringCreateWithoutUserInput = {
    id?: string
    transactionId?: string | null
    monitoringType: $Enums.AMLMonitoringType
    riskScore: Decimal | DecimalJsLike | number | string
    riskFactors?: AMLTransactionMonitoringCreateriskFactorsInput | string[]
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    patternType?: string | null
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    velocityScore?: Decimal | DecimalJsLike | number | string | null
    requiresReview?: boolean
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reportedToAUSTRAC?: boolean
    reportReference?: string | null
    reportedAt?: Date | string | null
    falsePositive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AMLTransactionMonitoringUncheckedCreateWithoutUserInput = {
    id?: string
    transactionId?: string | null
    monitoringType: $Enums.AMLMonitoringType
    riskScore: Decimal | DecimalJsLike | number | string
    riskFactors?: AMLTransactionMonitoringCreateriskFactorsInput | string[]
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    patternType?: string | null
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    velocityScore?: Decimal | DecimalJsLike | number | string | null
    requiresReview?: boolean
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reportedToAUSTRAC?: boolean
    reportReference?: string | null
    reportedAt?: Date | string | null
    falsePositive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AMLTransactionMonitoringCreateOrConnectWithoutUserInput = {
    where: AMLTransactionMonitoringWhereUniqueInput
    create: XOR<AMLTransactionMonitoringCreateWithoutUserInput, AMLTransactionMonitoringUncheckedCreateWithoutUserInput>
  }

  export type AMLTransactionMonitoringCreateManyUserInputEnvelope = {
    data: AMLTransactionMonitoringCreateManyUserInput | AMLTransactionMonitoringCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PrivacyConsentCreateWithoutUserInput = {
    id?: string
    consentType: $Enums.ConsentType
    consentVersion: string
    consentStatus?: $Enums.ConsentStatus
    consentDate?: Date | string | null
    expiryDate?: Date | string | null
    purposes?: PrivacyConsentCreatepurposesInput | string[]
    dataCategories?: PrivacyConsentCreatedataCategoriesInput | string[]
    thirdParties?: PrivacyConsentCreatethirdPartiesInput | string[]
    withdrawnAt?: Date | string | null
    withdrawalReason?: string | null
    legalBasis: string
    jurisdiction?: string
    ipAddress: string
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivacyConsentUncheckedCreateWithoutUserInput = {
    id?: string
    consentType: $Enums.ConsentType
    consentVersion: string
    consentStatus?: $Enums.ConsentStatus
    consentDate?: Date | string | null
    expiryDate?: Date | string | null
    purposes?: PrivacyConsentCreatepurposesInput | string[]
    dataCategories?: PrivacyConsentCreatedataCategoriesInput | string[]
    thirdParties?: PrivacyConsentCreatethirdPartiesInput | string[]
    withdrawnAt?: Date | string | null
    withdrawalReason?: string | null
    legalBasis: string
    jurisdiction?: string
    ipAddress: string
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivacyConsentCreateOrConnectWithoutUserInput = {
    where: PrivacyConsentWhereUniqueInput
    create: XOR<PrivacyConsentCreateWithoutUserInput, PrivacyConsentUncheckedCreateWithoutUserInput>
  }

  export type PrivacyConsentCreateManyUserInputEnvelope = {
    data: PrivacyConsentCreateManyUserInput | PrivacyConsentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DataAccessRequestCreateWithoutUserInput = {
    id?: string
    requestType: $Enums.DataRequestType
    requestStatus?: $Enums.DataRequestStatus
    requestDate?: Date | string
    requestDetails?: NullableJsonNullValueInput | InputJsonValue
    verificationMethod?: string | null
    verifiedAt?: Date | string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    completedAt?: Date | string | null
    responseMethod?: string | null
    responseUrl?: string | null
    responseExpiryDate?: Date | string | null
    dueDate: Date | string
    extensionReason?: string | null
    extendedDueDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataAccessRequestUncheckedCreateWithoutUserInput = {
    id?: string
    requestType: $Enums.DataRequestType
    requestStatus?: $Enums.DataRequestStatus
    requestDate?: Date | string
    requestDetails?: NullableJsonNullValueInput | InputJsonValue
    verificationMethod?: string | null
    verifiedAt?: Date | string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    completedAt?: Date | string | null
    responseMethod?: string | null
    responseUrl?: string | null
    responseExpiryDate?: Date | string | null
    dueDate: Date | string
    extensionReason?: string | null
    extendedDueDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataAccessRequestCreateOrConnectWithoutUserInput = {
    where: DataAccessRequestWhereUniqueInput
    create: XOR<DataAccessRequestCreateWithoutUserInput, DataAccessRequestUncheckedCreateWithoutUserInput>
  }

  export type DataAccessRequestCreateManyUserInputEnvelope = {
    data: DataAccessRequestCreateManyUserInput | DataAccessRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    event?: EnumAuthEventFilter<"AuditLog"> | $Enums.AuthEvent
    ipAddress?: StringFilter<"AuditLog"> | string
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    success?: BoolFilter<"AuditLog"> | boolean
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    stripeCustomerId?: StringFilter<"Subscription"> | string
    stripeSubscriptionId?: StringFilter<"Subscription"> | string
    stripePriceId?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    plan?: EnumPlanFilter<"Subscription"> | $Enums.Plan
    interval?: StringFilter<"Subscription"> | string
    amount?: IntFilter<"Subscription"> | number
    currency?: StringFilter<"Subscription"> | string
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    defaultPaymentMethodId?: StringNullableFilter<"Subscription"> | string | null
    lastPaymentAttempt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    failedPaymentCount?: IntFilter<"Subscription"> | number
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type TaxReturnUpsertWithWhereUniqueWithoutUserInput = {
    where: TaxReturnWhereUniqueInput
    update: XOR<TaxReturnUpdateWithoutUserInput, TaxReturnUncheckedUpdateWithoutUserInput>
    create: XOR<TaxReturnCreateWithoutUserInput, TaxReturnUncheckedCreateWithoutUserInput>
  }

  export type TaxReturnUpdateWithWhereUniqueWithoutUserInput = {
    where: TaxReturnWhereUniqueInput
    data: XOR<TaxReturnUpdateWithoutUserInput, TaxReturnUncheckedUpdateWithoutUserInput>
  }

  export type TaxReturnUpdateManyWithWhereWithoutUserInput = {
    where: TaxReturnScalarWhereInput
    data: XOR<TaxReturnUpdateManyMutationInput, TaxReturnUncheckedUpdateManyWithoutUserInput>
  }

  export type TaxReturnScalarWhereInput = {
    AND?: TaxReturnScalarWhereInput | TaxReturnScalarWhereInput[]
    OR?: TaxReturnScalarWhereInput[]
    NOT?: TaxReturnScalarWhereInput | TaxReturnScalarWhereInput[]
    id?: StringFilter<"TaxReturn"> | string
    userId?: StringFilter<"TaxReturn"> | string
    year?: StringFilter<"TaxReturn"> | string
    data?: JsonFilter<"TaxReturn">
    status?: EnumTaxReturnStatusFilter<"TaxReturn"> | $Enums.TaxReturnStatus
    submittedAt?: DateTimeNullableFilter<"TaxReturn"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"TaxReturn"> | Date | string | null
    createdAt?: DateTimeFilter<"TaxReturn"> | Date | string
    updatedAt?: DateTimeFilter<"TaxReturn"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    stripePaymentIntentId?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    description?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type AIConversationUpsertWithWhereUniqueWithoutUserInput = {
    where: AIConversationWhereUniqueInput
    update: XOR<AIConversationUpdateWithoutUserInput, AIConversationUncheckedUpdateWithoutUserInput>
    create: XOR<AIConversationCreateWithoutUserInput, AIConversationUncheckedCreateWithoutUserInput>
  }

  export type AIConversationUpdateWithWhereUniqueWithoutUserInput = {
    where: AIConversationWhereUniqueInput
    data: XOR<AIConversationUpdateWithoutUserInput, AIConversationUncheckedUpdateWithoutUserInput>
  }

  export type AIConversationUpdateManyWithWhereWithoutUserInput = {
    where: AIConversationScalarWhereInput
    data: XOR<AIConversationUpdateManyMutationInput, AIConversationUncheckedUpdateManyWithoutUserInput>
  }

  export type AIConversationScalarWhereInput = {
    AND?: AIConversationScalarWhereInput | AIConversationScalarWhereInput[]
    OR?: AIConversationScalarWhereInput[]
    NOT?: AIConversationScalarWhereInput | AIConversationScalarWhereInput[]
    id?: StringFilter<"AIConversation"> | string
    userId?: StringFilter<"AIConversation"> | string
    sessionId?: UuidFilter<"AIConversation"> | string
    provider?: StringFilter<"AIConversation"> | string
    model?: StringFilter<"AIConversation"> | string
    messages?: JsonFilter<"AIConversation">
    context?: JsonNullableFilter<"AIConversation">
    tokensUsed?: IntFilter<"AIConversation"> | number
    costUsd?: DecimalFilter<"AIConversation"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"AIConversation"> | Date | string
    updatedAt?: DateTimeFilter<"AIConversation"> | Date | string
  }

  export type AIInsightUpsertWithWhereUniqueWithoutUserInput = {
    where: AIInsightWhereUniqueInput
    update: XOR<AIInsightUpdateWithoutUserInput, AIInsightUncheckedUpdateWithoutUserInput>
    create: XOR<AIInsightCreateWithoutUserInput, AIInsightUncheckedCreateWithoutUserInput>
  }

  export type AIInsightUpdateWithWhereUniqueWithoutUserInput = {
    where: AIInsightWhereUniqueInput
    data: XOR<AIInsightUpdateWithoutUserInput, AIInsightUncheckedUpdateWithoutUserInput>
  }

  export type AIInsightUpdateManyWithWhereWithoutUserInput = {
    where: AIInsightScalarWhereInput
    data: XOR<AIInsightUpdateManyMutationInput, AIInsightUncheckedUpdateManyWithoutUserInput>
  }

  export type AIInsightScalarWhereInput = {
    AND?: AIInsightScalarWhereInput | AIInsightScalarWhereInput[]
    OR?: AIInsightScalarWhereInput[]
    NOT?: AIInsightScalarWhereInput | AIInsightScalarWhereInput[]
    id?: StringFilter<"AIInsight"> | string
    userId?: StringFilter<"AIInsight"> | string
    insightType?: StringFilter<"AIInsight"> | string
    category?: StringFilter<"AIInsight"> | string
    content?: JsonFilter<"AIInsight">
    confidenceScore?: DecimalNullableFilter<"AIInsight"> | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: StringNullableListFilter<"AIInsight">
    provider?: StringFilter<"AIInsight"> | string
    model?: StringFilter<"AIInsight"> | string
    isActive?: BoolFilter<"AIInsight"> | boolean
    expiresAt?: DateTimeNullableFilter<"AIInsight"> | Date | string | null
    createdAt?: DateTimeFilter<"AIInsight"> | Date | string
  }

  export type AIUsageTrackingUpsertWithWhereUniqueWithoutUserInput = {
    where: AIUsageTrackingWhereUniqueInput
    update: XOR<AIUsageTrackingUpdateWithoutUserInput, AIUsageTrackingUncheckedUpdateWithoutUserInput>
    create: XOR<AIUsageTrackingCreateWithoutUserInput, AIUsageTrackingUncheckedCreateWithoutUserInput>
  }

  export type AIUsageTrackingUpdateWithWhereUniqueWithoutUserInput = {
    where: AIUsageTrackingWhereUniqueInput
    data: XOR<AIUsageTrackingUpdateWithoutUserInput, AIUsageTrackingUncheckedUpdateWithoutUserInput>
  }

  export type AIUsageTrackingUpdateManyWithWhereWithoutUserInput = {
    where: AIUsageTrackingScalarWhereInput
    data: XOR<AIUsageTrackingUpdateManyMutationInput, AIUsageTrackingUncheckedUpdateManyWithoutUserInput>
  }

  export type AIUsageTrackingScalarWhereInput = {
    AND?: AIUsageTrackingScalarWhereInput | AIUsageTrackingScalarWhereInput[]
    OR?: AIUsageTrackingScalarWhereInput[]
    NOT?: AIUsageTrackingScalarWhereInput | AIUsageTrackingScalarWhereInput[]
    id?: StringFilter<"AIUsageTracking"> | string
    userId?: StringFilter<"AIUsageTracking"> | string
    provider?: StringFilter<"AIUsageTracking"> | string
    model?: StringFilter<"AIUsageTracking"> | string
    operationType?: StringFilter<"AIUsageTracking"> | string
    tokensInput?: IntFilter<"AIUsageTracking"> | number
    tokensOutput?: IntFilter<"AIUsageTracking"> | number
    costUsd?: DecimalFilter<"AIUsageTracking"> | Decimal | DecimalJsLike | number | string
    responseTimeMs?: IntNullableFilter<"AIUsageTracking"> | number | null
    success?: BoolFilter<"AIUsageTracking"> | boolean
    errorMessage?: StringNullableFilter<"AIUsageTracking"> | string | null
    createdAt?: DateTimeFilter<"AIUsageTracking"> | Date | string
  }

  export type basiq_usersUpsertWithoutUserInput = {
    update: XOR<basiq_usersUpdateWithoutUserInput, basiq_usersUncheckedUpdateWithoutUserInput>
    create: XOR<basiq_usersCreateWithoutUserInput, basiq_usersUncheckedCreateWithoutUserInput>
    where?: basiq_usersWhereInput
  }

  export type basiq_usersUpdateToOneWithWhereWithoutUserInput = {
    where?: basiq_usersWhereInput
    data: XOR<basiq_usersUpdateWithoutUserInput, basiq_usersUncheckedUpdateWithoutUserInput>
  }

  export type basiq_usersUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    connection_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_id?: NullableStringFieldUpdateOperationsInput | string | null
    consent_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bank_connections?: bank_connectionsUpdateManyWithoutBasiq_userNestedInput
    bank_accounts?: bank_accountsUpdateManyWithoutBasiq_userNestedInput
  }

  export type basiq_usersUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    connection_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_id?: NullableStringFieldUpdateOperationsInput | string | null
    consent_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bank_connections?: bank_connectionsUncheckedUpdateManyWithoutBasiq_userNestedInput
    bank_accounts?: bank_accountsUncheckedUpdateManyWithoutBasiq_userNestedInput
  }

  export type basiq_api_logsUpsertWithWhereUniqueWithoutUserInput = {
    where: basiq_api_logsWhereUniqueInput
    update: XOR<basiq_api_logsUpdateWithoutUserInput, basiq_api_logsUncheckedUpdateWithoutUserInput>
    create: XOR<basiq_api_logsCreateWithoutUserInput, basiq_api_logsUncheckedCreateWithoutUserInput>
  }

  export type basiq_api_logsUpdateWithWhereUniqueWithoutUserInput = {
    where: basiq_api_logsWhereUniqueInput
    data: XOR<basiq_api_logsUpdateWithoutUserInput, basiq_api_logsUncheckedUpdateWithoutUserInput>
  }

  export type basiq_api_logsUpdateManyWithWhereWithoutUserInput = {
    where: basiq_api_logsScalarWhereInput
    data: XOR<basiq_api_logsUpdateManyMutationInput, basiq_api_logsUncheckedUpdateManyWithoutUserInput>
  }

  export type basiq_api_logsScalarWhereInput = {
    AND?: basiq_api_logsScalarWhereInput | basiq_api_logsScalarWhereInput[]
    OR?: basiq_api_logsScalarWhereInput[]
    NOT?: basiq_api_logsScalarWhereInput | basiq_api_logsScalarWhereInput[]
    id?: UuidFilter<"basiq_api_logs"> | string
    user_id?: StringNullableFilter<"basiq_api_logs"> | string | null
    endpoint?: StringFilter<"basiq_api_logs"> | string
    method?: StringFilter<"basiq_api_logs"> | string
    request_body?: JsonNullableFilter<"basiq_api_logs">
    response_status?: IntNullableFilter<"basiq_api_logs"> | number | null
    response_body?: JsonNullableFilter<"basiq_api_logs">
    error_message?: StringNullableFilter<"basiq_api_logs"> | string | null
    duration_ms?: IntNullableFilter<"basiq_api_logs"> | number | null
    created_at?: DateTimeFilter<"basiq_api_logs"> | Date | string
  }

  export type ReceiptUpsertWithWhereUniqueWithoutUserInput = {
    where: ReceiptWhereUniqueInput
    update: XOR<ReceiptUpdateWithoutUserInput, ReceiptUncheckedUpdateWithoutUserInput>
    create: XOR<ReceiptCreateWithoutUserInput, ReceiptUncheckedCreateWithoutUserInput>
  }

  export type ReceiptUpdateWithWhereUniqueWithoutUserInput = {
    where: ReceiptWhereUniqueInput
    data: XOR<ReceiptUpdateWithoutUserInput, ReceiptUncheckedUpdateWithoutUserInput>
  }

  export type ReceiptUpdateManyWithWhereWithoutUserInput = {
    where: ReceiptScalarWhereInput
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyWithoutUserInput>
  }

  export type ReceiptScalarWhereInput = {
    AND?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
    OR?: ReceiptScalarWhereInput[]
    NOT?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
    id?: StringFilter<"Receipt"> | string
    userId?: StringFilter<"Receipt"> | string
    merchant?: StringNullableFilter<"Receipt"> | string | null
    totalAmount?: DecimalFilter<"Receipt"> | Decimal | DecimalJsLike | number | string
    gstAmount?: DecimalNullableFilter<"Receipt"> | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFilter<"Receipt"> | Date | string
    items?: JsonNullableFilter<"Receipt">
    imageUrl?: StringNullableFilter<"Receipt"> | string | null
    aiProcessed?: BoolFilter<"Receipt"> | boolean
    aiConfidence?: DecimalNullableFilter<"Receipt"> | Decimal | DecimalJsLike | number | string | null
    aiProvider?: StringNullableFilter<"Receipt"> | string | null
    aiModel?: StringNullableFilter<"Receipt"> | string | null
    processingStatus?: EnumReceiptStatusFilter<"Receipt"> | $Enums.ReceiptStatus
    abn?: StringNullableFilter<"Receipt"> | string | null
    taxInvoiceNumber?: StringNullableFilter<"Receipt"> | string | null
    taxCategory?: StringNullableFilter<"Receipt"> | string | null
    isGstRegistered?: BoolFilter<"Receipt"> | boolean
    matchedTransactionId?: StringNullableFilter<"Receipt"> | string | null
    matchConfidence?: DecimalNullableFilter<"Receipt"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Receipt"> | Date | string
    updatedAt?: DateTimeFilter<"Receipt"> | Date | string
  }

  export type BudgetUpsertWithWhereUniqueWithoutUserInput = {
    where: BudgetWhereUniqueInput
    update: XOR<BudgetUpdateWithoutUserInput, BudgetUncheckedUpdateWithoutUserInput>
    create: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput>
  }

  export type BudgetUpdateWithWhereUniqueWithoutUserInput = {
    where: BudgetWhereUniqueInput
    data: XOR<BudgetUpdateWithoutUserInput, BudgetUncheckedUpdateWithoutUserInput>
  }

  export type BudgetUpdateManyWithWhereWithoutUserInput = {
    where: BudgetScalarWhereInput
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyWithoutUserInput>
  }

  export type BudgetScalarWhereInput = {
    AND?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    OR?: BudgetScalarWhereInput[]
    NOT?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    id?: StringFilter<"Budget"> | string
    userId?: StringFilter<"Budget"> | string
    name?: StringNullableFilter<"Budget"> | string | null
    monthlyBudget?: DecimalFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    targetSavings?: DecimalNullableFilter<"Budget"> | Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: DecimalNullableFilter<"Budget"> | Decimal | DecimalJsLike | number | string | null
    predictions?: JsonNullableFilter<"Budget">
    categoryLimits?: JsonNullableFilter<"Budget">
    confidenceScore?: DecimalNullableFilter<"Budget"> | Decimal | DecimalJsLike | number | string | null
    aiProvider?: StringNullableFilter<"Budget"> | string | null
    aiModel?: StringNullableFilter<"Budget"> | string | null
    analysisPeriod?: StringNullableFilter<"Budget"> | string | null
    predictionPeriod?: StringNullableFilter<"Budget"> | string | null
    status?: EnumBudgetStatusFilter<"Budget"> | $Enums.BudgetStatus
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
  }

  export type BudgetTrackingUpsertWithWhereUniqueWithoutUserInput = {
    where: BudgetTrackingWhereUniqueInput
    update: XOR<BudgetTrackingUpdateWithoutUserInput, BudgetTrackingUncheckedUpdateWithoutUserInput>
    create: XOR<BudgetTrackingCreateWithoutUserInput, BudgetTrackingUncheckedCreateWithoutUserInput>
  }

  export type BudgetTrackingUpdateWithWhereUniqueWithoutUserInput = {
    where: BudgetTrackingWhereUniqueInput
    data: XOR<BudgetTrackingUpdateWithoutUserInput, BudgetTrackingUncheckedUpdateWithoutUserInput>
  }

  export type BudgetTrackingUpdateManyWithWhereWithoutUserInput = {
    where: BudgetTrackingScalarWhereInput
    data: XOR<BudgetTrackingUpdateManyMutationInput, BudgetTrackingUncheckedUpdateManyWithoutUserInput>
  }

  export type BudgetTrackingScalarWhereInput = {
    AND?: BudgetTrackingScalarWhereInput | BudgetTrackingScalarWhereInput[]
    OR?: BudgetTrackingScalarWhereInput[]
    NOT?: BudgetTrackingScalarWhereInput | BudgetTrackingScalarWhereInput[]
    id?: StringFilter<"BudgetTracking"> | string
    budgetId?: StringFilter<"BudgetTracking"> | string
    userId?: StringFilter<"BudgetTracking"> | string
    month?: IntFilter<"BudgetTracking"> | number
    year?: IntFilter<"BudgetTracking"> | number
    predictedAmount?: DecimalFilter<"BudgetTracking"> | Decimal | DecimalJsLike | number | string
    actualAmount?: DecimalNullableFilter<"BudgetTracking"> | Decimal | DecimalJsLike | number | string | null
    variance?: DecimalNullableFilter<"BudgetTracking"> | Decimal | DecimalJsLike | number | string | null
    category?: StringNullableFilter<"BudgetTracking"> | string | null
    createdAt?: DateTimeFilter<"BudgetTracking"> | Date | string
  }

  export type FinancialInsightUpsertWithWhereUniqueWithoutUserInput = {
    where: FinancialInsightWhereUniqueInput
    update: XOR<FinancialInsightUpdateWithoutUserInput, FinancialInsightUncheckedUpdateWithoutUserInput>
    create: XOR<FinancialInsightCreateWithoutUserInput, FinancialInsightUncheckedCreateWithoutUserInput>
  }

  export type FinancialInsightUpdateWithWhereUniqueWithoutUserInput = {
    where: FinancialInsightWhereUniqueInput
    data: XOR<FinancialInsightUpdateWithoutUserInput, FinancialInsightUncheckedUpdateWithoutUserInput>
  }

  export type FinancialInsightUpdateManyWithWhereWithoutUserInput = {
    where: FinancialInsightScalarWhereInput
    data: XOR<FinancialInsightUpdateManyMutationInput, FinancialInsightUncheckedUpdateManyWithoutUserInput>
  }

  export type FinancialInsightScalarWhereInput = {
    AND?: FinancialInsightScalarWhereInput | FinancialInsightScalarWhereInput[]
    OR?: FinancialInsightScalarWhereInput[]
    NOT?: FinancialInsightScalarWhereInput | FinancialInsightScalarWhereInput[]
    id?: StringFilter<"FinancialInsight"> | string
    userId?: StringFilter<"FinancialInsight"> | string
    insightType?: StringFilter<"FinancialInsight"> | string
    category?: StringNullableFilter<"FinancialInsight"> | string | null
    content?: JsonNullableFilter<"FinancialInsight">
    confidenceScore?: DecimalNullableFilter<"FinancialInsight"> | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: StringNullableListFilter<"FinancialInsight">
    provider?: StringNullableFilter<"FinancialInsight"> | string | null
    model?: StringNullableFilter<"FinancialInsight"> | string | null
    title?: StringNullableFilter<"FinancialInsight"> | string | null
    description?: StringNullableFilter<"FinancialInsight"> | string | null
    recommendations?: JsonNullableFilter<"FinancialInsight">
    priority?: EnumInsightPriorityFilter<"FinancialInsight"> | $Enums.InsightPriority
    isActive?: BoolFilter<"FinancialInsight"> | boolean
    createdAt?: DateTimeFilter<"FinancialInsight"> | Date | string
    expiresAt?: DateTimeNullableFilter<"FinancialInsight"> | Date | string | null
  }

  export type GoalUpsertWithWhereUniqueWithoutUserInput = {
    where: GoalWhereUniqueInput
    update: XOR<GoalUpdateWithoutUserInput, GoalUncheckedUpdateWithoutUserInput>
    create: XOR<GoalCreateWithoutUserInput, GoalUncheckedCreateWithoutUserInput>
  }

  export type GoalUpdateWithWhereUniqueWithoutUserInput = {
    where: GoalWhereUniqueInput
    data: XOR<GoalUpdateWithoutUserInput, GoalUncheckedUpdateWithoutUserInput>
  }

  export type GoalUpdateManyWithWhereWithoutUserInput = {
    where: GoalScalarWhereInput
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyWithoutUserInput>
  }

  export type GoalScalarWhereInput = {
    AND?: GoalScalarWhereInput | GoalScalarWhereInput[]
    OR?: GoalScalarWhereInput[]
    NOT?: GoalScalarWhereInput | GoalScalarWhereInput[]
    id?: StringFilter<"Goal"> | string
    userId?: StringFilter<"Goal"> | string
    title?: StringFilter<"Goal"> | string
    targetAmount?: DecimalFilter<"Goal"> | Decimal | DecimalJsLike | number | string
    currentAmount?: DecimalFilter<"Goal"> | Decimal | DecimalJsLike | number | string
    targetDate?: DateTimeFilter<"Goal"> | Date | string
    category?: StringNullableFilter<"Goal"> | string | null
    status?: EnumGoalStatusFilter<"Goal"> | $Enums.GoalStatus
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    updatedAt?: DateTimeFilter<"Goal"> | Date | string
  }

  export type FinancialAuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: FinancialAuditLogWhereUniqueInput
    update: XOR<FinancialAuditLogUpdateWithoutUserInput, FinancialAuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<FinancialAuditLogCreateWithoutUserInput, FinancialAuditLogUncheckedCreateWithoutUserInput>
  }

  export type FinancialAuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: FinancialAuditLogWhereUniqueInput
    data: XOR<FinancialAuditLogUpdateWithoutUserInput, FinancialAuditLogUncheckedUpdateWithoutUserInput>
  }

  export type FinancialAuditLogUpdateManyWithWhereWithoutUserInput = {
    where: FinancialAuditLogScalarWhereInput
    data: XOR<FinancialAuditLogUpdateManyMutationInput, FinancialAuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type FinancialAuditLogScalarWhereInput = {
    AND?: FinancialAuditLogScalarWhereInput | FinancialAuditLogScalarWhereInput[]
    OR?: FinancialAuditLogScalarWhereInput[]
    NOT?: FinancialAuditLogScalarWhereInput | FinancialAuditLogScalarWhereInput[]
    id?: StringFilter<"FinancialAuditLog"> | string
    userId?: StringFilter<"FinancialAuditLog"> | string
    sessionId?: UuidNullableFilter<"FinancialAuditLog"> | string | null
    operationType?: EnumFinancialOperationFilter<"FinancialAuditLog"> | $Enums.FinancialOperation
    resourceType?: StringFilter<"FinancialAuditLog"> | string
    resourceId?: UuidNullableFilter<"FinancialAuditLog"> | string | null
    ipAddress?: StringFilter<"FinancialAuditLog"> | string
    userAgent?: StringNullableFilter<"FinancialAuditLog"> | string | null
    httpMethod?: StringNullableFilter<"FinancialAuditLog"> | string | null
    endpoint?: StringNullableFilter<"FinancialAuditLog"> | string | null
    previousData?: JsonNullableFilter<"FinancialAuditLog">
    currentData?: JsonNullableFilter<"FinancialAuditLog">
    changedFields?: StringNullableListFilter<"FinancialAuditLog">
    amount?: DecimalNullableFilter<"FinancialAuditLog"> | Decimal | DecimalJsLike | number | string | null
    gstAmount?: DecimalNullableFilter<"FinancialAuditLog"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"FinancialAuditLog"> | string | null
    taxYear?: StringNullableFilter<"FinancialAuditLog"> | string | null
    success?: BoolFilter<"FinancialAuditLog"> | boolean
    errorMessage?: StringNullableFilter<"FinancialAuditLog"> | string | null
    hashChain?: StringNullableFilter<"FinancialAuditLog"> | string | null
    previousHash?: StringNullableFilter<"FinancialAuditLog"> | string | null
    createdAt?: DateTimeFilter<"FinancialAuditLog"> | Date | string
    timezone?: StringFilter<"FinancialAuditLog"> | string
  }

  export type AMLTransactionMonitoringUpsertWithWhereUniqueWithoutUserInput = {
    where: AMLTransactionMonitoringWhereUniqueInput
    update: XOR<AMLTransactionMonitoringUpdateWithoutUserInput, AMLTransactionMonitoringUncheckedUpdateWithoutUserInput>
    create: XOR<AMLTransactionMonitoringCreateWithoutUserInput, AMLTransactionMonitoringUncheckedCreateWithoutUserInput>
  }

  export type AMLTransactionMonitoringUpdateWithWhereUniqueWithoutUserInput = {
    where: AMLTransactionMonitoringWhereUniqueInput
    data: XOR<AMLTransactionMonitoringUpdateWithoutUserInput, AMLTransactionMonitoringUncheckedUpdateWithoutUserInput>
  }

  export type AMLTransactionMonitoringUpdateManyWithWhereWithoutUserInput = {
    where: AMLTransactionMonitoringScalarWhereInput
    data: XOR<AMLTransactionMonitoringUpdateManyMutationInput, AMLTransactionMonitoringUncheckedUpdateManyWithoutUserInput>
  }

  export type AMLTransactionMonitoringScalarWhereInput = {
    AND?: AMLTransactionMonitoringScalarWhereInput | AMLTransactionMonitoringScalarWhereInput[]
    OR?: AMLTransactionMonitoringScalarWhereInput[]
    NOT?: AMLTransactionMonitoringScalarWhereInput | AMLTransactionMonitoringScalarWhereInput[]
    id?: StringFilter<"AMLTransactionMonitoring"> | string
    userId?: StringFilter<"AMLTransactionMonitoring"> | string
    transactionId?: UuidNullableFilter<"AMLTransactionMonitoring"> | string | null
    monitoringType?: EnumAMLMonitoringTypeFilter<"AMLTransactionMonitoring"> | $Enums.AMLMonitoringType
    riskScore?: DecimalFilter<"AMLTransactionMonitoring"> | Decimal | DecimalJsLike | number | string
    riskFactors?: StringNullableListFilter<"AMLTransactionMonitoring">
    amount?: DecimalFilter<"AMLTransactionMonitoring"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"AMLTransactionMonitoring"> | string
    patternType?: StringNullableFilter<"AMLTransactionMonitoring"> | string | null
    patternDetails?: JsonNullableFilter<"AMLTransactionMonitoring">
    velocityScore?: DecimalNullableFilter<"AMLTransactionMonitoring"> | Decimal | DecimalJsLike | number | string | null
    requiresReview?: BoolFilter<"AMLTransactionMonitoring"> | boolean
    reviewedBy?: StringNullableFilter<"AMLTransactionMonitoring"> | string | null
    reviewedAt?: DateTimeNullableFilter<"AMLTransactionMonitoring"> | Date | string | null
    reportedToAUSTRAC?: BoolFilter<"AMLTransactionMonitoring"> | boolean
    reportReference?: StringNullableFilter<"AMLTransactionMonitoring"> | string | null
    reportedAt?: DateTimeNullableFilter<"AMLTransactionMonitoring"> | Date | string | null
    falsePositive?: BoolFilter<"AMLTransactionMonitoring"> | boolean
    notes?: StringNullableFilter<"AMLTransactionMonitoring"> | string | null
    createdAt?: DateTimeFilter<"AMLTransactionMonitoring"> | Date | string
    updatedAt?: DateTimeFilter<"AMLTransactionMonitoring"> | Date | string
  }

  export type PrivacyConsentUpsertWithWhereUniqueWithoutUserInput = {
    where: PrivacyConsentWhereUniqueInput
    update: XOR<PrivacyConsentUpdateWithoutUserInput, PrivacyConsentUncheckedUpdateWithoutUserInput>
    create: XOR<PrivacyConsentCreateWithoutUserInput, PrivacyConsentUncheckedCreateWithoutUserInput>
  }

  export type PrivacyConsentUpdateWithWhereUniqueWithoutUserInput = {
    where: PrivacyConsentWhereUniqueInput
    data: XOR<PrivacyConsentUpdateWithoutUserInput, PrivacyConsentUncheckedUpdateWithoutUserInput>
  }

  export type PrivacyConsentUpdateManyWithWhereWithoutUserInput = {
    where: PrivacyConsentScalarWhereInput
    data: XOR<PrivacyConsentUpdateManyMutationInput, PrivacyConsentUncheckedUpdateManyWithoutUserInput>
  }

  export type PrivacyConsentScalarWhereInput = {
    AND?: PrivacyConsentScalarWhereInput | PrivacyConsentScalarWhereInput[]
    OR?: PrivacyConsentScalarWhereInput[]
    NOT?: PrivacyConsentScalarWhereInput | PrivacyConsentScalarWhereInput[]
    id?: StringFilter<"PrivacyConsent"> | string
    userId?: StringFilter<"PrivacyConsent"> | string
    consentType?: EnumConsentTypeFilter<"PrivacyConsent"> | $Enums.ConsentType
    consentVersion?: StringFilter<"PrivacyConsent"> | string
    consentStatus?: EnumConsentStatusFilter<"PrivacyConsent"> | $Enums.ConsentStatus
    consentDate?: DateTimeNullableFilter<"PrivacyConsent"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"PrivacyConsent"> | Date | string | null
    purposes?: StringNullableListFilter<"PrivacyConsent">
    dataCategories?: StringNullableListFilter<"PrivacyConsent">
    thirdParties?: StringNullableListFilter<"PrivacyConsent">
    withdrawnAt?: DateTimeNullableFilter<"PrivacyConsent"> | Date | string | null
    withdrawalReason?: StringNullableFilter<"PrivacyConsent"> | string | null
    legalBasis?: StringFilter<"PrivacyConsent"> | string
    jurisdiction?: StringFilter<"PrivacyConsent"> | string
    ipAddress?: StringFilter<"PrivacyConsent"> | string
    userAgent?: StringNullableFilter<"PrivacyConsent"> | string | null
    createdAt?: DateTimeFilter<"PrivacyConsent"> | Date | string
    updatedAt?: DateTimeFilter<"PrivacyConsent"> | Date | string
  }

  export type DataAccessRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: DataAccessRequestWhereUniqueInput
    update: XOR<DataAccessRequestUpdateWithoutUserInput, DataAccessRequestUncheckedUpdateWithoutUserInput>
    create: XOR<DataAccessRequestCreateWithoutUserInput, DataAccessRequestUncheckedCreateWithoutUserInput>
  }

  export type DataAccessRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: DataAccessRequestWhereUniqueInput
    data: XOR<DataAccessRequestUpdateWithoutUserInput, DataAccessRequestUncheckedUpdateWithoutUserInput>
  }

  export type DataAccessRequestUpdateManyWithWhereWithoutUserInput = {
    where: DataAccessRequestScalarWhereInput
    data: XOR<DataAccessRequestUpdateManyMutationInput, DataAccessRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type DataAccessRequestScalarWhereInput = {
    AND?: DataAccessRequestScalarWhereInput | DataAccessRequestScalarWhereInput[]
    OR?: DataAccessRequestScalarWhereInput[]
    NOT?: DataAccessRequestScalarWhereInput | DataAccessRequestScalarWhereInput[]
    id?: StringFilter<"DataAccessRequest"> | string
    userId?: StringFilter<"DataAccessRequest"> | string
    requestType?: EnumDataRequestTypeFilter<"DataAccessRequest"> | $Enums.DataRequestType
    requestStatus?: EnumDataRequestStatusFilter<"DataAccessRequest"> | $Enums.DataRequestStatus
    requestDate?: DateTimeFilter<"DataAccessRequest"> | Date | string
    requestDetails?: JsonNullableFilter<"DataAccessRequest">
    verificationMethod?: StringNullableFilter<"DataAccessRequest"> | string | null
    verifiedAt?: DateTimeNullableFilter<"DataAccessRequest"> | Date | string | null
    processedBy?: StringNullableFilter<"DataAccessRequest"> | string | null
    processedAt?: DateTimeNullableFilter<"DataAccessRequest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DataAccessRequest"> | Date | string | null
    responseMethod?: StringNullableFilter<"DataAccessRequest"> | string | null
    responseUrl?: StringNullableFilter<"DataAccessRequest"> | string | null
    responseExpiryDate?: DateTimeNullableFilter<"DataAccessRequest"> | Date | string | null
    dueDate?: DateTimeFilter<"DataAccessRequest"> | Date | string
    extensionReason?: StringNullableFilter<"DataAccessRequest"> | string | null
    extendedDueDate?: DateTimeNullableFilter<"DataAccessRequest"> | Date | string | null
    notes?: StringNullableFilter<"DataAccessRequest"> | string | null
    createdAt?: DateTimeFilter<"DataAccessRequest"> | Date | string
    updatedAt?: DateTimeFilter<"DataAccessRequest"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFinancialAuditLogsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFinancialAuditLogsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFinancialAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFinancialAuditLogsInput, UserUncheckedCreateWithoutFinancialAuditLogsInput>
  }

  export type UserUpsertWithoutFinancialAuditLogsInput = {
    update: XOR<UserUpdateWithoutFinancialAuditLogsInput, UserUncheckedUpdateWithoutFinancialAuditLogsInput>
    create: XOR<UserCreateWithoutFinancialAuditLogsInput, UserUncheckedCreateWithoutFinancialAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFinancialAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFinancialAuditLogsInput, UserUncheckedUpdateWithoutFinancialAuditLogsInput>
  }

  export type UserUpdateWithoutFinancialAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFinancialAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type UserUpsertWithoutSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTaxReturnsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTaxReturnsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTaxReturnsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaxReturnsInput, UserUncheckedCreateWithoutTaxReturnsInput>
  }

  export type UserUpsertWithoutTaxReturnsInput = {
    update: XOR<UserUpdateWithoutTaxReturnsInput, UserUncheckedUpdateWithoutTaxReturnsInput>
    create: XOR<UserCreateWithoutTaxReturnsInput, UserUncheckedCreateWithoutTaxReturnsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaxReturnsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaxReturnsInput, UserUncheckedUpdateWithoutTaxReturnsInput>
  }

  export type UserUpdateWithoutTaxReturnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTaxReturnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InvoiceLineItemCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceLineItemWhereUniqueInput
    create: XOR<InvoiceLineItemCreateWithoutInvoiceInput, InvoiceLineItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceLineItemCreateManyInvoiceInput | InvoiceLineItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceLineItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineItemWhereUniqueInput
    update: XOR<InvoiceLineItemUpdateWithoutInvoiceInput, InvoiceLineItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceLineItemCreateWithoutInvoiceInput, InvoiceLineItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineItemWhereUniqueInput
    data: XOR<InvoiceLineItemUpdateWithoutInvoiceInput, InvoiceLineItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceLineItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceLineItemScalarWhereInput
    data: XOR<InvoiceLineItemUpdateManyMutationInput, InvoiceLineItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceLineItemScalarWhereInput = {
    AND?: InvoiceLineItemScalarWhereInput | InvoiceLineItemScalarWhereInput[]
    OR?: InvoiceLineItemScalarWhereInput[]
    NOT?: InvoiceLineItemScalarWhereInput | InvoiceLineItemScalarWhereInput[]
    id?: StringFilter<"InvoiceLineItem"> | string
    invoiceId?: StringFilter<"InvoiceLineItem"> | string
    description?: StringFilter<"InvoiceLineItem"> | string
    quantity?: IntFilter<"InvoiceLineItem"> | number
    unitPrice?: IntFilter<"InvoiceLineItem"> | number
    totalPrice?: IntFilter<"InvoiceLineItem"> | number
    createdAt?: DateTimeFilter<"InvoiceLineItem"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceLineItem"> | Date | string
  }

  export type InvoiceCreateWithoutLineItemsInput = {
    id?: string
    invoiceNumber: string
    stripeInvoiceId: string
    customerName: string
    customerEmail: string
    customerABN?: string | null
    subtotal: number
    gstAmount: number
    total: number
    status: string
    invoiceDate: Date | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUncheckedCreateWithoutLineItemsInput = {
    id?: string
    invoiceNumber: string
    stripeInvoiceId: string
    customerName: string
    customerEmail: string
    customerABN?: string | null
    subtotal: number
    gstAmount: number
    total: number
    status: string
    invoiceDate: Date | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutLineItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLineItemsInput, InvoiceUncheckedCreateWithoutLineItemsInput>
  }

  export type InvoiceUpsertWithoutLineItemsInput = {
    update: XOR<InvoiceUpdateWithoutLineItemsInput, InvoiceUncheckedUpdateWithoutLineItemsInput>
    create: XOR<InvoiceCreateWithoutLineItemsInput, InvoiceUncheckedCreateWithoutLineItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutLineItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutLineItemsInput, InvoiceUncheckedUpdateWithoutLineItemsInput>
  }

  export type InvoiceUpdateWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerABN?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: IntFieldUpdateOperationsInput | number
    gstAmount?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerABN?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: IntFieldUpdateOperationsInput | number
    gstAmount?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAiConversationsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAiConversationsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAiConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiConversationsInput, UserUncheckedCreateWithoutAiConversationsInput>
  }

  export type UserUpsertWithoutAiConversationsInput = {
    update: XOR<UserUpdateWithoutAiConversationsInput, UserUncheckedUpdateWithoutAiConversationsInput>
    create: XOR<UserCreateWithoutAiConversationsInput, UserUncheckedCreateWithoutAiConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAiConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAiConversationsInput, UserUncheckedUpdateWithoutAiConversationsInput>
  }

  export type UserUpdateWithoutAiConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAiConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAiInsightsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAiInsightsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAiInsightsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiInsightsInput, UserUncheckedCreateWithoutAiInsightsInput>
  }

  export type UserUpsertWithoutAiInsightsInput = {
    update: XOR<UserUpdateWithoutAiInsightsInput, UserUncheckedUpdateWithoutAiInsightsInput>
    create: XOR<UserCreateWithoutAiInsightsInput, UserUncheckedCreateWithoutAiInsightsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAiInsightsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAiInsightsInput, UserUncheckedUpdateWithoutAiInsightsInput>
  }

  export type UserUpdateWithoutAiInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAiInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAiUsageTrackingInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAiUsageTrackingInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAiUsageTrackingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiUsageTrackingInput, UserUncheckedCreateWithoutAiUsageTrackingInput>
  }

  export type UserUpsertWithoutAiUsageTrackingInput = {
    update: XOR<UserUpdateWithoutAiUsageTrackingInput, UserUncheckedUpdateWithoutAiUsageTrackingInput>
    create: XOR<UserCreateWithoutAiUsageTrackingInput, UserUncheckedCreateWithoutAiUsageTrackingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAiUsageTrackingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAiUsageTrackingInput, UserUncheckedUpdateWithoutAiUsageTrackingInput>
  }

  export type UserUpdateWithoutAiUsageTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAiUsageTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBasiq_usersInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBasiq_usersInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBasiq_usersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBasiq_usersInput, UserUncheckedCreateWithoutBasiq_usersInput>
  }

  export type bank_connectionsCreateWithoutBasiq_userInput = {
    id?: string
    connection_id: string
    institution_id: string
    institution_name: string
    institution_short_name?: string | null
    institution_logo_url?: string | null
    status?: string | null
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    bank_accounts?: bank_accountsCreateNestedManyWithoutConnectionInput
  }

  export type bank_connectionsUncheckedCreateWithoutBasiq_userInput = {
    id?: string
    connection_id: string
    institution_id: string
    institution_name: string
    institution_short_name?: string | null
    institution_logo_url?: string | null
    status?: string | null
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    bank_accounts?: bank_accountsUncheckedCreateNestedManyWithoutConnectionInput
  }

  export type bank_connectionsCreateOrConnectWithoutBasiq_userInput = {
    where: bank_connectionsWhereUniqueInput
    create: XOR<bank_connectionsCreateWithoutBasiq_userInput, bank_connectionsUncheckedCreateWithoutBasiq_userInput>
  }

  export type bank_connectionsCreateManyBasiq_userInputEnvelope = {
    data: bank_connectionsCreateManyBasiq_userInput | bank_connectionsCreateManyBasiq_userInput[]
    skipDuplicates?: boolean
  }

  export type bank_accountsCreateWithoutBasiq_userInput = {
    id?: string
    basiq_account_id: string
    account_holder?: string | null
    account_number?: string | null
    bsb?: string | null
    institution_name?: string | null
    account_type?: string | null
    account_name?: string | null
    balance_available?: Decimal | DecimalJsLike | number | string | null
    balance_current?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    is_business_account?: boolean
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    connection: bank_connectionsCreateNestedOneWithoutBank_accountsInput
    bank_transactions?: bank_transactionsCreateNestedManyWithoutBank_accountInput
  }

  export type bank_accountsUncheckedCreateWithoutBasiq_userInput = {
    id?: string
    connection_id: string
    basiq_account_id: string
    account_holder?: string | null
    account_number?: string | null
    bsb?: string | null
    institution_name?: string | null
    account_type?: string | null
    account_name?: string | null
    balance_available?: Decimal | DecimalJsLike | number | string | null
    balance_current?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    is_business_account?: boolean
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    bank_transactions?: bank_transactionsUncheckedCreateNestedManyWithoutBank_accountInput
  }

  export type bank_accountsCreateOrConnectWithoutBasiq_userInput = {
    where: bank_accountsWhereUniqueInput
    create: XOR<bank_accountsCreateWithoutBasiq_userInput, bank_accountsUncheckedCreateWithoutBasiq_userInput>
  }

  export type bank_accountsCreateManyBasiq_userInputEnvelope = {
    data: bank_accountsCreateManyBasiq_userInput | bank_accountsCreateManyBasiq_userInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBasiq_usersInput = {
    update: XOR<UserUpdateWithoutBasiq_usersInput, UserUncheckedUpdateWithoutBasiq_usersInput>
    create: XOR<UserCreateWithoutBasiq_usersInput, UserUncheckedCreateWithoutBasiq_usersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBasiq_usersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBasiq_usersInput, UserUncheckedUpdateWithoutBasiq_usersInput>
  }

  export type UserUpdateWithoutBasiq_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBasiq_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type bank_connectionsUpsertWithWhereUniqueWithoutBasiq_userInput = {
    where: bank_connectionsWhereUniqueInput
    update: XOR<bank_connectionsUpdateWithoutBasiq_userInput, bank_connectionsUncheckedUpdateWithoutBasiq_userInput>
    create: XOR<bank_connectionsCreateWithoutBasiq_userInput, bank_connectionsUncheckedCreateWithoutBasiq_userInput>
  }

  export type bank_connectionsUpdateWithWhereUniqueWithoutBasiq_userInput = {
    where: bank_connectionsWhereUniqueInput
    data: XOR<bank_connectionsUpdateWithoutBasiq_userInput, bank_connectionsUncheckedUpdateWithoutBasiq_userInput>
  }

  export type bank_connectionsUpdateManyWithWhereWithoutBasiq_userInput = {
    where: bank_connectionsScalarWhereInput
    data: XOR<bank_connectionsUpdateManyMutationInput, bank_connectionsUncheckedUpdateManyWithoutBasiq_userInput>
  }

  export type bank_connectionsScalarWhereInput = {
    AND?: bank_connectionsScalarWhereInput | bank_connectionsScalarWhereInput[]
    OR?: bank_connectionsScalarWhereInput[]
    NOT?: bank_connectionsScalarWhereInput | bank_connectionsScalarWhereInput[]
    id?: UuidFilter<"bank_connections"> | string
    basiq_user_id?: UuidFilter<"bank_connections"> | string
    connection_id?: StringFilter<"bank_connections"> | string
    institution_id?: StringFilter<"bank_connections"> | string
    institution_name?: StringFilter<"bank_connections"> | string
    institution_short_name?: StringNullableFilter<"bank_connections"> | string | null
    institution_logo_url?: StringNullableFilter<"bank_connections"> | string | null
    status?: StringNullableFilter<"bank_connections"> | string | null
    last_synced?: DateTimeNullableFilter<"bank_connections"> | Date | string | null
    created_at?: DateTimeFilter<"bank_connections"> | Date | string
    updated_at?: DateTimeFilter<"bank_connections"> | Date | string
  }

  export type bank_accountsUpsertWithWhereUniqueWithoutBasiq_userInput = {
    where: bank_accountsWhereUniqueInput
    update: XOR<bank_accountsUpdateWithoutBasiq_userInput, bank_accountsUncheckedUpdateWithoutBasiq_userInput>
    create: XOR<bank_accountsCreateWithoutBasiq_userInput, bank_accountsUncheckedCreateWithoutBasiq_userInput>
  }

  export type bank_accountsUpdateWithWhereUniqueWithoutBasiq_userInput = {
    where: bank_accountsWhereUniqueInput
    data: XOR<bank_accountsUpdateWithoutBasiq_userInput, bank_accountsUncheckedUpdateWithoutBasiq_userInput>
  }

  export type bank_accountsUpdateManyWithWhereWithoutBasiq_userInput = {
    where: bank_accountsScalarWhereInput
    data: XOR<bank_accountsUpdateManyMutationInput, bank_accountsUncheckedUpdateManyWithoutBasiq_userInput>
  }

  export type bank_accountsScalarWhereInput = {
    AND?: bank_accountsScalarWhereInput | bank_accountsScalarWhereInput[]
    OR?: bank_accountsScalarWhereInput[]
    NOT?: bank_accountsScalarWhereInput | bank_accountsScalarWhereInput[]
    id?: UuidFilter<"bank_accounts"> | string
    basiq_user_id?: UuidFilter<"bank_accounts"> | string
    connection_id?: UuidFilter<"bank_accounts"> | string
    basiq_account_id?: StringFilter<"bank_accounts"> | string
    account_holder?: StringNullableFilter<"bank_accounts"> | string | null
    account_number?: StringNullableFilter<"bank_accounts"> | string | null
    bsb?: StringNullableFilter<"bank_accounts"> | string | null
    institution_name?: StringNullableFilter<"bank_accounts"> | string | null
    account_type?: StringNullableFilter<"bank_accounts"> | string | null
    account_name?: StringNullableFilter<"bank_accounts"> | string | null
    balance_available?: DecimalNullableFilter<"bank_accounts"> | Decimal | DecimalJsLike | number | string | null
    balance_current?: DecimalNullableFilter<"bank_accounts"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"bank_accounts"> | string | null
    status?: StringNullableFilter<"bank_accounts"> | string | null
    is_business_account?: BoolFilter<"bank_accounts"> | boolean
    last_synced?: DateTimeNullableFilter<"bank_accounts"> | Date | string | null
    created_at?: DateTimeFilter<"bank_accounts"> | Date | string
    updated_at?: DateTimeFilter<"bank_accounts"> | Date | string
  }

  export type basiq_usersCreateWithoutBank_connectionsInput = {
    id?: string
    basiq_user_id: string
    email: string
    mobile?: string | null
    connection_status?: string | null
    consent_id?: string | null
    consent_status?: string | null
    consent_expires_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutBasiq_usersInput
    bank_accounts?: bank_accountsCreateNestedManyWithoutBasiq_userInput
  }

  export type basiq_usersUncheckedCreateWithoutBank_connectionsInput = {
    id?: string
    user_id: string
    basiq_user_id: string
    email: string
    mobile?: string | null
    connection_status?: string | null
    consent_id?: string | null
    consent_status?: string | null
    consent_expires_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    bank_accounts?: bank_accountsUncheckedCreateNestedManyWithoutBasiq_userInput
  }

  export type basiq_usersCreateOrConnectWithoutBank_connectionsInput = {
    where: basiq_usersWhereUniqueInput
    create: XOR<basiq_usersCreateWithoutBank_connectionsInput, basiq_usersUncheckedCreateWithoutBank_connectionsInput>
  }

  export type bank_accountsCreateWithoutConnectionInput = {
    id?: string
    basiq_account_id: string
    account_holder?: string | null
    account_number?: string | null
    bsb?: string | null
    institution_name?: string | null
    account_type?: string | null
    account_name?: string | null
    balance_available?: Decimal | DecimalJsLike | number | string | null
    balance_current?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    is_business_account?: boolean
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    basiq_user: basiq_usersCreateNestedOneWithoutBank_accountsInput
    bank_transactions?: bank_transactionsCreateNestedManyWithoutBank_accountInput
  }

  export type bank_accountsUncheckedCreateWithoutConnectionInput = {
    id?: string
    basiq_user_id: string
    basiq_account_id: string
    account_holder?: string | null
    account_number?: string | null
    bsb?: string | null
    institution_name?: string | null
    account_type?: string | null
    account_name?: string | null
    balance_available?: Decimal | DecimalJsLike | number | string | null
    balance_current?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    is_business_account?: boolean
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    bank_transactions?: bank_transactionsUncheckedCreateNestedManyWithoutBank_accountInput
  }

  export type bank_accountsCreateOrConnectWithoutConnectionInput = {
    where: bank_accountsWhereUniqueInput
    create: XOR<bank_accountsCreateWithoutConnectionInput, bank_accountsUncheckedCreateWithoutConnectionInput>
  }

  export type bank_accountsCreateManyConnectionInputEnvelope = {
    data: bank_accountsCreateManyConnectionInput | bank_accountsCreateManyConnectionInput[]
    skipDuplicates?: boolean
  }

  export type basiq_usersUpsertWithoutBank_connectionsInput = {
    update: XOR<basiq_usersUpdateWithoutBank_connectionsInput, basiq_usersUncheckedUpdateWithoutBank_connectionsInput>
    create: XOR<basiq_usersCreateWithoutBank_connectionsInput, basiq_usersUncheckedCreateWithoutBank_connectionsInput>
    where?: basiq_usersWhereInput
  }

  export type basiq_usersUpdateToOneWithWhereWithoutBank_connectionsInput = {
    where?: basiq_usersWhereInput
    data: XOR<basiq_usersUpdateWithoutBank_connectionsInput, basiq_usersUncheckedUpdateWithoutBank_connectionsInput>
  }

  export type basiq_usersUpdateWithoutBank_connectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    connection_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_id?: NullableStringFieldUpdateOperationsInput | string | null
    consent_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBasiq_usersNestedInput
    bank_accounts?: bank_accountsUpdateManyWithoutBasiq_userNestedInput
  }

  export type basiq_usersUncheckedUpdateWithoutBank_connectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    basiq_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    connection_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_id?: NullableStringFieldUpdateOperationsInput | string | null
    consent_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bank_accounts?: bank_accountsUncheckedUpdateManyWithoutBasiq_userNestedInput
  }

  export type bank_accountsUpsertWithWhereUniqueWithoutConnectionInput = {
    where: bank_accountsWhereUniqueInput
    update: XOR<bank_accountsUpdateWithoutConnectionInput, bank_accountsUncheckedUpdateWithoutConnectionInput>
    create: XOR<bank_accountsCreateWithoutConnectionInput, bank_accountsUncheckedCreateWithoutConnectionInput>
  }

  export type bank_accountsUpdateWithWhereUniqueWithoutConnectionInput = {
    where: bank_accountsWhereUniqueInput
    data: XOR<bank_accountsUpdateWithoutConnectionInput, bank_accountsUncheckedUpdateWithoutConnectionInput>
  }

  export type bank_accountsUpdateManyWithWhereWithoutConnectionInput = {
    where: bank_accountsScalarWhereInput
    data: XOR<bank_accountsUpdateManyMutationInput, bank_accountsUncheckedUpdateManyWithoutConnectionInput>
  }

  export type basiq_usersCreateWithoutBank_accountsInput = {
    id?: string
    basiq_user_id: string
    email: string
    mobile?: string | null
    connection_status?: string | null
    consent_id?: string | null
    consent_status?: string | null
    consent_expires_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutBasiq_usersInput
    bank_connections?: bank_connectionsCreateNestedManyWithoutBasiq_userInput
  }

  export type basiq_usersUncheckedCreateWithoutBank_accountsInput = {
    id?: string
    user_id: string
    basiq_user_id: string
    email: string
    mobile?: string | null
    connection_status?: string | null
    consent_id?: string | null
    consent_status?: string | null
    consent_expires_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    bank_connections?: bank_connectionsUncheckedCreateNestedManyWithoutBasiq_userInput
  }

  export type basiq_usersCreateOrConnectWithoutBank_accountsInput = {
    where: basiq_usersWhereUniqueInput
    create: XOR<basiq_usersCreateWithoutBank_accountsInput, basiq_usersUncheckedCreateWithoutBank_accountsInput>
  }

  export type bank_connectionsCreateWithoutBank_accountsInput = {
    id?: string
    connection_id: string
    institution_id: string
    institution_name: string
    institution_short_name?: string | null
    institution_logo_url?: string | null
    status?: string | null
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    basiq_user: basiq_usersCreateNestedOneWithoutBank_connectionsInput
  }

  export type bank_connectionsUncheckedCreateWithoutBank_accountsInput = {
    id?: string
    basiq_user_id: string
    connection_id: string
    institution_id: string
    institution_name: string
    institution_short_name?: string | null
    institution_logo_url?: string | null
    status?: string | null
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type bank_connectionsCreateOrConnectWithoutBank_accountsInput = {
    where: bank_connectionsWhereUniqueInput
    create: XOR<bank_connectionsCreateWithoutBank_accountsInput, bank_connectionsUncheckedCreateWithoutBank_accountsInput>
  }

  export type bank_transactionsCreateWithoutBank_accountInput = {
    id?: string
    basiq_transaction_id: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    transaction_date: Date | string
    post_date?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    transaction_type?: string | null
    direction?: string | null
    category?: string | null
    subcategory?: string | null
    merchant_name?: string | null
    status?: string | null
    is_business_expense?: boolean
    tax_category?: string | null
    gst_amount?: Decimal | DecimalJsLike | number | string | null
    receipt_id?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type bank_transactionsUncheckedCreateWithoutBank_accountInput = {
    id?: string
    basiq_transaction_id: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    transaction_date: Date | string
    post_date?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    transaction_type?: string | null
    direction?: string | null
    category?: string | null
    subcategory?: string | null
    merchant_name?: string | null
    status?: string | null
    is_business_expense?: boolean
    tax_category?: string | null
    gst_amount?: Decimal | DecimalJsLike | number | string | null
    receipt_id?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type bank_transactionsCreateOrConnectWithoutBank_accountInput = {
    where: bank_transactionsWhereUniqueInput
    create: XOR<bank_transactionsCreateWithoutBank_accountInput, bank_transactionsUncheckedCreateWithoutBank_accountInput>
  }

  export type bank_transactionsCreateManyBank_accountInputEnvelope = {
    data: bank_transactionsCreateManyBank_accountInput | bank_transactionsCreateManyBank_accountInput[]
    skipDuplicates?: boolean
  }

  export type basiq_usersUpsertWithoutBank_accountsInput = {
    update: XOR<basiq_usersUpdateWithoutBank_accountsInput, basiq_usersUncheckedUpdateWithoutBank_accountsInput>
    create: XOR<basiq_usersCreateWithoutBank_accountsInput, basiq_usersUncheckedCreateWithoutBank_accountsInput>
    where?: basiq_usersWhereInput
  }

  export type basiq_usersUpdateToOneWithWhereWithoutBank_accountsInput = {
    where?: basiq_usersWhereInput
    data: XOR<basiq_usersUpdateWithoutBank_accountsInput, basiq_usersUncheckedUpdateWithoutBank_accountsInput>
  }

  export type basiq_usersUpdateWithoutBank_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    connection_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_id?: NullableStringFieldUpdateOperationsInput | string | null
    consent_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBasiq_usersNestedInput
    bank_connections?: bank_connectionsUpdateManyWithoutBasiq_userNestedInput
  }

  export type basiq_usersUncheckedUpdateWithoutBank_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    basiq_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    connection_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_id?: NullableStringFieldUpdateOperationsInput | string | null
    consent_status?: NullableStringFieldUpdateOperationsInput | string | null
    consent_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bank_connections?: bank_connectionsUncheckedUpdateManyWithoutBasiq_userNestedInput
  }

  export type bank_connectionsUpsertWithoutBank_accountsInput = {
    update: XOR<bank_connectionsUpdateWithoutBank_accountsInput, bank_connectionsUncheckedUpdateWithoutBank_accountsInput>
    create: XOR<bank_connectionsCreateWithoutBank_accountsInput, bank_connectionsUncheckedCreateWithoutBank_accountsInput>
    where?: bank_connectionsWhereInput
  }

  export type bank_connectionsUpdateToOneWithWhereWithoutBank_accountsInput = {
    where?: bank_connectionsWhereInput
    data: XOR<bank_connectionsUpdateWithoutBank_accountsInput, bank_connectionsUncheckedUpdateWithoutBank_accountsInput>
  }

  export type bank_connectionsUpdateWithoutBank_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    institution_id?: StringFieldUpdateOperationsInput | string
    institution_name?: StringFieldUpdateOperationsInput | string
    institution_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    institution_logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    basiq_user?: basiq_usersUpdateOneRequiredWithoutBank_connectionsNestedInput
  }

  export type bank_connectionsUncheckedUpdateWithoutBank_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_user_id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    institution_id?: StringFieldUpdateOperationsInput | string
    institution_name?: StringFieldUpdateOperationsInput | string
    institution_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    institution_logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bank_transactionsUpsertWithWhereUniqueWithoutBank_accountInput = {
    where: bank_transactionsWhereUniqueInput
    update: XOR<bank_transactionsUpdateWithoutBank_accountInput, bank_transactionsUncheckedUpdateWithoutBank_accountInput>
    create: XOR<bank_transactionsCreateWithoutBank_accountInput, bank_transactionsUncheckedCreateWithoutBank_accountInput>
  }

  export type bank_transactionsUpdateWithWhereUniqueWithoutBank_accountInput = {
    where: bank_transactionsWhereUniqueInput
    data: XOR<bank_transactionsUpdateWithoutBank_accountInput, bank_transactionsUncheckedUpdateWithoutBank_accountInput>
  }

  export type bank_transactionsUpdateManyWithWhereWithoutBank_accountInput = {
    where: bank_transactionsScalarWhereInput
    data: XOR<bank_transactionsUpdateManyMutationInput, bank_transactionsUncheckedUpdateManyWithoutBank_accountInput>
  }

  export type bank_transactionsScalarWhereInput = {
    AND?: bank_transactionsScalarWhereInput | bank_transactionsScalarWhereInput[]
    OR?: bank_transactionsScalarWhereInput[]
    NOT?: bank_transactionsScalarWhereInput | bank_transactionsScalarWhereInput[]
    id?: UuidFilter<"bank_transactions"> | string
    bank_account_id?: UuidFilter<"bank_transactions"> | string
    basiq_transaction_id?: StringFilter<"bank_transactions"> | string
    description?: StringNullableFilter<"bank_transactions"> | string | null
    amount?: DecimalFilter<"bank_transactions"> | Decimal | DecimalJsLike | number | string
    transaction_date?: DateTimeFilter<"bank_transactions"> | Date | string
    post_date?: DateTimeNullableFilter<"bank_transactions"> | Date | string | null
    balance?: DecimalNullableFilter<"bank_transactions"> | Decimal | DecimalJsLike | number | string | null
    transaction_type?: StringNullableFilter<"bank_transactions"> | string | null
    direction?: StringNullableFilter<"bank_transactions"> | string | null
    category?: StringNullableFilter<"bank_transactions"> | string | null
    subcategory?: StringNullableFilter<"bank_transactions"> | string | null
    merchant_name?: StringNullableFilter<"bank_transactions"> | string | null
    status?: StringNullableFilter<"bank_transactions"> | string | null
    is_business_expense?: BoolFilter<"bank_transactions"> | boolean
    tax_category?: StringNullableFilter<"bank_transactions"> | string | null
    gst_amount?: DecimalNullableFilter<"bank_transactions"> | Decimal | DecimalJsLike | number | string | null
    receipt_id?: UuidNullableFilter<"bank_transactions"> | string | null
    notes?: StringNullableFilter<"bank_transactions"> | string | null
    created_at?: DateTimeFilter<"bank_transactions"> | Date | string
    updated_at?: DateTimeFilter<"bank_transactions"> | Date | string
  }

  export type bank_accountsCreateWithoutBank_transactionsInput = {
    id?: string
    basiq_account_id: string
    account_holder?: string | null
    account_number?: string | null
    bsb?: string | null
    institution_name?: string | null
    account_type?: string | null
    account_name?: string | null
    balance_available?: Decimal | DecimalJsLike | number | string | null
    balance_current?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    is_business_account?: boolean
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    basiq_user: basiq_usersCreateNestedOneWithoutBank_accountsInput
    connection: bank_connectionsCreateNestedOneWithoutBank_accountsInput
  }

  export type bank_accountsUncheckedCreateWithoutBank_transactionsInput = {
    id?: string
    basiq_user_id: string
    connection_id: string
    basiq_account_id: string
    account_holder?: string | null
    account_number?: string | null
    bsb?: string | null
    institution_name?: string | null
    account_type?: string | null
    account_name?: string | null
    balance_available?: Decimal | DecimalJsLike | number | string | null
    balance_current?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    is_business_account?: boolean
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type bank_accountsCreateOrConnectWithoutBank_transactionsInput = {
    where: bank_accountsWhereUniqueInput
    create: XOR<bank_accountsCreateWithoutBank_transactionsInput, bank_accountsUncheckedCreateWithoutBank_transactionsInput>
  }

  export type bank_accountsUpsertWithoutBank_transactionsInput = {
    update: XOR<bank_accountsUpdateWithoutBank_transactionsInput, bank_accountsUncheckedUpdateWithoutBank_transactionsInput>
    create: XOR<bank_accountsCreateWithoutBank_transactionsInput, bank_accountsUncheckedCreateWithoutBank_transactionsInput>
    where?: bank_accountsWhereInput
  }

  export type bank_accountsUpdateToOneWithWhereWithoutBank_transactionsInput = {
    where?: bank_accountsWhereInput
    data: XOR<bank_accountsUpdateWithoutBank_transactionsInput, bank_accountsUncheckedUpdateWithoutBank_transactionsInput>
  }

  export type bank_accountsUpdateWithoutBank_transactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_account_id?: StringFieldUpdateOperationsInput | string
    account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bsb?: NullableStringFieldUpdateOperationsInput | string | null
    institution_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    balance_available?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balance_current?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_account?: BoolFieldUpdateOperationsInput | boolean
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    basiq_user?: basiq_usersUpdateOneRequiredWithoutBank_accountsNestedInput
    connection?: bank_connectionsUpdateOneRequiredWithoutBank_accountsNestedInput
  }

  export type bank_accountsUncheckedUpdateWithoutBank_transactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_user_id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    basiq_account_id?: StringFieldUpdateOperationsInput | string
    account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bsb?: NullableStringFieldUpdateOperationsInput | string | null
    institution_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    balance_available?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balance_current?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_account?: BoolFieldUpdateOperationsInput | boolean
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutBasiq_api_logsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBasiq_api_logsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBasiq_api_logsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBasiq_api_logsInput, UserUncheckedCreateWithoutBasiq_api_logsInput>
  }

  export type UserUpsertWithoutBasiq_api_logsInput = {
    update: XOR<UserUpdateWithoutBasiq_api_logsInput, UserUncheckedUpdateWithoutBasiq_api_logsInput>
    create: XOR<UserCreateWithoutBasiq_api_logsInput, UserUncheckedCreateWithoutBasiq_api_logsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBasiq_api_logsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBasiq_api_logsInput, UserUncheckedUpdateWithoutBasiq_api_logsInput>
  }

  export type UserUpdateWithoutBasiq_api_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBasiq_api_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutReceiptsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceiptsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceiptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceiptsInput, UserUncheckedCreateWithoutReceiptsInput>
  }

  export type UserUpsertWithoutReceiptsInput = {
    update: XOR<UserUpdateWithoutReceiptsInput, UserUncheckedUpdateWithoutReceiptsInput>
    create: XOR<UserCreateWithoutReceiptsInput, UserUncheckedCreateWithoutReceiptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceiptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceiptsInput, UserUncheckedUpdateWithoutReceiptsInput>
  }

  export type UserUpdateWithoutReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBudgetsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBudgetsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBudgetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBudgetsInput, UserUncheckedCreateWithoutBudgetsInput>
  }

  export type BudgetTrackingCreateWithoutBudgetInput = {
    id?: string
    month: number
    year: number
    predictedAmount: Decimal | DecimalJsLike | number | string
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    category?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBudgetTrackingInput
  }

  export type BudgetTrackingUncheckedCreateWithoutBudgetInput = {
    id?: string
    userId: string
    month: number
    year: number
    predictedAmount: Decimal | DecimalJsLike | number | string
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    category?: string | null
    createdAt?: Date | string
  }

  export type BudgetTrackingCreateOrConnectWithoutBudgetInput = {
    where: BudgetTrackingWhereUniqueInput
    create: XOR<BudgetTrackingCreateWithoutBudgetInput, BudgetTrackingUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetTrackingCreateManyBudgetInputEnvelope = {
    data: BudgetTrackingCreateManyBudgetInput | BudgetTrackingCreateManyBudgetInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBudgetsInput = {
    update: XOR<UserUpdateWithoutBudgetsInput, UserUncheckedUpdateWithoutBudgetsInput>
    create: XOR<UserCreateWithoutBudgetsInput, UserUncheckedCreateWithoutBudgetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBudgetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBudgetsInput, UserUncheckedUpdateWithoutBudgetsInput>
  }

  export type UserUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BudgetTrackingUpsertWithWhereUniqueWithoutBudgetInput = {
    where: BudgetTrackingWhereUniqueInput
    update: XOR<BudgetTrackingUpdateWithoutBudgetInput, BudgetTrackingUncheckedUpdateWithoutBudgetInput>
    create: XOR<BudgetTrackingCreateWithoutBudgetInput, BudgetTrackingUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetTrackingUpdateWithWhereUniqueWithoutBudgetInput = {
    where: BudgetTrackingWhereUniqueInput
    data: XOR<BudgetTrackingUpdateWithoutBudgetInput, BudgetTrackingUncheckedUpdateWithoutBudgetInput>
  }

  export type BudgetTrackingUpdateManyWithWhereWithoutBudgetInput = {
    where: BudgetTrackingScalarWhereInput
    data: XOR<BudgetTrackingUpdateManyMutationInput, BudgetTrackingUncheckedUpdateManyWithoutBudgetInput>
  }

  export type BudgetCreateWithoutBudgetTrackingInput = {
    id?: string
    name?: string | null
    monthlyBudget: Decimal | DecimalJsLike | number | string
    targetSavings?: Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: Decimal | DecimalJsLike | number | string | null
    predictions?: NullableJsonNullValueInput | InputJsonValue
    categoryLimits?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    aiProvider?: string | null
    aiModel?: string | null
    analysisPeriod?: string | null
    predictionPeriod?: string | null
    status?: $Enums.BudgetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBudgetsInput
  }

  export type BudgetUncheckedCreateWithoutBudgetTrackingInput = {
    id?: string
    userId: string
    name?: string | null
    monthlyBudget: Decimal | DecimalJsLike | number | string
    targetSavings?: Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: Decimal | DecimalJsLike | number | string | null
    predictions?: NullableJsonNullValueInput | InputJsonValue
    categoryLimits?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    aiProvider?: string | null
    aiModel?: string | null
    analysisPeriod?: string | null
    predictionPeriod?: string | null
    status?: $Enums.BudgetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCreateOrConnectWithoutBudgetTrackingInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutBudgetTrackingInput, BudgetUncheckedCreateWithoutBudgetTrackingInput>
  }

  export type UserCreateWithoutBudgetTrackingInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBudgetTrackingInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBudgetTrackingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBudgetTrackingInput, UserUncheckedCreateWithoutBudgetTrackingInput>
  }

  export type BudgetUpsertWithoutBudgetTrackingInput = {
    update: XOR<BudgetUpdateWithoutBudgetTrackingInput, BudgetUncheckedUpdateWithoutBudgetTrackingInput>
    create: XOR<BudgetCreateWithoutBudgetTrackingInput, BudgetUncheckedCreateWithoutBudgetTrackingInput>
    where?: BudgetWhereInput
  }

  export type BudgetUpdateToOneWithWhereWithoutBudgetTrackingInput = {
    where?: BudgetWhereInput
    data: XOR<BudgetUpdateWithoutBudgetTrackingInput, BudgetUncheckedUpdateWithoutBudgetTrackingInput>
  }

  export type BudgetUpdateWithoutBudgetTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    predictions?: NullableJsonNullValueInput | InputJsonValue
    categoryLimits?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    analysisPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    predictionPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBudgetsNestedInput
  }

  export type BudgetUncheckedUpdateWithoutBudgetTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    predictions?: NullableJsonNullValueInput | InputJsonValue
    categoryLimits?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    analysisPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    predictionPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutBudgetTrackingInput = {
    update: XOR<UserUpdateWithoutBudgetTrackingInput, UserUncheckedUpdateWithoutBudgetTrackingInput>
    create: XOR<UserCreateWithoutBudgetTrackingInput, UserUncheckedCreateWithoutBudgetTrackingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBudgetTrackingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBudgetTrackingInput, UserUncheckedUpdateWithoutBudgetTrackingInput>
  }

  export type UserUpdateWithoutBudgetTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBudgetTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFinancialInsightsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFinancialInsightsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFinancialInsightsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFinancialInsightsInput, UserUncheckedCreateWithoutFinancialInsightsInput>
  }

  export type UserUpsertWithoutFinancialInsightsInput = {
    update: XOR<UserUpdateWithoutFinancialInsightsInput, UserUncheckedUpdateWithoutFinancialInsightsInput>
    create: XOR<UserCreateWithoutFinancialInsightsInput, UserUncheckedCreateWithoutFinancialInsightsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFinancialInsightsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFinancialInsightsInput, UserUncheckedUpdateWithoutFinancialInsightsInput>
  }

  export type UserUpdateWithoutFinancialInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFinancialInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutGoalsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGoalsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGoalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGoalsInput, UserUncheckedCreateWithoutGoalsInput>
  }

  export type UserUpsertWithoutGoalsInput = {
    update: XOR<UserUpdateWithoutGoalsInput, UserUncheckedUpdateWithoutGoalsInput>
    create: XOR<UserCreateWithoutGoalsInput, UserUncheckedCreateWithoutGoalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGoalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGoalsInput, UserUncheckedUpdateWithoutGoalsInput>
  }

  export type UserUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAmlMonitoringInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAmlMonitoringInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAmlMonitoringInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAmlMonitoringInput, UserUncheckedCreateWithoutAmlMonitoringInput>
  }

  export type UserUpsertWithoutAmlMonitoringInput = {
    update: XOR<UserUpdateWithoutAmlMonitoringInput, UserUncheckedUpdateWithoutAmlMonitoringInput>
    create: XOR<UserCreateWithoutAmlMonitoringInput, UserUncheckedCreateWithoutAmlMonitoringInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAmlMonitoringInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAmlMonitoringInput, UserUncheckedUpdateWithoutAmlMonitoringInput>
  }

  export type UserUpdateWithoutAmlMonitoringInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAmlMonitoringInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPrivacyConsentsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPrivacyConsentsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    dataAccessRequests?: DataAccessRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPrivacyConsentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPrivacyConsentsInput, UserUncheckedCreateWithoutPrivacyConsentsInput>
  }

  export type UserUpsertWithoutPrivacyConsentsInput = {
    update: XOR<UserUpdateWithoutPrivacyConsentsInput, UserUncheckedUpdateWithoutPrivacyConsentsInput>
    create: XOR<UserCreateWithoutPrivacyConsentsInput, UserUncheckedCreateWithoutPrivacyConsentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPrivacyConsentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPrivacyConsentsInput, UserUncheckedUpdateWithoutPrivacyConsentsInput>
  }

  export type UserUpdateWithoutPrivacyConsentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPrivacyConsentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    dataAccessRequests?: DataAccessRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDataAccessRequestsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsCreateNestedManyWithoutUserInput
    receipts?: ReceiptCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDataAccessRequestsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name: string
    phone?: string | null
    password?: string | null
    image?: string | null
    role?: $Enums.Role
    abn?: string | null
    tfn?: string | null
    taxResidency?: $Enums.TaxResidency
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    taxReturns?: TaxReturnUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    aiUsageTracking?: AIUsageTrackingUncheckedCreateNestedManyWithoutUserInput
    basiq_users?: basiq_usersUncheckedCreateNestedOneWithoutUserInput
    basiq_api_logs?: basiq_api_logsUncheckedCreateNestedManyWithoutUserInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    budgetTracking?: BudgetTrackingUncheckedCreateNestedManyWithoutUserInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    financialAuditLogs?: FinancialAuditLogUncheckedCreateNestedManyWithoutUserInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedCreateNestedManyWithoutUserInput
    privacyConsents?: PrivacyConsentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDataAccessRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDataAccessRequestsInput, UserUncheckedCreateWithoutDataAccessRequestsInput>
  }

  export type UserUpsertWithoutDataAccessRequestsInput = {
    update: XOR<UserUpdateWithoutDataAccessRequestsInput, UserUncheckedUpdateWithoutDataAccessRequestsInput>
    create: XOR<UserCreateWithoutDataAccessRequestsInput, UserUncheckedCreateWithoutDataAccessRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDataAccessRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDataAccessRequestsInput, UserUncheckedUpdateWithoutDataAccessRequestsInput>
  }

  export type UserUpdateWithoutDataAccessRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDataAccessRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    tfn?: NullableStringFieldUpdateOperationsInput | string | null
    taxResidency?: EnumTaxResidencyFieldUpdateOperationsInput | $Enums.TaxResidency
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    taxReturns?: TaxReturnUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    aiUsageTracking?: AIUsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    basiq_users?: basiq_usersUncheckedUpdateOneWithoutUserNestedInput
    basiq_api_logs?: basiq_api_logsUncheckedUpdateManyWithoutUserNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutUserNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    financialAuditLogs?: FinancialAuditLogUncheckedUpdateManyWithoutUserNestedInput
    amlMonitoring?: AMLTransactionMonitoringUncheckedUpdateManyWithoutUserNestedInput
    privacyConsents?: PrivacyConsentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    event: $Enums.AuthEvent
    ipAddress: string
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    success?: boolean
    createdAt?: Date | string
  }

  export type SubscriptionCreateManyUserInput = {
    id?: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    stripePriceId: string
    status: string
    plan: $Enums.Plan
    interval?: string
    amount: number
    currency?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    cancelledAt?: Date | string | null
    trialEnd?: Date | string | null
    defaultPaymentMethodId?: string | null
    lastPaymentAttempt?: Date | string | null
    failedPaymentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxReturnCreateManyUserInput = {
    id?: string
    year: string
    data: JsonNullValueInput | InputJsonValue
    status?: $Enums.TaxReturnStatus
    submittedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    stripePaymentIntentId: string
    amount: number
    currency: string
    status: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIConversationCreateManyUserInput = {
    id?: string
    sessionId: string
    provider: string
    model: string
    messages: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: number
    costUsd?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIInsightCreateManyUserInput = {
    id?: string
    insightType: string
    category: string
    content: JsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: AIInsightCreatesourceDataIdsInput | string[]
    provider: string
    model: string
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AIUsageTrackingCreateManyUserInput = {
    id?: string
    provider: string
    model: string
    operationType: string
    tokensInput?: number
    tokensOutput?: number
    costUsd?: Decimal | DecimalJsLike | number | string
    responseTimeMs?: number | null
    success?: boolean
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type basiq_api_logsCreateManyUserInput = {
    id?: string
    endpoint: string
    method: string
    request_body?: NullableJsonNullValueInput | InputJsonValue
    response_status?: number | null
    response_body?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    duration_ms?: number | null
    created_at?: Date | string
  }

  export type ReceiptCreateManyUserInput = {
    id?: string
    merchant?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    gstAmount?: Decimal | DecimalJsLike | number | string | null
    date: Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    aiProcessed?: boolean
    aiConfidence?: Decimal | DecimalJsLike | number | string | null
    aiProvider?: string | null
    aiModel?: string | null
    processingStatus?: $Enums.ReceiptStatus
    abn?: string | null
    taxInvoiceNumber?: string | null
    taxCategory?: string | null
    isGstRegistered?: boolean
    matchedTransactionId?: string | null
    matchConfidence?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCreateManyUserInput = {
    id?: string
    name?: string | null
    monthlyBudget: Decimal | DecimalJsLike | number | string
    targetSavings?: Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: Decimal | DecimalJsLike | number | string | null
    predictions?: NullableJsonNullValueInput | InputJsonValue
    categoryLimits?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    aiProvider?: string | null
    aiModel?: string | null
    analysisPeriod?: string | null
    predictionPeriod?: string | null
    status?: $Enums.BudgetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetTrackingCreateManyUserInput = {
    id?: string
    budgetId: string
    month: number
    year: number
    predictedAmount: Decimal | DecimalJsLike | number | string
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    category?: string | null
    createdAt?: Date | string
  }

  export type FinancialInsightCreateManyUserInput = {
    id?: string
    insightType: string
    category?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: FinancialInsightCreatesourceDataIdsInput | string[]
    provider?: string | null
    model?: string | null
    title?: string | null
    description?: string | null
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    priority?: $Enums.InsightPriority
    isActive?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type GoalCreateManyUserInput = {
    id?: string
    title: string
    targetAmount: Decimal | DecimalJsLike | number | string
    currentAmount?: Decimal | DecimalJsLike | number | string
    targetDate: Date | string
    category?: string | null
    status?: $Enums.GoalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialAuditLogCreateManyUserInput = {
    id?: string
    sessionId?: string | null
    operationType: $Enums.FinancialOperation
    resourceType: string
    resourceId?: string | null
    ipAddress: string
    userAgent?: string | null
    httpMethod?: string | null
    endpoint?: string | null
    previousData?: NullableJsonNullValueInput | InputJsonValue
    currentData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: FinancialAuditLogCreatechangedFieldsInput | string[]
    amount?: Decimal | DecimalJsLike | number | string | null
    gstAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    taxYear?: string | null
    success?: boolean
    errorMessage?: string | null
    hashChain?: string | null
    previousHash?: string | null
    createdAt?: Date | string
    timezone?: string
  }

  export type AMLTransactionMonitoringCreateManyUserInput = {
    id?: string
    transactionId?: string | null
    monitoringType: $Enums.AMLMonitoringType
    riskScore: Decimal | DecimalJsLike | number | string
    riskFactors?: AMLTransactionMonitoringCreateriskFactorsInput | string[]
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    patternType?: string | null
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    velocityScore?: Decimal | DecimalJsLike | number | string | null
    requiresReview?: boolean
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reportedToAUSTRAC?: boolean
    reportReference?: string | null
    reportedAt?: Date | string | null
    falsePositive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivacyConsentCreateManyUserInput = {
    id?: string
    consentType: $Enums.ConsentType
    consentVersion: string
    consentStatus?: $Enums.ConsentStatus
    consentDate?: Date | string | null
    expiryDate?: Date | string | null
    purposes?: PrivacyConsentCreatepurposesInput | string[]
    dataCategories?: PrivacyConsentCreatedataCategoriesInput | string[]
    thirdParties?: PrivacyConsentCreatethirdPartiesInput | string[]
    withdrawnAt?: Date | string | null
    withdrawalReason?: string | null
    legalBasis: string
    jurisdiction?: string
    ipAddress: string
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataAccessRequestCreateManyUserInput = {
    id?: string
    requestType: $Enums.DataRequestType
    requestStatus?: $Enums.DataRequestStatus
    requestDate?: Date | string
    requestDetails?: NullableJsonNullValueInput | InputJsonValue
    verificationMethod?: string | null
    verifiedAt?: Date | string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    completedAt?: Date | string | null
    responseMethod?: string | null
    responseUrl?: string | null
    responseExpiryDate?: Date | string | null
    dueDate: Date | string
    extensionReason?: string | null
    extendedDueDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: EnumAuthEventFieldUpdateOperationsInput | $Enums.AuthEvent
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: EnumAuthEventFieldUpdateOperationsInput | $Enums.AuthEvent
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: EnumAuthEventFieldUpdateOperationsInput | $Enums.AuthEvent
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    interval?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedPaymentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    interval?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedPaymentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    interval?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedPaymentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxReturnUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumTaxReturnStatusFieldUpdateOperationsInput | $Enums.TaxReturnStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxReturnUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumTaxReturnStatusFieldUpdateOperationsInput | $Enums.TaxReturnStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxReturnUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumTaxReturnStatusFieldUpdateOperationsInput | $Enums.TaxReturnStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInsightUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: AIInsightUpdatesourceDataIdsInput | string[]
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInsightUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: AIInsightUpdatesourceDataIdsInput | string[]
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInsightUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: AIInsightUpdatesourceDataIdsInput | string[]
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageTrackingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    tokensInput?: IntFieldUpdateOperationsInput | number
    tokensOutput?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageTrackingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    tokensInput?: IntFieldUpdateOperationsInput | number
    tokensOutput?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageTrackingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    tokensInput?: IntFieldUpdateOperationsInput | number
    tokensOutput?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type basiq_api_logsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    request_body?: NullableJsonNullValueInput | InputJsonValue
    response_status?: NullableIntFieldUpdateOperationsInput | number | null
    response_body?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type basiq_api_logsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    request_body?: NullableJsonNullValueInput | InputJsonValue
    response_status?: NullableIntFieldUpdateOperationsInput | number | null
    response_body?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type basiq_api_logsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    request_body?: NullableJsonNullValueInput | InputJsonValue
    response_status?: NullableIntFieldUpdateOperationsInput | number | null
    response_body?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gstAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    processingStatus?: EnumReceiptStatusFieldUpdateOperationsInput | $Enums.ReceiptStatus
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    taxInvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxCategory?: NullableStringFieldUpdateOperationsInput | string | null
    isGstRegistered?: BoolFieldUpdateOperationsInput | boolean
    matchedTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gstAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    processingStatus?: EnumReceiptStatusFieldUpdateOperationsInput | $Enums.ReceiptStatus
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    taxInvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxCategory?: NullableStringFieldUpdateOperationsInput | string | null
    isGstRegistered?: BoolFieldUpdateOperationsInput | boolean
    matchedTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gstAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    processingStatus?: EnumReceiptStatusFieldUpdateOperationsInput | $Enums.ReceiptStatus
    abn?: NullableStringFieldUpdateOperationsInput | string | null
    taxInvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxCategory?: NullableStringFieldUpdateOperationsInput | string | null
    isGstRegistered?: BoolFieldUpdateOperationsInput | boolean
    matchedTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    predictions?: NullableJsonNullValueInput | InputJsonValue
    categoryLimits?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    analysisPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    predictionPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetTracking?: BudgetTrackingUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    predictions?: NullableJsonNullValueInput | InputJsonValue
    categoryLimits?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    analysisPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    predictionPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetTracking?: BudgetTrackingUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthlyIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    predictions?: NullableJsonNullValueInput | InputJsonValue
    categoryLimits?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    analysisPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    predictionPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetTrackingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    predictedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: BudgetUpdateOneRequiredWithoutBudgetTrackingNestedInput
  }

  export type BudgetTrackingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    predictedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetTrackingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    predictedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialInsightUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: FinancialInsightUpdatesourceDataIdsInput | string[]
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    priority?: EnumInsightPriorityFieldUpdateOperationsInput | $Enums.InsightPriority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FinancialInsightUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: FinancialInsightUpdatesourceDataIdsInput | string[]
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    priority?: EnumInsightPriorityFieldUpdateOperationsInput | $Enums.InsightPriority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FinancialInsightUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sourceDataIds?: FinancialInsightUpdatesourceDataIdsInput | string[]
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    priority?: EnumInsightPriorityFieldUpdateOperationsInput | $Enums.InsightPriority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GoalUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialAuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    operationType?: EnumFinancialOperationFieldUpdateOperationsInput | $Enums.FinancialOperation
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    httpMethod?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    previousData?: NullableJsonNullValueInput | InputJsonValue
    currentData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: FinancialAuditLogUpdatechangedFieldsInput | string[]
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gstAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    taxYear?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    hashChain?: NullableStringFieldUpdateOperationsInput | string | null
    previousHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
  }

  export type FinancialAuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    operationType?: EnumFinancialOperationFieldUpdateOperationsInput | $Enums.FinancialOperation
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    httpMethod?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    previousData?: NullableJsonNullValueInput | InputJsonValue
    currentData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: FinancialAuditLogUpdatechangedFieldsInput | string[]
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gstAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    taxYear?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    hashChain?: NullableStringFieldUpdateOperationsInput | string | null
    previousHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
  }

  export type FinancialAuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    operationType?: EnumFinancialOperationFieldUpdateOperationsInput | $Enums.FinancialOperation
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    httpMethod?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    previousData?: NullableJsonNullValueInput | InputJsonValue
    currentData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: FinancialAuditLogUpdatechangedFieldsInput | string[]
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gstAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    taxYear?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    hashChain?: NullableStringFieldUpdateOperationsInput | string | null
    previousHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
  }

  export type AMLTransactionMonitoringUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    monitoringType?: EnumAMLMonitoringTypeFieldUpdateOperationsInput | $Enums.AMLMonitoringType
    riskScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskFactors?: AMLTransactionMonitoringUpdateriskFactorsInput | string[]
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    patternType?: NullableStringFieldUpdateOperationsInput | string | null
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    velocityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportedToAUSTRAC?: BoolFieldUpdateOperationsInput | boolean
    reportReference?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    falsePositive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AMLTransactionMonitoringUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    monitoringType?: EnumAMLMonitoringTypeFieldUpdateOperationsInput | $Enums.AMLMonitoringType
    riskScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskFactors?: AMLTransactionMonitoringUpdateriskFactorsInput | string[]
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    patternType?: NullableStringFieldUpdateOperationsInput | string | null
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    velocityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportedToAUSTRAC?: BoolFieldUpdateOperationsInput | boolean
    reportReference?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    falsePositive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AMLTransactionMonitoringUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    monitoringType?: EnumAMLMonitoringTypeFieldUpdateOperationsInput | $Enums.AMLMonitoringType
    riskScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskFactors?: AMLTransactionMonitoringUpdateriskFactorsInput | string[]
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    patternType?: NullableStringFieldUpdateOperationsInput | string | null
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    velocityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportedToAUSTRAC?: BoolFieldUpdateOperationsInput | boolean
    reportReference?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    falsePositive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivacyConsentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentType?: EnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType
    consentVersion?: StringFieldUpdateOperationsInput | string
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purposes?: PrivacyConsentUpdatepurposesInput | string[]
    dataCategories?: PrivacyConsentUpdatedataCategoriesInput | string[]
    thirdParties?: PrivacyConsentUpdatethirdPartiesInput | string[]
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasis?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivacyConsentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentType?: EnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType
    consentVersion?: StringFieldUpdateOperationsInput | string
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purposes?: PrivacyConsentUpdatepurposesInput | string[]
    dataCategories?: PrivacyConsentUpdatedataCategoriesInput | string[]
    thirdParties?: PrivacyConsentUpdatethirdPartiesInput | string[]
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasis?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivacyConsentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentType?: EnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType
    consentVersion?: StringFieldUpdateOperationsInput | string
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purposes?: PrivacyConsentUpdatepurposesInput | string[]
    dataCategories?: PrivacyConsentUpdatedataCategoriesInput | string[]
    thirdParties?: PrivacyConsentUpdatethirdPartiesInput | string[]
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasis?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataAccessRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumDataRequestTypeFieldUpdateOperationsInput | $Enums.DataRequestType
    requestStatus?: EnumDataRequestStatusFieldUpdateOperationsInput | $Enums.DataRequestStatus
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requestDetails?: NullableJsonNullValueInput | InputJsonValue
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseMethod?: NullableStringFieldUpdateOperationsInput | string | null
    responseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    responseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataAccessRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumDataRequestTypeFieldUpdateOperationsInput | $Enums.DataRequestType
    requestStatus?: EnumDataRequestStatusFieldUpdateOperationsInput | $Enums.DataRequestStatus
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requestDetails?: NullableJsonNullValueInput | InputJsonValue
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseMethod?: NullableStringFieldUpdateOperationsInput | string | null
    responseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    responseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataAccessRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumDataRequestTypeFieldUpdateOperationsInput | $Enums.DataRequestType
    requestStatus?: EnumDataRequestStatusFieldUpdateOperationsInput | $Enums.DataRequestStatus
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requestDetails?: NullableJsonNullValueInput | InputJsonValue
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseMethod?: NullableStringFieldUpdateOperationsInput | string | null
    responseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    responseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemCreateManyInvoiceInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bank_connectionsCreateManyBasiq_userInput = {
    id?: string
    connection_id: string
    institution_id: string
    institution_name: string
    institution_short_name?: string | null
    institution_logo_url?: string | null
    status?: string | null
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type bank_accountsCreateManyBasiq_userInput = {
    id?: string
    connection_id: string
    basiq_account_id: string
    account_holder?: string | null
    account_number?: string | null
    bsb?: string | null
    institution_name?: string | null
    account_type?: string | null
    account_name?: string | null
    balance_available?: Decimal | DecimalJsLike | number | string | null
    balance_current?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    is_business_account?: boolean
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type bank_connectionsUpdateWithoutBasiq_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    institution_id?: StringFieldUpdateOperationsInput | string
    institution_name?: StringFieldUpdateOperationsInput | string
    institution_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    institution_logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bank_accounts?: bank_accountsUpdateManyWithoutConnectionNestedInput
  }

  export type bank_connectionsUncheckedUpdateWithoutBasiq_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    institution_id?: StringFieldUpdateOperationsInput | string
    institution_name?: StringFieldUpdateOperationsInput | string
    institution_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    institution_logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bank_accounts?: bank_accountsUncheckedUpdateManyWithoutConnectionNestedInput
  }

  export type bank_connectionsUncheckedUpdateManyWithoutBasiq_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    institution_id?: StringFieldUpdateOperationsInput | string
    institution_name?: StringFieldUpdateOperationsInput | string
    institution_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    institution_logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bank_accountsUpdateWithoutBasiq_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_account_id?: StringFieldUpdateOperationsInput | string
    account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bsb?: NullableStringFieldUpdateOperationsInput | string | null
    institution_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    balance_available?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balance_current?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_account?: BoolFieldUpdateOperationsInput | boolean
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    connection?: bank_connectionsUpdateOneRequiredWithoutBank_accountsNestedInput
    bank_transactions?: bank_transactionsUpdateManyWithoutBank_accountNestedInput
  }

  export type bank_accountsUncheckedUpdateWithoutBasiq_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    basiq_account_id?: StringFieldUpdateOperationsInput | string
    account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bsb?: NullableStringFieldUpdateOperationsInput | string | null
    institution_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    balance_available?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balance_current?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_account?: BoolFieldUpdateOperationsInput | boolean
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bank_transactions?: bank_transactionsUncheckedUpdateManyWithoutBank_accountNestedInput
  }

  export type bank_accountsUncheckedUpdateManyWithoutBasiq_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    basiq_account_id?: StringFieldUpdateOperationsInput | string
    account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bsb?: NullableStringFieldUpdateOperationsInput | string | null
    institution_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    balance_available?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balance_current?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_account?: BoolFieldUpdateOperationsInput | boolean
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bank_accountsCreateManyConnectionInput = {
    id?: string
    basiq_user_id: string
    basiq_account_id: string
    account_holder?: string | null
    account_number?: string | null
    bsb?: string | null
    institution_name?: string | null
    account_type?: string | null
    account_name?: string | null
    balance_available?: Decimal | DecimalJsLike | number | string | null
    balance_current?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    is_business_account?: boolean
    last_synced?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type bank_accountsUpdateWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_account_id?: StringFieldUpdateOperationsInput | string
    account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bsb?: NullableStringFieldUpdateOperationsInput | string | null
    institution_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    balance_available?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balance_current?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_account?: BoolFieldUpdateOperationsInput | boolean
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    basiq_user?: basiq_usersUpdateOneRequiredWithoutBank_accountsNestedInput
    bank_transactions?: bank_transactionsUpdateManyWithoutBank_accountNestedInput
  }

  export type bank_accountsUncheckedUpdateWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_user_id?: StringFieldUpdateOperationsInput | string
    basiq_account_id?: StringFieldUpdateOperationsInput | string
    account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bsb?: NullableStringFieldUpdateOperationsInput | string | null
    institution_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    balance_available?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balance_current?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_account?: BoolFieldUpdateOperationsInput | boolean
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bank_transactions?: bank_transactionsUncheckedUpdateManyWithoutBank_accountNestedInput
  }

  export type bank_accountsUncheckedUpdateManyWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_user_id?: StringFieldUpdateOperationsInput | string
    basiq_account_id?: StringFieldUpdateOperationsInput | string
    account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bsb?: NullableStringFieldUpdateOperationsInput | string | null
    institution_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    balance_available?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balance_current?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_account?: BoolFieldUpdateOperationsInput | boolean
    last_synced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bank_transactionsCreateManyBank_accountInput = {
    id?: string
    basiq_transaction_id: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    transaction_date: Date | string
    post_date?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    transaction_type?: string | null
    direction?: string | null
    category?: string | null
    subcategory?: string | null
    merchant_name?: string | null
    status?: string | null
    is_business_expense?: boolean
    tax_category?: string | null
    gst_amount?: Decimal | DecimalJsLike | number | string | null
    receipt_id?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type bank_transactionsUpdateWithoutBank_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_transaction_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    post_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transaction_type?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_expense?: BoolFieldUpdateOperationsInput | boolean
    tax_category?: NullableStringFieldUpdateOperationsInput | string | null
    gst_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    receipt_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bank_transactionsUncheckedUpdateWithoutBank_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_transaction_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    post_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transaction_type?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_expense?: BoolFieldUpdateOperationsInput | boolean
    tax_category?: NullableStringFieldUpdateOperationsInput | string | null
    gst_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    receipt_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bank_transactionsUncheckedUpdateManyWithoutBank_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    basiq_transaction_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    post_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transaction_type?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    is_business_expense?: BoolFieldUpdateOperationsInput | boolean
    tax_category?: NullableStringFieldUpdateOperationsInput | string | null
    gst_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    receipt_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetTrackingCreateManyBudgetInput = {
    id?: string
    userId: string
    month: number
    year: number
    predictedAmount: Decimal | DecimalJsLike | number | string
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    category?: string | null
    createdAt?: Date | string
  }

  export type BudgetTrackingUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    predictedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBudgetTrackingNestedInput
  }

  export type BudgetTrackingUncheckedUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    predictedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetTrackingUncheckedUpdateManyWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    predictedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}